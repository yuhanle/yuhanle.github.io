<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>煜寒了</title>
  
  <subtitle>关心粮食和蔬菜</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.yuhanle.com/"/>
  <updated>2021-10-21T08:18:48.335Z</updated>
  <id>https://blog.yuhanle.com/</id>
  
  <author>
    <name>煜寒了</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用 fastlane 进行 iOS 打包</title>
    <link href="https://blog.yuhanle.com/2018/08/06/fastlane-say-here/"/>
    <id>https://blog.yuhanle.com/2018/08/06/fastlane-say-here/</id>
    <published>2018-08-06T01:00:00.000Z</published>
    <updated>2021-10-21T08:18:48.335Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://docs.fastlane.tools/img/fastlane_text.png" alt></p><p><a href="https://fastlane.tools/" target="_blank" rel="noopener">fastlane</a> 是一个通过简单命令来完成诸如截图、获取证书、编译、导出安装包、提交 iTunesConnect 等一系列操作的工具，它同时支持 iOS 和 Android。 </p><a id="more"></a><table><thead><tr><th style="text-align:center"></th><th>fastlane</th></tr></thead><tbody><tr><td style="text-align:center">🚀</td><td>Save <strong>hours</strong> every time you push a new release to the store or beta testing service</td></tr><tr><td style="text-align:center">✨</td><td>Integrates with all your existing tools and services (170 actions currently)</td></tr><tr><td style="text-align:center">📖</td><td>100% open source under the MIT license</td></tr><tr><td style="text-align:center">🎩</td><td>Easy setup assistant to get started in a few minutes</td></tr><tr><td style="text-align:center">⚒</td><td>Runs on <strong>your</strong> machine, it’s your app and your data</td></tr><tr><td style="text-align:center">👻</td><td>Integrates with all major CI systems</td></tr><tr><td style="text-align:center">🖥</td><td>Supports iOS, Mac, and Android apps</td></tr><tr><td style="text-align:center">🔧</td><td>Extend and customise <em>fastlane</em> to fit your needs, you’re not dependent on anyone</td></tr><tr><td style="text-align:center">💭</td><td>Never remember any commands any more, just <em>fastlane</em></td></tr><tr><td style="text-align:center">🚢</td><td>Deploy from any computer, including a CI server</td></tr></tbody></table><p>你能够通过简单的方式配置流程进行的顺序，并通过非常简单的命令执行其中的一个流程。当然它的简单并不代表功能也简陋，有开源社区的支持，更新迅速且有很多功能能够满足你的需求。</p><p><img src="http://cdn.yuhanle.com/fastlane/2017-12-21-fastlane01.png" alt></p><h2 id="为什么使用它"><a href="#为什么使用它" class="headerlink" title="为什么使用它"></a>为什么使用它</h2><p>作为公司的 iOS 程序员，少不了在发布应用的时候各种等待。标准的手动发布流程是：编译-&gt;打包上传-&gt;填写应用更新数据-&gt;等待 iTunesConnect 编译-&gt;选择版本发布，整个过程大概需要 30 分钟左右。关键是这个过程就像windows 装系统一样，虽然手动参与的不多，但是要一直守在电脑前等着。</p><p>刚开始用 fastlane，发现其使用和配置还算简单，有开源社区支持，更新迅速功能强大。且相比 jenkins 里的插件，fastlane 可以单独使用，也可以被<strong><a href="https://docs.fastlane.tools/best-practices/continuous-integration/" target="_blank" rel="noopener">多种CI </a></strong>接入。</p><p>程序员这么懒，一定会想办法让他自动化的。后来发现特别懒的 <a href="https://github.com/KrauseFx" target="_blank" rel="noopener">Felix Krause</a> 写的 <a href="https://docs.fastlane.tools/" target="_blank" rel="noopener">Fastlane</a>，Fastlane可以非常快速简单的搭建一个自动化发布服务，并且支持 <code>Android</code>，<code>iOS</code>，<code>MacOS</code>。他可以实现一条命令从<strong>编译</strong>到<strong>选版发布</strong>全程不用干预。作为程序员的你只要一条命令，看集美剧，发布就完成了。截止刚刚 Fastlane 官网上宣称已经为程序员节省了<strong>13,746,550小时+</strong>。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li>提交时执行测试（包括单元测试和集成测试）；</li><li>构建并分发内部测试，公开测试版本；</li><li>构建生产版本并上传至 ITC（包括更新配置文件，创建新的屏幕截图，上传应用并提交审核）；</li><li>…</li></ul><h2 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h2><ul><li>会编程</li><li>Xcode7+</li><li>Mac OS 10.11+</li></ul><h2 id="工具集"><a href="#工具集" class="headerlink" title="工具集"></a>工具集</h2><p><code>fastlane</code> 将如下的工具套件有机地结合起来,从管理证书到单元测试,从编译打包到上传发布,都能通过命令行轻松完成.该套件支持与 <code>Jenkins</code> 和 <code>CocoaPods</code>，<code>xctools</code> 等其他第三方工具的集成,并且能够定义多个通道（lanes）以支持不同的部署目标。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul><li><a href="https://github.com/fastlane/fastlane/tree/master/scan" target="_blank" rel="noopener">scan</a> =&gt; 自动运行测试工具，并且可以生成漂亮的 HTML 报告</li></ul><h3 id="证书，配置文件"><a href="#证书，配置文件" class="headerlink" title="证书，配置文件"></a>证书，配置文件</h3><ul><li><a href="https://github.com/fastlane/fastlane/tree/master/cert" target="_blank" rel="noopener">cert</a> =&gt; 自动创建管理 iOS 代码签名证书</li><li><a href="https://github.com/fastlane/fastlane/tree/master/sigh" target="_blank" rel="noopener">sigh</a> =&gt; 一声叹息啊，这么多年和 <code>Provisioning Profile</code>战斗过无数次。总是有这样那样的问题导致配置文件过期或者失效。<code>sigh</code> 是用来创建、更新、下载、修复 <code>Provisioning Profile</code> 的工具。</li><li><a href="https://github.com/fastlane/fastlane/tree/master/pem" target="_blank" rel="noopener">pem</a> =&gt; 自动生成、更新推送配置文件</li><li><a href="https://github.com/fastlane/fastlane/tree/master/match" target="_blank" rel="noopener">match</a> =&gt; 一个新的证书和配置文件管理工具。我会另写一篇文章专门介绍这个工具。他会所有需要用到的证书传到 git 私有库上，任何需要配置的机器直接用 <code>match</code> 同步回来就不用管证书问题了，小团队福音啊！</li></ul><h3 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h3><ul><li><a href="https://github.com/fastlane/fastlane/tree/master/snapshot" target="_blank" rel="noopener">snapshot</a> =&gt; 用 <code>Xcode7</code> 推出的 <code>UI test</code> 功能实现自动化截图</li><li><a href="https://github.com/fastlane/fastlane/tree/master/frameit" target="_blank" rel="noopener">frameit</a> =&gt; 可以把截的图片自动套上一层外边框</li></ul><h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><ul><li><a href="https://github.com/fastlane/fastlane/tree/master/produce" target="_blank" rel="noopener">produce</a> =&gt; 如果你的产品还没在 iTunes Connect(iTC) 或者 Apple Developer Center(ADC) 建立，produce 可以自动帮你完成这些工作</li><li><a href="https://github.com/fastlane/fastlane/tree/master/deliver" target="_blank" rel="noopener">deliver</a> =&gt; 自动上传截图，APP 的元数据，二进制 (ipa) 文件到 iTunes Connect</li></ul><h3 id="TestFlight-管理"><a href="#TestFlight-管理" class="headerlink" title="TestFlight 管理"></a>TestFlight 管理</h3><ul><li><a href="https://github.com/fastlane/fastlane/tree/master/pilot" target="_blank" rel="noopener">pilot</a> =&gt; 管理 <code>TestFlight</code> 的测试用户，上传二进制文件</li><li><a href="https://github.com/fastlane/boarding" target="_blank" rel="noopener">boarding</a> =&gt; 建立一个添加测试用户界面，发给测试者，可自行添加邮件地址，并同步到 <code>iTC</code></li></ul><h3 id="辅助工具"><a href="#辅助工具" class="headerlink" title="辅助工具"></a>辅助工具</h3><ul><li><a href="https://github.com/fastlane/fastlane/tree/master/spaceship" target="_blank" rel="noopener">spaceship</a> =&gt; 为 <code>pilot</code>，<code>boarding</code>和 <code>deliver</code>等工具提供和 iTC 和 ADC 的交互 API。<code>spaceship</code>本来是个独立的项目，后来被 <code>Fastlane</code> 收编进来</li><li><a href="https://github.com/fastlane/fastlane/tree/master/watchbuild" target="_blank" rel="noopener">WatchBuild</a> =&gt; 是一个独立的 iTC 监控工具，开启 <code>WatchBuild</code> 可以监控 iTC 上的文件状态，弹出 MacOS 自带的 Notification</li></ul><h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><ul><li><a href="https://github.com/fastlane/fastlane/tree/master/supply#readme" target="_blank" rel="noopener">supply</a> =&gt; 自动上传到 Google Play 工具</li><li><a href="https://github.com/fastlane/fastlane/tree/master/screengrab#readme" target="_blank" rel="noopener">screengrab</a> =&gt; Android 的自动截图工具</li></ul><h2 id="简例"><a href="#简例" class="headerlink" title="简例"></a>简例</h2><p>fastlane 命令是一个流程控制的命令行工具(CLI)，通过内部集成 <code>action</code> 和第三方的 <code>action</code> 完成一系列控制流程。运行 fastlane 命令行工具，会读取当前目录或者 <code>./fastlane</code> 目录下的 <code>Fastfile</code> 配置文件。</p><p>在 <code>Fastfile</code> 中：</p><ul><li><code>action</code> =&gt; Fastlane 中的每一条命令都是一个扩展(action)，上面提到的 <code>deliver</code>，<code>sigh</code>之类的工具本身是 CLI，但是在 Fastlane 中内嵌了对他们支持的 <code>action</code></li><li><code>lane</code> =&gt; Fastlane 中流程的合集，每一个动作即可以是 <code>action</code>，也可以是其他的 <code>lane</code>。语法和 ruby 中的 rake 非常像</li></ul><p>一个简单的发布流程：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">lane <span class="symbol">:deploy</span> <span class="keyword">do</span></span><br><span class="line">  <span class="comment"># 执行 pod instasll</span></span><br><span class="line">  cocoapods</span><br><span class="line">  <span class="comment"># 执行 carthage bootstrap</span></span><br><span class="line">  carthage</span><br><span class="line">  <span class="comment"># 增加build版本号</span></span><br><span class="line">  increment_build_number</span><br><span class="line">  <span class="comment"># 编译代码</span></span><br><span class="line">  gym</span><br><span class="line">  <span class="comment"># 发布到Apple Store</span></span><br><span class="line">  deliver(<span class="symbol">force:</span> <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>如果 ruby 版本满足要求，可以直接在命令行执行以下命令安装 fastlane</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装fastlane</span></span><br><span class="line">sudo gem install -n /usr/<span class="built_in">local</span>/bin fastlane</span><br></pre></td></tr></table></figure><p>使用的环境搭建好了，就可以进行下一步来配置 fastlane </p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>执行默认的初始化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd 项目目录</span><br><span class="line">fastlane init</span><br></pre></td></tr></table></figure><p>如果你的项目只有一个 bundle id 也只有一个开发者账号的话，可以直接遵循官方的步骤配置。否则需要按照官方文档，配置不同参数和环境变量。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Last login: Tue Aug  7 13:19:59 on ttys000</span><br><span class="line">yuhanle:360qws-G100 yuhanle$ fastlane init</span><br><span class="line">[✔] 🚀 </span><br><span class="line">[✔] Looking for iOS and Android projects in current directory...</span><br><span class="line">[13:33:35]: Created new folder './fastlane'.</span><br><span class="line">[13:33:35]: Detected an iOS/macOS project in the current directory: 'G100.xcworkspace'</span><br><span class="line">[13:33:35]: -----------------------------</span><br><span class="line">[13:33:35]: --- Welcome to fastlane 🚀 ---</span><br><span class="line">[13:33:35]: -----------------------------</span><br><span class="line">[13:33:35]: fastlane can help you with all kinds of automation for your mobile app</span><br><span class="line">[13:33:35]: We recommend automating one task first, and then gradually automating more over time</span><br><span class="line">[13:33:35]: What would you like to use fastlane for?</span><br><span class="line">1. 📸  Automate screenshots</span><br><span class="line">2. 👩‍✈️  Automate beta distribution to TestFlight</span><br><span class="line">3. 🚀  Automate App Store distribution</span><br><span class="line">4. 🛠  Manual setup - manually setup your project to automate your tasks</span><br><span class="line">?</span><br></pre></td></tr></table></figure><p>在提问了你的 <code>Apple ID</code>，<code>Team</code> 的问题之后，fastlane 会自动检测当前目录下项目的 <code>App Name</code> 和 <code>App Identifier</code>。如果检测的不对，选择 <code>n</code> 自行输入。</p><p>接下来会问你这个 app 是否需要在 iTC 和 ADC 中创建(上一步中如果选择 <code>y</code> 会自动检测是否需要创建)，fastlane 会调用 <code>produce</code> 进行初始化，如果现在还不想创建，也可以之后再运行 <code>produce init</code> 进行这个流程。如果不执行 <code>produce</code> 的流程，<code>deliver</code> 的流程也会被掠过，当然之后也可以 <code>deliver init</code> 运行完全一样的流程。</p><p>在执行 <code>deliver init</code> 的过程中，会同步 iTC 中的所有语言的元数据和截图，并按照目录结构组织好。目录结构应该类似下面：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">fastlane</span><br><span class="line">├── Appfile</span><br><span class="line">├── Deliverfile</span><br><span class="line">├── Fastfile</span><br><span class="line">├── metadata</span><br><span class="line">│   ├── copyright.txt</span><br><span class="line">│   ├── en-US</span><br><span class="line">│   │   ├── description.txt</span><br><span class="line">│   │   ├── keywords.txt</span><br><span class="line">│   │   ├── marketing_url.txt</span><br><span class="line">│   │   ├── name.txt</span><br><span class="line">│   │   ├── privacy_url.txt</span><br><span class="line">│   │   ├── release_notes.txt</span><br><span class="line">│   │   └── support_url.txt</span><br><span class="line">│   ├── primary_category.txt</span><br><span class="line">│   ├── primary_first_sub_category.txt</span><br><span class="line">│   ├── primary_second_sub_category.txt</span><br><span class="line">│   ├── secondary_category.txt</span><br><span class="line">│   ├── secondary_first_sub_category.txt</span><br><span class="line">│   ├── secondary_second_sub_category.txt</span><br><span class="line">│   └── zh-Hans</span><br><span class="line">│       ├── description.txt</span><br><span class="line">│       ├── keywords.txt</span><br><span class="line">│       ├── marketing_url.txt</span><br><span class="line">│       ├── name.txt</span><br><span class="line">│       ├── privacy_url.txt</span><br><span class="line">│       ├── release_notes.txt</span><br><span class="line">│       └── support_url.txt</span><br><span class="line">└── screenshots</span><br><span class="line">    ├── README.txt</span><br><span class="line">    ├── en-US</span><br><span class="line">    │   ├── 一堆png图片</span><br></pre></td></tr></table></figure><p>这里肯定会被创建的是 <code>Appfile</code> 和 <code>Fastfile</code>。如果 <code>Deliverfile</code>，<code>screenshots</code> 和 <code>metadata</code> 目录没被创建，可以运行 <code>deliver init</code> 来创建。</p><ul><li>Fastfile =&gt; 用来定义所有的 lane 任务 <a href="https://github.com/fastlane/fastlane/tree/master/fastlane/docs#fastfile" target="_blank" rel="noopener">Fastfile帮助</a></li><li>Appfile =&gt; 是用来存储一些公共信息的，比如 <code>app_identifier</code>，<code>apple_id</code>，<code>team_id</code>，<code>itc_team_id</code>等。<a href="https://github.com/fastlane/fastlane/blob/master/fastlane/docs/Appfile.md" target="_blank" rel="noopener">Appfile帮助</a></li><li>Deliverfile =&gt; <code>deliver</code> 的配置文件 <a href="https://github.com/fastlane/fastlane/blob/master/deliver/Deliverfile.md" target="_blank" rel="noopener">Deliverfile帮助</a></li></ul><p><strong>PS</strong>:</p><ol><li>这里有个小问题，iTC 和 ADC 中的 <code>Team ID</code> 是不一样的，在 <code>fastlane init</code> 中只会自动在 Appfile 里写入 ADC 的 <code>team_id</code>，所以在这个过程中会不停的问你 iTC 的 <code>Team ID</code>，所以在创建完 Appfile 后，手动在里面添加 <code>itc_team_id</code>。</li><li>这个问答对不同的项目可能有各种各样的分支。我已经用不同的项目试过很多次了，但是可能还不是全部，所以你还需要见招拆招。</li><li>在这里可以安心的输入密码，所有的密码都加密保存在系统的 Keychain 里。</li></ol><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p><img src="http://cdn.yuhanle.com/fastlane/QQ20180807-133643@2x.png" alt></p><p>fastlane 可以通过配置  .env 文件、Appfile、Deliverfile、Fastfile 来完成各种工作。</p><p>其中 Fastfile 是最核心的用来控制流程走向的配置文件，.env 和 Appfile 可以辅助 Fastfile 来设置一些参数，Deliverfile 可用于配置提交 iTunesConnect 的一些参数。</p><p>需要查看，样例配置可直接前往<a href="http://devhy.com/2018/01/23/26-fastlane-usage/#%E4%B8%8B%E8%BD%BD%E6%A0%B7%E4%BE%8B%E9%85%8D%E7%BD%AE" target="_blank" rel="noopener">下载样例配置</a></p><h4 id="Appfile"><a href="#Appfile" class="headerlink" title="Appfile"></a>Appfile</h4><p>Appfile是用来配置一些类似于 AppleID、BundleID 参数(参数是 fastlane 已经定义好的，新增的并没有用，如果想新增变量需要使用 .env 方式)，可以在 Fastfile 中使用，AppleID、BundleID 等其实会被一些 actions 直接调用，并不需要写出来传递。</p><h5 id="普通配置方式"><a href="#普通配置方式" class="headerlink" title="普通配置方式"></a>普通配置方式</h5><p>直接在 Appfile 里填写 app_identifier、apple_id、team_id 等，然后根据 lane 的不同可以设置成不同。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认配置</span></span><br><span class="line">app_identifier <span class="string">"com.xxxxxxxxxx.test"</span></span><br><span class="line">apple_id <span class="string">"xxxxxxxxxx@xxxx.com"</span></span><br><span class="line">team_id <span class="string">"xxxxxxxxxx"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果lane是ent换成Dev的配置</span></span><br><span class="line">for_lane <span class="symbol">:ent</span> <span class="keyword">do</span></span><br><span class="line">  app_identifier <span class="string">"com.xxxxxxxxxx.testDev"</span></span><br><span class="line">  apple_id <span class="string">"xxxxxxxxxx@xxxx.com"</span></span><br><span class="line">  TEAM_ID <span class="string">"xxxxxxxxxx"</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h5 id="使用-env-配置方式"><a href="#使用-env-配置方式" class="headerlink" title="使用 .env 配置方式"></a>使用 .env 配置方式</h5><p><a href="https://docs.fastlane.tools/advanced/#environment-variables" target="_blank" rel="noopener">.env</a> 这个文件的作用是作为环境变量的配置文件，在 fastlane init 进行初始化后并不会自动生成，如果需要可以自己创建。</p><p>执行时默认会读取 <code>.env</code> 和 <code>.env.default</code> 文件里的配置。通过执行 <code>fastlane [lane-name] --env [envName]</code> 来指定使用配置文件 <code>.env.[envName]</code>，读取顺序是 <code>.env -&gt; .env.default -&gt; .env.&lt;envName&gt;</code>，相同的变量名会被后面的覆盖。</p><p>如我建了文件 .env.myDev，里面写了一些参数，那在执行的时候使用 <code>fastlane [lane-name] --env myDev</code> 即可，想在 Appfile、Deliverfile、Fastfile 等调用，直接使用 <code>ENV[&#39;keyName&#39;]</code> 即可</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .env.myDev文件</span></span><br><span class="line"><span class="comment"># bundle id</span></span><br><span class="line">App_Identifier = <span class="string">"com.xxxxxxxxxx.testDev"</span></span><br><span class="line"><span class="comment"># 开发者账号</span></span><br><span class="line">Apple_Id = <span class="string">"xxxxxxxxxx@xxxx.com"</span></span><br><span class="line"><span class="comment"># 开发者TeamId</span></span><br><span class="line">Team_Id  = <span class="string">"xxxxxxxxxx"</span></span><br><span class="line"><span class="comment"># project的target scheme名称</span></span><br><span class="line">Scheme   = <span class="string">"xxxxxxxxxx"</span></span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Appfile使用.env方式直接读取变量即可</span></span><br><span class="line">app_identifier ENV[<span class="string">'App_Identifier'</span>]</span><br><span class="line">apple_id  ENV[<span class="string">'Apple_Id'</span>]</span><br><span class="line">team_id ENV[<span class="string">'Team_Id'</span>]</span><br></pre></td></tr></table></figure><p><strong>注意：因为是 .env 文件是.开头文件，默认是在 finder 中隐藏的，需要通过执行一下命令来显示</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置隐藏文件可见</span></span><br><span class="line">defaults write com.apple.finder AppleShowAllFiles TRUE</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启finder服务以生效</span></span><br><span class="line">killall Finder</span><br></pre></td></tr></table></figure><h5 id="配置方式对比"><a href="#配置方式对比" class="headerlink" title="配置方式对比"></a>配置方式对比</h5><ul><li>普通配置方式：简单易懂，但不能自定义变量，且每个 lane 想不一样都要写一个 for_lane</li><li>.env 配置方式：功能性强，但配置起来稍微麻烦一点</li></ul><h4 id="Fastfile"><a href="#Fastfile" class="headerlink" title="Fastfile"></a>Fastfile</h4><p>Fastfile 是对流程进行控制的核心文件，需要设定支持的平台和在一些环节里需要做的事情，是我们脚本的入口，所有的事件驱动都是在这个文件来调度的。</p><h5 id="Lane"><a href="#Lane" class="headerlink" title="Lane"></a><a href="https://github.com/fastlane/fastlane/tree/master/lane" target="_blank" rel="noopener">Lane</a></h5><p>有了 <code>Fastfile</code>，就可以添加自己的发布流程了。打开Fastfile文件(这里我用Sublime 设定语法为Ruby)，如果不出意外的话你生成的Fastfile和我应该差不多。这里我就不贴出来了。</p><p>最开始定义了</p><ul><li><code>fastlane_version</code> =&gt; 指定fastlane最小版本</li><li><code>default_platform</code> =&gt; 指定当前平台，可选 <code>ios,android,mac</code></li></ul><p>在 <code>platform</code> 中就是需要修改的重点。先忽略 <code>before_all</code>，<code>after_all</code>，<code>error</code> 这些方法，这里的 <code>lane</code> 就是一组任务，上传到 Firim 的任务如下</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">lane <span class="symbol">:to_firim</span> <span class="keyword">do</span></span><br><span class="line">  <span class="comment"># 如果你用 pod install 注意参数 -&gt; 否则会出错</span></span><br><span class="line">  cocoapods(<span class="symbol">use_bundle_exec:</span> <span class="literal">false</span>)</span><br><span class="line">  <span class="comment"># 如果你没有申请adhoc证书，sigh会自动帮你申请，并且添加到Xcode里</span></span><br><span class="line">  sigh(<span class="symbol">adhoc:</span> <span class="literal">true</span>)</span><br><span class="line">  <span class="comment"># 以下两个action来自fastlane-plugin-versioning，</span></span><br><span class="line">  <span class="comment"># 第一个递增 Build，第二个设定Version。</span></span><br><span class="line">  <span class="comment"># 如果你有多个target，就必须指定target的值，否则它会直接找找到的第一个plist修改</span></span><br><span class="line">  <span class="comment"># 在这里我建议每一个打的包的Build都要不一样，这样crash了拿到日志，可以对应到ipa上</span></span><br><span class="line">  increment_build_number_in_plist(<span class="symbol">target:</span> [target_name])</span><br><span class="line">  increment_version_number_in_plist(</span><br><span class="line">    <span class="symbol">target:</span> [target_name],</span><br><span class="line">    <span class="symbol">version_number:</span> <span class="string">'7.1.3'</span></span><br><span class="line">    )</span><br><span class="line">  <span class="comment"># gym用来编译ipa</span></span><br><span class="line">  gym(</span><br><span class="line">    <span class="symbol">output_directory:</span> <span class="string">'./firim'</span>,</span><br><span class="line">    <span class="symbol">export_options:</span> &#123;</span><br><span class="line">      <span class="symbol">method:</span> <span class="string">"ad-hoc"</span>, <span class="comment"># 这可以不指定</span></span><br><span class="line">      <span class="symbol">thinning:</span> <span class="string">"&lt;none&gt;"</span></span><br><span class="line">    &#125;</span><br><span class="line">    )</span><br><span class="line">  <span class="comment"># 上传ipa到fir.im服务器，在fir.im获取firim_api_token</span></span><br><span class="line">  firim(<span class="symbol">firim_api_token:</span> [firim_api_token])</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h5 id="Sigh"><a href="#Sigh" class="headerlink" title="Sigh"></a><a href="https://github.com/fastlane/fastlane/tree/master/sigh" target="_blank" rel="noopener">Sigh</a></h5><p>如果你不确定证书目前是否可用，可以用 Sigh 自动生成获取证书。Sigh 会自动根据 Appfile 里设置的 <code>app_identifier</code>从 ADC (苹果开发者中心)生成证书，并下载到项目根目录下(不是 fastlane 目录)，下载后自动安装。你可以通过指定 <code>output_path</code> 指定证书下载位置。</p><p>PS：建议不要把这个文件夹同步到项目的 git 中( Fastlane 提供了 <code>match</code> 专门管理所有证书)。可以在 .gitignore 中可以忽略这个文件夹。</p><p>Sigh 常用的配置项：</p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td>adhoc</td><td>bool</td><td>获取adhoc证书</td><td>fasle</td></tr><tr><td>development</td><td>bool</td><td>更新开发证书，不更新<code>production</code>证书</td><td>false</td></tr><tr><td>force</td><td>bool</td><td>强制更新证书，不管证书是否在ADC中存在</td><td>false</td></tr></tbody></table><p>iOS 里 code 打包证书有 4 种，adhoc，inhouse，appstore，development 证书。</p><table><thead><tr><th></th><th>价格</th><th>AppStore 证书</th><th>In-House 证书</th><th>AdHoc 证书</th><th>Development 证书</th></tr></thead><tbody><tr><td>企业帐户</td><td>$299</td><td></td><td>√</td><td>√</td><td>√</td></tr><tr><td>公司账号</td><td>$99</td><td>√</td><td></td><td>√</td><td>√</td></tr><tr><td>个人账户</td><td>$99</td><td>√</td><td></td><td>√</td><td>√</td></tr></tbody></table><p>其中 <code>In-House</code> 的方式打包的ipa安装没有设备的限制。<code>AdHoc</code> 打包的 ipa 必须提前把设备的 UDID 添加到证书中，并且有 100 台设备限制。</p><p>所以如果你不指定 <code>adhoc</code> 为 <code>true</code>，Sigh 会识别帐户类型，企业帐户默认生成 <code>In-House</code> 证书，公司账号和个人帐户默认生成 AppStore 证书。</p><h5 id="Gym"><a href="#Gym" class="headerlink" title="Gym"></a><a href="https://github.com/fastlane/fastlane/tree/master/gym" target="_blank" rel="noopener">Gym</a></h5><p>Gym 常用配置项：</p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td>scheme</td><td>string</td><td>指定需要编译的scheme</td><td></td></tr><tr><td>clean</td><td>bool</td><td>是否在编译前clean</td><td>false</td></tr><tr><td>output_directory</td><td>string</td><td>导出目录</td><td><code>./</code></td></tr><tr><td>output_name</td><td>string</td><td>导出ipa名字</td><td>[app_name].ipa</td></tr><tr><td>export_options</td><td>hash/string</td><td>这里指定Xcode API的外部配置文件地址，或者配置hash，见下文</td><td></td></tr><tr><td>export_method</td><td>string</td><td>打包方式，可选项<code>app-store</code> <code>ad-hoc`</code>package<code></code>enterprise<code>development</code>developer-id`</td><td>如果在fastlane中使用了sigh，这个值会从上下文获取</td></tr><tr><td>include_bitcode</td><td>bool</td><td>是否开启<code>bitcode</code></td><td>Xcode API 默认值为true</td></tr><tr><td>include_symbols</td><td>bool</td><td>是否生成符号表</td><td>Xcode API 默认值为true</td></tr></tbody></table><p>Xcode7 之后，Xcode API 允许我们指定一个 <code>plist</code> 文件作为额外的配置文件。gym 默认会帮你创建这个文件，你可以直接指定配置。更多关于 plist 可配置项，执行 <code>xcodebuild -help</code> 查看 <code>Available keys for -exportOptionsPlist</code>。</p><p><code>export_method</code>， <code>include_symbols</code>，和 <code>include_bitcode</code>  这些参数都是 <code>exportOptionsPlist</code> 的配置，对应 <code>method</code>，<code>uploadSymbols</code> 和 <code>uploadBitcode</code>。</p><p>Gym 可以指定配置文件 <a href="https://github.com/fastlane/fastlane/tree/master/gym#gymfile" target="_blank" rel="noopener"><code>Gymfile</code></a>。 </p><p>初始化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gym init</span><br></pre></td></tr></table></figure><h4 id="Multi-Target"><a href="#Multi-Target" class="headerlink" title="Multi-Target"></a>Multi-Target</h4><p>如果我们需要配置多个 target 进行打包的话，我们可以使用 <a href="https://link.juejin.im?target=https%3A%2F%2Fdocs.fastlane.tools%2Fadvanced%2F%23environment-variables" target="_blank" rel="noopener">环境变量</a>，来进行配置。假如我们现在有两个 <code>target</code>，<code>targetA</code> 和 <code>targetB</code>，则我们需要创建两个 <code>.env</code> 文件，例如 <code>.env.targetA</code>，<code>.env.targetB</code>，放在 <code>Fastfile</code> 文件同级目录下</p><p>在 <code>.env</code> 文件里面我们可以配置一些不同的内容（非公共），比如 <code>app_identifier</code>，<code>release_notes</code> 等等。截图如下：</p><p><img src="http://cdn.yuhanle.com/fastlane/QQ20180807-142523@2x.png" alt></p><p>在 <code>Appfile</code>，<code>Deliverfile</code>，<code>Fastfile</code> 等文件，我们都可以直接使用 <code>.env</code> 文件里面的内容。</p><p>Appfile</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Appfile</span><br><span class="line"></span><br><span class="line">#The bundle identifier of your app</span><br><span class="line">app_identifier ENV[&apos;APP_IDENTIFIER&apos;]</span><br><span class="line"></span><br><span class="line"># Your Apple email address</span><br><span class="line">apple_id ENV[&apos;APPLE_ID&apos;] </span><br><span class="line"></span><br><span class="line"># Developer Portal Team ID</span><br><span class="line">team_id ENV[&apos;TEAM_ID&apos;]</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>Deliverfile，<strong>请在设置 release_nores、support_url、private_url 等配置的时候，采用 hash 的方式写。</strong></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># app_identifier</span></span><br><span class="line">app_identifier ENV[<span class="string">'APP_IDENTIFIER'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用户名,Apple ID电子邮件地址</span></span><br><span class="line">username ENV[<span class="string">'APPLE_ID'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 团队ID</span></span><br><span class="line">team_id ENV[<span class="string">'TEAM_ID'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 团队name</span></span><br><span class="line">team_name ENV[<span class="string">'TEAM_NAME'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># copyright</span></span><br><span class="line">copyright ENV[<span class="string">'COPYRIGHT'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关键字</span></span><br><span class="line">keywords(</span><br><span class="line"><span class="string">'zh-Hans'</span> =&gt; ENV[<span class="string">'KEYWORDS'</span>],</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新版本修改记录</span></span><br><span class="line">release_notes(</span><br><span class="line"><span class="comment"># 中国</span></span><br><span class="line"><span class="string">'zh-Hans'</span> =&gt; ENV[<span class="string">'RELEASE_NOTES'</span>],</span><br><span class="line"><span class="comment"># 澳大利亚</span></span><br><span class="line"><span class="string">'en-au'</span> =&gt; ENV[<span class="string">'RELEASE_NOTES_AU'</span>],</span><br><span class="line"><span class="comment"># 美国</span></span><br><span class="line"><span class="string">'en-us'</span> =&gt; ENV[<span class="string">'RELEASE_NOTES_US'</span>]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 支持网址</span></span><br><span class="line">support_url(</span><br><span class="line"><span class="comment"># 中国</span></span><br><span class="line"><span class="string">'zh-Hans'</span> =&gt; ENV[<span class="string">'SUPPORT_URL'</span>],</span><br><span class="line"><span class="comment"># 澳大利亚</span></span><br><span class="line"><span class="string">'en-au'</span> =&gt; ENV[<span class="string">'SUPPORT_URL_AU'</span>],</span><br><span class="line"><span class="comment"># 美国</span></span><br><span class="line"><span class="string">'en-us'</span> =&gt; ENV[<span class="string">'SUPPORT_URL_US'</span>]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 隐私政策网址 国家代码 https://www.cnblogs.com/Mien/archive/2008/08/22/1273950.html</span></span><br><span class="line">privacy_url(</span><br><span class="line"><span class="comment"># 中国</span></span><br><span class="line"><span class="string">'zh-Hans'</span> =&gt; ENV[<span class="string">'PRIVACY_URL'</span>],</span><br><span class="line"><span class="comment"># 澳大利亚</span></span><br><span class="line"><span class="string">'en-au'</span> =&gt; ENV[<span class="string">'PRIVACY_URL_AU'</span>],</span><br><span class="line"><span class="comment"># 美国</span></span><br><span class="line"><span class="string">'en-us'</span> =&gt; ENV[<span class="string">'PRIVACY_URL_US'</span>]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传完成后提交新版本进行审查</span></span><br><span class="line">submit_for_review <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 跳过HTML报告文件验证</span></span><br><span class="line">force <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用iTC的分阶段发布功能 灰度发布</span></span><br><span class="line">phased_release <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用审核小组的联系信息 app 审核信息</span></span><br><span class="line">app_review_information(</span><br><span class="line">  <span class="symbol">first_name:</span> <span class="string">"xx"</span>,</span><br><span class="line">  <span class="symbol">last_name:</span> <span class="string">"xx"</span>,</span><br><span class="line">  <span class="symbol">phone_number:</span> <span class="string">"+86 18888888888"</span>,</span><br><span class="line">  <span class="symbol">email_address:</span> <span class="string">"xxxx"</span>,</span><br><span class="line">  <span class="symbol">demo_user:</span> <span class="string">"test1@test.com"</span>,</span><br><span class="line">  <span class="symbol">demo_password:</span> <span class="string">"test123"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="Deliver"><a href="#Deliver" class="headerlink" title="Deliver"></a><a href="https://github.com/fastlane/fastlane/tree/master/deliver" target="_blank" rel="noopener">Deliver</a></h4><p>Deliver 可以完全管理与 iTC 的交互。其中包括：</p><ul><li>上传和下载多语言截图</li><li>上传和下载多语言元数据</li><li>上传二进制文件</li></ul><p>还记得上面<a href="https://whlsxl.github.io/fastlane1/#init" target="_blank" rel="noopener">初始化</a>的时候初始化的 <code>metadata</code>，<code>screenshots</code> 目录么？iTC 中的所有的元数据信息都被保存在 <code>metadata</code> 中，所有的截图信息都被保存在 <code>screenshots</code> 中。</p><p>metadata：</p><ul><li>可以很容易的管理对应目录下的文件和 iTC 后台的表单项，在执行 <code>deliver</code> 时会自动被传到 iTC。</li><li>在 <code>metadata</code> 目录下的文件，如 <code>copyright.txt</code>，是没有本地化的，在二层目录中的文件都是需要对应不同语言的表单项。</li><li>如果你不想修改某些项的信息，直接把对应的文件删除即可。</li><li>所有这些表单项也可以在 <code>Deliverfile</code> 中指定，<code>Deliverfile</code> 中指定的项优先级比文件高</li></ul><p>screenshots：</p><ul><li>如果不想更改截图，可以把整个截图目录删除</li><li>如果不使用 <code>snapshot</code> (自动化截图)，也可以自己截图放到对应目录下，比一张一张上传 iTC 快的多。截图在iTC 中的排列顺序就是本地文件名的「字母表顺序」(在目录中右击，按文件名排序)。<code>deliver</code>会识别图片分辨率，上传到对应设备中。</li></ul><p>如果要通过 <code>deliver</code> 修改元数据或截图，你必须提供所有 iTC 中有的语言。比如后台中有「简体中文」和「英文」，你也必须提供对应的 <code>zh-Hans</code> 和 <code>en-US</code> 文件，否则 <code>deliver</code> 会报缺少语言的错误。可以在 iTC 后台提交的版本中删除语言。</p><p>Deliver 常用配置项：</p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td>ipa</td><td>string</td><td><code>ipa</code>地址</td><td>如果使用<code>gym</code>，可以通过上下文获取</td></tr><tr><td>metadata_path</td><td>string</td><td>指定<code>metadata</code>目录地址</td><td>如果在<code>fastlane</code>中<code>./fastlane/metadata</code>，如果作为独立的命令行应用<code>./metadata</code></td></tr><tr><td>screenshots_path</td><td>string</td><td>指定<code>screenshots</code>目录地址</td><td>如果在<code>fastlane</code>中<code>./fastlane/screenshots</code>，如果作为独立的命令行应用<code>./screenshots</code></td></tr><tr><td>skip_binary_upload</td><td>bool</td><td>跳过二进制文件上传，适用于只想改<code>metadata</code></td><td>false</td></tr><tr><td>skip_screenshots</td><td>bool</td><td>跳过截图上传，如果截图没有变化，开启这项节约时间</td><td>false</td></tr><tr><td>skip_metadata</td><td>bool</td><td>跳过元数据上传</td><td>false</td></tr><tr><td>force</td><td>bool</td><td><code>deliver</code>会在上传时汇总信息生成HTML也，等待你审核。跳过这项审核此项设为<code>true</code></td><td>false</td></tr><tr><td>submit_for_review</td><td>bool</td><td>上传完成是否自动提交审核</td><td>false</td></tr><tr><td>automatic_release</td><td>bool</td><td>审核通过是否自动释放</td><td>false</td></tr><tr><td>price_tier</td><td>int</td><td>App价格级别。<strong>注意：这项提交当时就会生效</strong>，所以更改价格还是在后天手动操作</td><td></td></tr><tr><td>submission_information</td><td>hash</td><td>这是在iTC上点击提交之后的问答表格，<a href="https://github.com/fastlane/fastlane/blob/master/spaceship/lib/spaceship/tunes/app_submission.rb#L18-L69" target="_blank" rel="noopener">可选项</a></td><td></td></tr><tr><td>app_review_information</td><td>hash</td><td>提供审核时的信息，<a href="https://github.com/fastlane/fastlane/blob/master/deliver/Deliverfile.md#app_review_information" target="_blank" rel="noopener">详情</a></td><td></td></tr><tr><td>app_icon</td><td>string</td><td>指定<code>icon</code>图片地址，必须为<code>png</code>格式</td></tr></tbody></table><ul><li><p>submission_information =&gt;</p><ul><li><p>前缀 <code>export_compliance</code> =&gt; 对应「出口合规信息」，没有特殊情况都选 <code>false</code> 就可以。</p></li><li><p>前缀 <code>content_rights</code> =&gt; 问你是否包含，显示，访问第三方内容(这项我没在我提交过程中找到)，没有特殊情况也都选 <code>false</code> 就可以。</p></li><li><p>前缀 <code>add_id_info</code> =&gt; 可就关键了，对应「广告标识符」，如果你在 App 中使用了 <code>IDFA</code>。你必须在这给个理由，而不能直接选 <code>false</code>。</p><p>下图等价下表，App 中投放了广告。</p></li></ul></li></ul><p><img src="http://cdn.yuhanle.com/fastlane/submission_information.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">submission_information(&#123;</span><br><span class="line">  export_compliance_available_on_french_store: &quot;false&quot;,</span><br><span class="line">  export_compliance_contains_proprietary_cryptography: &quot;false&quot;,</span><br><span class="line">  export_compliance_contains_third_party_cryptography: &quot;false&quot;,</span><br><span class="line">  export_compliance_is_exempt: &quot;false&quot;,</span><br><span class="line">  export_compliance_uses_encryption: &quot;false&quot;,</span><br><span class="line">  export_compliance_app_type: nil,</span><br><span class="line">  export_compliance_encryption_updated: &quot;false&quot;,</span><br><span class="line">  export_compliance_compliance_required: &quot;false&quot;,</span><br><span class="line">  export_compliance_platform: &quot;ios&quot;,</span><br><span class="line">  content_rights_contains_third_party_content: &quot;false&quot;,</span><br><span class="line">  content_rights_has_rights: &quot;false&quot;,</span><br><span class="line">  add_id_info_limits_tracking: &quot;true&quot;,</span><br><span class="line">  add_id_info_serves_ads: &quot;true&quot;,</span><br><span class="line">  add_id_info_tracks_action: &quot;false&quot;,</span><br><span class="line">  add_id_info_tracks_install: &quot;false&quot;,</span><br><span class="line">  add_id_info_uses_idfa: &quot;true&quot;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>deliver</code> 的 <code>CLI</code> 工具：</p><ul><li>下载 iTC 上的截图 <code>deliver download_screenshots</code></li><li><p>下载 iTC 上的元数据  <code>deliver download_metadata</code></p><p>配置完以上的设置，最后只需要一条命令发布</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastlane ios deploy</span><br></pre></td></tr></table></figure><h2 id="系统级-lane"><a href="#系统级-lane" class="headerlink" title="系统级 lane"></a>系统级 lane</h2><p><code>fastlane</code> 默认有 lane。</p><ul><li><code>before_all</code>，就是在执行一次脚本之前首先执行的代码，我们可以在这里面执行一些公共的东西，比如<code>git_pull</code>，<code>cocoapods</code>。</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">before_all <span class="keyword">do</span></span><br><span class="line">  <span class="comment"># 检出到 Developer 分支</span></span><br><span class="line">  sh <span class="string">'git checkout Developer'</span></span><br><span class="line">  git_pull</span><br><span class="line">  cocoapods(<span class="symbol">repo_update:</span> <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li><p><code>after_all</code>， 成功结束之后，处理共有的后置逻辑。</p></li><li><p><code>before_each</code>，每次执行 lane 之前都会执行一次。</p></li><li><p><code>after_each</code>，每次执行 lane 之后都会执行一次。</p></li><li><p><code>error</code>，在执行上述情况任意环境报错都会中止并执行一次。</p></li></ul><h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><table><thead><tr><th>执行顺序</th><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>before_all</td><td>在执行 lane 之前只执行一次。</td></tr><tr><td>2</td><td>before_each</td><td>每次执行 lane 之前都会执行一次。</td></tr><tr><td>3</td><td>lane</td><td>自定义的任务。</td></tr><tr><td>4</td><td>after_each</td><td>每次执行 lane 之后都会执行一次。</td></tr><tr><td>5</td><td>after_all</td><td>在执行 lane 成功结束之后执行一次。</td></tr><tr><td>6</td><td>error</td><td>在执行上述情况任意环境报错都会中止并执行一次。</td></tr></tbody></table><h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><ul><li>出现 <code>Command timed out after 10 seconds on try 1 of 4, trying again...</code>，在 <code>fastlane</code> 文件开头加上：</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV[<span class="string">"FASTLANE_XCODEBUILD_SETTINGS_TIMEOUT"</span>] = <span class="string">"180"</span></span><br><span class="line">ENV[<span class="string">"FASTLANE_XCODE_LIST_TIMEOUT"</span>] = <span class="string">"180"</span></span><br></pre></td></tr></table></figure><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>Fastlane 的插件是一个或者一组 <code>action</code> 的打包，单独发布在 fastlane 之外。<a href="https://github.com/fastlane/fastlane/blob/master/fastlane/docs/Plugins.md" target="_blank" rel="noopener">Fastlane Plugin 指南</a></p><p>自从 16 年 5 月份推出插件系统以来，现在已经有很多第三方的插件可以使用。查看所有插件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastlane search_plugins</span><br></pre></td></tr></table></figure><p>这里介绍两个下文会用到的插件：</p><ol><li><p>fastlane-plugin-versioning =&gt; 用来修改 build 版本号和 version 版本号。</p><p>Fastlane 内嵌的 action <code>increment_build_number</code>使用的是苹果提供的 <code>agvtool</code>，<code>agvtool</code> 在更改 Build 的时候会改变所有target的版本号。这时如果你在一个工程里有多个产品的话，每次编译，所有的Build都要加1，最后就不知道高到哪里去了。</p><p>有了 <code>fastlane-plugin-versioning</code> 不仅可以指定 target 增加 Build，而且可以按照「<a href="http://semver.org/lang/zh-CN/" target="_blank" rel="noopener">语义化版本</a>」规范增加 Version，当然也可以直接设定 Version。</p><p>PS：最开始写 iOS 时不知道怎么定义 Build。现在我一般都直接定义成纯数字，比如 100 起,每次编译的时候让他自动加一。</p></li><li><p><a href="https://github.com/whlsxl/firim/tree/master/fastlane-plugin-firim" target="_blank" rel="noopener">fastlane-plugin-firim</a> =&gt; 直接把 AdHoc 或者 InHouse 打包的 ipa 上传到 fir.im，供测试下载。</p></li></ol><p>安装上面的插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fastlane add_plugin [name] # 安装方法</span><br><span class="line">fastlane add_plugin versioning</span><br><span class="line">fastlane add_plugin firim</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://juejin.im/post/5a7b10bb6fb9a0636263bfd5" target="_blank" rel="noopener">iOS 持续交付之 Fastlane</a></p><p><a href="http://devhy.com/2018/01/23/26-fastlane-usage/" target="_blank" rel="noopener">和重复劳动说再见-使用fastlane进行iOS打包</a></p><p><a href="https://whlsxl.github.io/fastlane1/" target="_blank" rel="noopener">小团队的自动化发布－Fastlane带来的全自动化发布</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://docs.fastlane.tools/img/fastlane_text.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://fastlane.tools/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;fastlane&lt;/a&gt; 是一个通过简单命令来完成诸如截图、获取证书、编译、导出安装包、提交 iTunesConnect 等一系列操作的工具，它同时支持 iOS 和 Android。 &lt;/p&gt;
    
    </summary>
    
      <category term="fastlane" scheme="https://blog.yuhanle.com/categories/fastlane/"/>
    
    
      <category term="fastlane" scheme="https://blog.yuhanle.com/tags/fastlane/"/>
    
  </entry>
  
  <entry>
    <title>数据序列化框架在 Swift 日常开发中的应用</title>
    <link href="https://blog.yuhanle.com/2018/07/05/json-analysis-in-swift/"/>
    <id>https://blog.yuhanle.com/2018/07/05/json-analysis-in-swift/</id>
    <published>2018-07-05T01:00:00.000Z</published>
    <updated>2021-10-21T08:18:48.337Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/10498756/42311471-7fec973a-8070-11e8-80cb-cf2719b0ab7a.png" alt="image"></p><a id="more"></a><p>到了 Swift 年代，第三方库 SwiftyJSON 和 ObjectMapper 都曾经作为 JSON 转换的中流砥柱，只是这两者还是免不了“手动指定字段和JSON字典映射关系”的工作。于是阿里想了个黑科技（<a href="https://github.com/alibaba/HandyJSON" target="_blank" rel="noopener">HandyJSON</a>），通过分析Swift数据结构在内存中的布局，自动分析出映射关系，进一步降低开发者使用的成本。</p><p>如今我们就有多个选择：ObjectMapper、HandyJSON、SwiftyJSON、MJExtension 等</p><p>其实我们在日常开发中，对于 JSON 数据的处理有两大需求：</p><ol><li>json 和 model 互相转换（Android Studio有 Gson format 插件，但Xcode没有类似功能）</li><li>服务端返回的 json 里可能有 null，但是 Swift 语言的空是用 nil 表示，需要空值处理(对象 Optional 类型)</li></ol><h2 id="框架简介"><a href="#框架简介" class="headerlink" title="框架简介"></a>框架简介</h2><h3 id="ObjectMapper"><a href="#ObjectMapper" class="headerlink" title="ObjectMapper"></a>ObjectMapper</h3><p>先看 <a href="https://github.com/Hearst-DD/ObjectMapper" target="_blank" rel="noopener">ObjectMapper</a> ： Model 类必须实现 Mappable 协议，即实现 init 和 mapping 函数；适合跟 Alamofire 配合。但是 mapping 函数实现起来过于臃肿耗时，只能借助<a href="https://github.com/quicktype/quicktype-xcode" target="_blank" rel="noopener">插件</a>来快速完成。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ObjectMapper</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonOBM</span>: <span class="title">Mappable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> username: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span>?</span><br><span class="line">    <span class="keyword">var</span> weight: <span class="type">Double</span>!</span><br><span class="line">    <span class="keyword">var</span> sex: <span class="type">Bool</span>!</span><br><span class="line">    <span class="keyword">var</span> location: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> three_day_forecast: [<span class="type">ForecastOBM</span>]?</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(<span class="built_in">map</span>: <span class="type">Map</span>) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">mapping</span><span class="params">(<span class="built_in">map</span>: Map)</span></span> &#123;</span><br><span class="line">        username    &lt;- <span class="built_in">map</span>[<span class="string">"username"</span>]</span><br><span class="line">        age         &lt;- <span class="built_in">map</span>[<span class="string">"age"</span>]</span><br><span class="line">        weight      &lt;- <span class="built_in">map</span>[<span class="string">"weight"</span>]</span><br><span class="line">        sex         &lt;- <span class="built_in">map</span>[<span class="string">"sex"</span>]</span><br><span class="line">        location    &lt;- <span class="built_in">map</span>[<span class="string">"location"</span>]</span><br><span class="line">        three_day_forecast &lt;- <span class="built_in">map</span> [<span class="string">"three_day_forecast"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ForecastOBM</span>: <span class="title">Mappable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> conditions: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> day: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> temperature: <span class="type">Double</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(<span class="built_in">map</span>: <span class="type">Map</span>) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">mapping</span><span class="params">(<span class="built_in">map</span>: Map)</span></span> &#123;</span><br><span class="line">        conditions      &lt;- <span class="built_in">map</span>[<span class="string">"conditions"</span>]</span><br><span class="line">        day             &lt;- <span class="built_in">map</span>[<span class="string">"day"</span>]</span><br><span class="line">        temperature     &lt;- <span class="built_in">map</span>[<span class="string">"temperature"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://dotnet.ctolib.com/j2s.html" target="_blank" rel="noopener">j2s 是一个 macOS app 能够将 JSON 对象转成 Swift 结构体</a></p><h3 id="HandyJSON"><a href="#HandyJSON" class="headerlink" title="HandyJSON"></a>HandyJSON</h3><p>再看 <a href="https://github.com/alibaba/handyjson" target="_blank" rel="noopener">HandyJSON</a>， 写起来比较方便，类和结构体要求继承于 HandyJSON、枚举要继承于 HandyJSONEnum。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> HandyJSON</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonHJ</span>: <span class="title">HandyJSON</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> username: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span>?</span><br><span class="line">    <span class="keyword">var</span> weight: <span class="type">Double</span>!</span><br><span class="line">    <span class="keyword">var</span> sex: <span class="type">Bool</span>!</span><br><span class="line">    <span class="keyword">var</span> locatoin: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> three_day_forecast: [<span class="type">ForecastHJ</span>]?</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ForecastHJ</span>: <span class="title">HandyJSON</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> conditions: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> day: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> temperature: <span class="type">Double</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比ObjectMapper使用上要简单， 不用写mapping函数那么多代码了。</p><h3 id="SwiftyJSON"><a href="#SwiftyJSON" class="headerlink" title="SwiftyJSON"></a>SwiftyJSON</h3><p>看 <a href="https://github.com/SwiftyJSON/SwiftyJSON" target="_blank" rel="noopener">SwiftyJSON</a>：取字段值使用比较方便， 但是然并卵？ SwiftyJSON 不支持转 Model，如果你只是想要解析某几个字段，那么 SwiftyJSON 是不二选择， 而且适用于 Alamofire。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> jsonString: <span class="type">String</span> = <span class="string">"&#123;\"username\":\"yuhanle\",\"age\":18,\"weight\":65.4,\"sex\":1,\"location\":\"Toronto, Canada\",\"three_day_forecast\":[&#123;\"conditions\":\"Partly cloudy\",\"day\":\"Monday\",\"temperature\":20&#125;,&#123;\"conditions\":\"Showers\",\"day\":\"Tuesday\",\"temperature\":22&#125;,&#123;\"conditions\":\"Sunny\",\"day\":\"Wednesday\",\"temperature\":28&#125;]&#125;"</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">let</span> dataFromString = jsonString.data(using: .utf8, allowLossyConversion: <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> json = <span class="keyword">try</span> <span class="type">JSON</span>(data: dataFromString!)</span><br><span class="line">    <span class="built_in">print</span>(json[<span class="string">"username"</span>], json[<span class="string">"weight"</span>], json[<span class="string">"three_day_forecast"</span>][<span class="number">0</span>][<span class="string">"conditions"</span>])</span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="keyword">let</span> error <span class="keyword">as</span> <span class="type">NSError</span> &#123;</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">"Error: <span class="subst">\(error.domain)</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MJExtension"><a href="#MJExtension" class="headerlink" title="MJExtension"></a>MJExtension</h3><p>最后看下一下 <a href="https://github.com/CoderMJLee/MJExtension" target="_blank" rel="noopener">MJExtension</a>，作为一个从 ObjC 年代就开始流程的转换框架，在如今使用的人仍然很多，但是对于 Swift 的集成却不是特别友好，官方 issue 列表中经常都会有申请支持 swift 的呼声！</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> MJExtension</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonMJ</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@objc</span> <span class="keyword">var</span> username: <span class="type">String</span>?</span><br><span class="line">    <span class="meta">@objc</span> <span class="keyword">var</span> age = <span class="number">0</span></span><br><span class="line">    <span class="meta">@objc</span> <span class="keyword">var</span> weight = <span class="number">0.0</span></span><br><span class="line">    <span class="meta">@objc</span> <span class="keyword">var</span> sex = <span class="literal">false</span></span><br><span class="line">    <span class="meta">@objc</span> <span class="keyword">var</span> location: <span class="type">String</span>?</span><br><span class="line">    <span class="meta">@objc</span> <span class="keyword">var</span> three_day_forecast: [<span class="type">ForecastMJ</span>]?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ForecastMJ</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@objc</span> <span class="keyword">var</span> conditions: <span class="type">String</span>?</span><br><span class="line">    <span class="meta">@objc</span> <span class="keyword">var</span> day: <span class="type">String</span>?</span><br><span class="line">    <span class="meta">@objc</span> <span class="keyword">var</span> temperature = <span class="number">0.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管在支持上不是特别友好，但是在自定义 Model 的过程中，应该是最轻松的一款，但是在升级 Swift 4 之后，需要在属性前添加 @objc 才可以正常使用，否则转换失败。具体情况可参考：<a href="https://github.com/CoderMJLee/MJExtension/issues/582" target="_blank" rel="noopener">Swift 4 字典转模型失败</a></p><p>另外还有一种情况，就是关于整型属性，需要给定初试值，也就是说，MJExtension 无法序列化/反序列化整型。解决办法很简单， 就是赋个默认值， 即将Optional整型变为整型就可以。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span>?   <span class="comment">// 请注意：MJExtension不能解析Optional Int类型</span></span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">0</span> <span class="comment">// 正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行耗时"><a href="#运行耗时" class="headerlink" title="运行耗时"></a>运行耗时</h2><p>我们准备了一小段 JSON 数据，循环解析 10000 次，来分析几大框架的运行耗时：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"username"</span>: <span class="string">"yuhanle"</span>,</span><br><span class="line">    <span class="attr">"age"</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">"weight"</span>: <span class="number">65.4</span>,</span><br><span class="line">    <span class="attr">"sex"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"location"</span>: <span class="string">"Toronto, Canada"</span>,</span><br><span class="line">    <span class="attr">"three_day_forecast"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"conditions"</span>: <span class="string">"Partly cloudy"</span>,</span><br><span class="line">            <span class="attr">"day"</span>: <span class="string">"Monday"</span>,</span><br><span class="line">            <span class="attr">"temperature"</span>: <span class="number">20</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"conditions"</span>: <span class="string">"Showers"</span>,</span><br><span class="line">            <span class="attr">"day"</span>: <span class="string">"Tuesday"</span>,</span><br><span class="line">            <span class="attr">"temperature"</span>: <span class="number">22</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"conditions"</span>: <span class="string">"Sunny"</span>,</span><br><span class="line">            <span class="attr">"day"</span>: <span class="string">"Wednesday"</span>,</span><br><span class="line">            <span class="attr">"temperature"</span>: <span class="number">28</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以 HandyJSON 为例，在开始处理数据和结束时，记录时间差，时间差的结果每次会有波动</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> maxCount = <span class="number">10000</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testHandyJSON</span><span class="params">(json: String)</span></span> -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> start = <span class="type">CFAbsoluteTimeGetCurrent</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> people: <span class="type">PersonHJ</span> = <span class="type">PersonHJ</span>()</span><br><span class="line">    <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;maxCount &#123;</span><br><span class="line">        people = <span class="type">PersonHJ</span>.deserialize(from: json)!</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> executionTime = <span class="type">CFAbsoluteTimeGetCurrent</span>() - start</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"HandyJSON deserialize time totals: "</span>, executionTime)</span><br><span class="line"></span><br><span class="line">    start = <span class="type">CFAbsoluteTimeGetCurrent</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> res = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;maxCount &#123;</span><br><span class="line">        res = people.toJSONString()!</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    executionTime = <span class="type">CFAbsoluteTimeGetCurrent</span>() - start</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"HandyJSON toJSONString time totals: "</span>, executionTime)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终记录得到的结果对比图</p><table><thead><tr><th><strong>测试项</strong></th><th><strong>JSON -&gt; MODEL</strong></th><th><strong>MODEL -&gt; JSON</strong></th></tr></thead><tbody><tr><td>HandyJSON</td><td>3.0839329957962</td><td>4.97446703910828</td></tr><tr><td>ObjeceMapper</td><td>1.40153098106384</td><td>1.2123589515686</td></tr><tr><td>SwiftJSON</td><td>不支持</td><td>不支持</td></tr><tr><td>MJExtension</td><td>0.417935013771057</td><td>0.418874025344849</td></tr></tbody></table><p><img src="https://user-images.githubusercontent.com/10498756/42310902-2010687e-806f-11e8-9365-c3d1a3958677.png" alt="image"></p><p>结果有点出乎意料，HandyJSON 的黑魔法纵然很强大，这也导致了耗时的问题，相比较而言，不太友好的  MJExtension 速度最快。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于应用开发来说，JSON 数据序列化和反序列号的操作必不可少，上述分析的效率和性能问题，也应该多考虑，选择合适的框架很重要，学习和踩坑也是并存的。</p><p>另外，Swift 支持 Codable 协议，对这个需求的处理也有很大的支持！</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://medium.com/@jasonyuh/%E5%BA%94%E8%AF%A5%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8codable-f99d6ac5810" target="_blank" rel="noopener">应该什么时候使用Codable</a></li><li><a href="http://www.cnblogs.com/yajunLi/p/7121950.html" target="_blank" rel="noopener">Swift实现JSON转Model - HandyJSON使用讲解</a></li><li><a href="https://blog.csdn.net/brycegao321/article/details/75349045" target="_blank" rel="noopener">iOS JSON序列化/反序列化哪家强？</a></li><li><a href="https://medium.com/@wenchenx/swift-4-codable-%E8%AE%93%E5%BA%8F%E5%88%97%E5%8C%96%E8%AE%8A%E5%BE%97%E6%9B%B4%E7%B0%A1%E5%96%AE-73e55042f077" target="_blank" rel="noopener">Swift 4 Codable 讓序列化變得更簡單</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/10498756/42311471-7fec973a-8070-11e8-80cb-cf2719b0ab7a.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="swift" scheme="https://blog.yuhanle.com/categories/swift/"/>
    
    
      <category term="swift" scheme="https://blog.yuhanle.com/tags/swift/"/>
    
      <category term="JSON" scheme="https://blog.yuhanle.com/tags/JSON/"/>
    
      <category term="HandyJSON" scheme="https://blog.yuhanle.com/tags/HandyJSON/"/>
    
  </entry>
  
  <entry>
    <title>RAC 在 MVVM 中的常见用法</title>
    <link href="https://blog.yuhanle.com/2018/05/13/rac-in-mvvm/"/>
    <id>https://blog.yuhanle.com/2018/05/13/rac-in-mvvm/</id>
    <published>2018-05-13T01:00:00.000Z</published>
    <updated>2021-10-21T08:18:48.339Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><p>在 iOS 开发中，或多或少都会见过 RAC 的身影，它为提高开发效率而生，在某些特定情况下开发时可以大大简化代码，并且目前来看安全可靠。如果你还没有接触 RAC，建议你工作之余稍作研究，并尝试体验一下。<br><a id="more"></a></p><p>关于 RAC 的解释，官方的说，<a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="noopener">ReactiveCocoa</a>（其简称为RAC）是由 GitHub 开源的一个应用于 iOS 和 OS X 开发的新框架，其具有 <a href="https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B8%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80" target="_blank" rel="noopener">函数式编程</a> 和 <a href="https://zh.wikipedia.org/wiki/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B" target="_blank" rel="noopener">响应式编程</a> 的特性。</p><p>这是摘自花瓣网工程师博客的一幅图，可以直观的看到各个类之间的关系</p><p><img src="http://cdn.yuhanle.com/rac/FRP_ReactiveCocoa_large.png" alt></p><p>接下来，我们就结合 RAC 中的类以及实际使用场景，来描述一下他的基本用法：</p><ul><li>RACSignal</li><li>RACSubject</li><li>RACSequence</li><li>RACMulticastConnection</li><li>RACCommand</li><li>RAC 常用宏</li><li>RAC-bind</li><li>RAC-过滤</li><li>RAC-映射</li><li>RAC-组合</li></ul><h2 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h2><h3 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h3><h4 id="RACSignal"><a href="#RACSignal" class="headerlink" title="RACSignal"></a>RACSignal</h4><p><strong>信号类</strong>，Signal 是 RAC 中的核心概念。当数据改变时，信号内部就会收到数据，然后发出。<strong>但是默认一个信号是冷信号</strong>，当一个信号没有订阅者（Subscriber）时它什么也不干，就像我们的函数，当一个函数写好之后并没有被调用它也什么都不会干。信号可以通过以下三种方式发送事件给订阅者。</p><p>详细介绍参考：<a href="https://draveness.me/racdelegateproxy" target="_blank" rel="noopener">从代理到 RACSignal</a></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.创建信号</span></span><br><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    <span class="comment">// 3.发送信号</span></span><br><span class="line">    [subscriber sendNext:<span class="string">@"ws"</span>];</span><br><span class="line">    <span class="comment">// 4.取消信号</span></span><br><span class="line">    <span class="comment">// 如果信号想要被取消，就必须返回一个RACDisposable</span></span><br><span class="line">    <span class="comment">// 信号什么时候被取消：</span></span><br><span class="line">    <span class="comment">// 1.自动取消，当一个信号的订阅者被销毁的时候机会自动取消订阅，</span></span><br><span class="line">    <span class="comment">// 2.手动取消，</span></span><br><span class="line">    <span class="comment">// block什么时候调用：一旦一个信号被取消订阅就会调用</span></span><br><span class="line">    <span class="comment">// block作用：当信号被取消时用于清空一些资源</span></span><br><span class="line">    <span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"取消订阅"</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 订阅信号</span></span><br><span class="line"><span class="comment">// subscribeNext</span></span><br><span class="line"><span class="comment">// 把nextBlock保存到订阅者里面</span></span><br><span class="line"><span class="comment">// 只要订阅信号就会返回一个取消订阅信号的类</span></span><br><span class="line">RACDisposable *disposable = [signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="comment">// block的调用时刻：只要信号内部发出数据就会调用这个block</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消订阅</span></span><br><span class="line">[disposable dispose];</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><p>信号类的作用：</p><ol><li>只要有数据改变就会把数据包装成信号传递出去</li><li>只要有数据改变就会有信号发出</li><li>数据发出，并不是信号类发出，信号类不能发送数据</li></ol><p>实现思路：</p><ol><li><p>当一个信号被订阅，创建订阅者，并把 nextBlock 保存到订阅者里面</p></li><li><p>创建的时候会返回 [RACDynamicSignal createSignal:didSubscribe];</p></li><li><p>调用 RACDynamicSignal 的 didSubscribe</p></li><li><p>发送信号 [subscriber sendNext:value];</p></li><li><p>拿到订阅者的 nextBlock 调用</p></li></ol><h4 id="RACSubject"><a href="#RACSubject" class="headerlink" title="RACSubject"></a>RACSubject</h4><p>RACSubject 在使用中我们可以完全代替代理/通知，来简化代码。</p><p><strong>(可变的信号）：</strong> 可以连接RAC代码与非RAC代码，可以接收和主动发送信号。看了很多介绍都不推荐使用。目前我只把他当作代理使用了一下。</p><p>详细介绍参考：<a href="https://draveness.me/racsubject" target="_blank" rel="noopener">『可变』的热信号 RACSubject</a></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建信号</span></span><br><span class="line">RACSubject *subject = [RACSubject subject];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 订阅信号</span></span><br><span class="line">[subject subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="comment">// block:当有数据发出的时候就会调用</span></span><br><span class="line">    <span class="comment">// block:处理数据</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 发送信号</span></span><br><span class="line">[subject sendNext:value];</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><ol><li>RACSubject 和 RACReplaySubject 的区别</li><li>RACSubject 必须要先订阅信号之后才能发送信号， 而 RACReplaySubject 可以先发送信号后订阅.</li><li>RACSubject 代码中体现为：先走TwoViewController的 sendNext，后走 ViewController 的 subscribeNext 订阅</li><li>RACReplaySubject 代码中体现为：先走 ViewController 的 subscribeNext 订阅，后走 TwoViewController 的sendNext 可按实际情况各取所需。</li></ol><h4 id="RACSequence"><a href="#RACSequence" class="headerlink" title="RACSequence"></a>RACSequence</h4><p>详细介绍参考：<a href="https://draveness.me/racsequence" target="_blank" rel="noopener">Pull-Driven 的数据流 RACSequence</a></p><p>使用场景： 可以快速高效的遍历数组和字典。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *path = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"flags.plist"</span> ofType:<span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSArray</span> *dictArr = [<span class="built_in">NSArray</span> arrayWithContentsOfFile:path];</span><br><span class="line">    [dictArr.rac_sequence.signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">&#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"error"</span>);</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"完毕"</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>也可以使用宏</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSDictionary</span> *dict = @&#123;<span class="string">@"key"</span>:@<span class="number">1</span>, <span class="string">@"key2"</span>:@<span class="number">2</span>&#125;;</span><br><span class="line">[dict.rac_sequence.signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">    <span class="built_in">NSString</span> *key = x[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *value = x[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// RACTupleUnpack宏：专门用来解析元组</span></span><br><span class="line">    <span class="comment">// RACTupleUnpack 等会右边：需要解析的元组 宏的参数，填解析的什么样数据</span></span><br><span class="line">    <span class="comment">// 元组里面有几个值，宏的参数就必须填几个</span></span><br><span class="line">    RACTupleUnpack(<span class="built_in">NSString</span> *key, <span class="built_in">NSString</span> *value) = x;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@ %@"</span>, key, value);</span><br><span class="line">&#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"error"</span>);</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"完毕"</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h4 id="RACMulticastConnection"><a href="#RACMulticastConnection" class="headerlink" title="RACMulticastConnection"></a>RACMulticastConnection</h4><p>当有多个订阅者，但是我们只想发送一个信号的时候怎么办？这时我们就可以用 RACMulticastConnection，来实现。</p><p>详细介绍参考：<a href="https://draveness.me/racconnection" target="_blank" rel="noopener">用于多播的 RACMulticastConnection</a></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通写法, 这样的缺点是：每订阅一次信号就得重新创建并发送请求，很不友好</span></span><br><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    <span class="comment">// didSubscribeblock 中的代码都统称为副作用</span></span><br><span class="line">    <span class="comment">// 发送请求</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"发送请求啦"</span>);</span><br><span class="line">    <span class="comment">// 发送信号</span></span><br><span class="line">    [subscriber sendNext:<span class="string">@"ws"</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">[signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line">[signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line">[signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐做法。 使用RACMulticastConnection，无论有多少个订阅者，无论订阅多少次，只发送一个</span></span><br><span class="line"><span class="comment">// 1.发送请求，用一个信号内包装，不管有多少个订阅者，只想发一次请求</span></span><br><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    <span class="comment">// 发送请求</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"发送请求啦"</span>);</span><br><span class="line">    <span class="comment">// 发送信号</span></span><br><span class="line">    [subscriber sendNext:<span class="string">@"ws"</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">//2. 创建连接类</span></span><br><span class="line">RACMulticastConnection *connection = [signal publish];</span><br><span class="line">[connection.signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line">[connection.signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line">[connection.signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">//3. 连接。只有连接了才会把信号源变为热信号</span></span><br><span class="line">[connection connect];</span><br></pre></td></tr></table></figure><h4 id="RACCommand"><a href="#RACCommand" class="headerlink" title="RACCommand"></a>RACCommand</h4><p>RACCommand：RAC 中用于处理事件的类，可以把事件如何处理，事件中的数据如何传递，包装到这个类中，他可以很方便的监控事件的执行过程，比如看事件有没有执行完毕，详细介绍参考：<a href="https://draveness.me/raccommand" target="_blank" rel="noopener">优雅的 RACCommand</a></p><p><code>RACCommand</code> 是一个在 ReactiveCocoa 中比较复杂的类，大多数使用 ReactiveCocoa 的人，尤其是初学者并不会经常使用它。</p><p>在很多情况下，虽然使用 <code>RACSignal</code> 和 <code>RACSubject</code> 就能解决绝大部分问题，但是 <code>RACCommand</code> 的使用会为我们带来巨大的便利，尤其是在与副作用相关的操作中。</p><p>使用场景：监听按钮点击，异步网络请求</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通做法</span></span><br><span class="line"><span class="comment">// RACCommand: 处理事件</span></span><br><span class="line"><span class="comment">// 不能返回空的信号</span></span><br><span class="line"><span class="comment">// 1.创建命令</span></span><br><span class="line">RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(<span class="keyword">id</span> input) &#123;</span><br><span class="line">    <span class="comment">//block调用，执行命令的时候就会调用</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, input); <span class="comment">// input 为执行命令传进来的参数</span></span><br><span class="line">    <span class="comment">// 这里的返回值不允许为nil</span></span><br><span class="line">    <span class="keyword">return</span> [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:<span class="string">@"执行命令产生的数据"</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如何拿到执行命令中产生的数据呢？</span></span><br><span class="line"><span class="comment">// 订阅命令内部的信号</span></span><br><span class="line"><span class="comment">// ** 方式一：直接订阅执行命令返回的信号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.执行命令</span></span><br><span class="line">RACSignal *signal =[command execute:@<span class="number">2</span>]; </span><br><span class="line">    <span class="comment">// 这里其实用到的是replaySubject 可以先发送命令再订阅</span></span><br><span class="line">    <span class="comment">// 在这里就可以订阅信号了</span></span><br><span class="line">    [signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般做法</span></span><br><span class="line"><span class="comment">// 1.创建命令</span></span><br><span class="line">RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(<span class="keyword">id</span> input) &#123;</span><br><span class="line">    <span class="comment">//block调用，执行命令的时候就会调用</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, input); <span class="comment">// input 为执行命令传进来的参数</span></span><br><span class="line">    <span class="comment">// 这里的返回值不允许为nil</span></span><br><span class="line">    <span class="keyword">return</span> [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:<span class="string">@"执行命令产生的数据"</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：</span></span><br><span class="line"><span class="comment">// 订阅信号</span></span><br><span class="line"><span class="comment">// 注意：这里必须是先订阅才能发送命令</span></span><br><span class="line"><span class="comment">// executionSignals：信号源，信号中信号，signalofsignals:信号，发送数据就是信号</span></span><br><span class="line">[command.executionSignals subscribeNext:^(RACSignal *x) &#123;</span><br><span class="line">    [x subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.执行命令</span></span><br><span class="line">[command execute:@<span class="number">2</span>];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 高级做法</span></span><br><span class="line"><span class="comment">// 1.创建命令</span></span><br><span class="line">RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(<span class="keyword">id</span> input) &#123;</span><br><span class="line">    <span class="comment">// block调用：执行命令的时候就会调用</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, input);</span><br><span class="line">    <span class="comment">// 这里的返回值不允许为nil</span></span><br><span class="line">    <span class="keyword">return</span> [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:<span class="string">@"发送信号"</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式三</span></span><br><span class="line"><span class="comment">// switchToLatest获取最新发送的信号，只能用于信号中信号。</span></span><br><span class="line">[command.executionSignals.switchToLatest subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">// 2.执行命令</span></span><br><span class="line">[command execute:@<span class="number">3</span>];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// switchToLatest--用于信号中信号</span></span><br><span class="line"><span class="comment">// 创建信号中信号</span></span><br><span class="line">RACSubject *signalofsignals = [RACSubject subject];</span><br><span class="line">RACSubject *signalA = [RACSubject subject];</span><br><span class="line"><span class="comment">// 订阅信号</span></span><br><span class="line">[signalofsignals subscribeNext:^(RACSignal *x) &#123;</span><br><span class="line">   [x subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">   &#125;];</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">// switchToLatest: 获取信号中信号发送的最新信号</span></span><br><span class="line">[signalofsignals.switchToLatest subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">// 发送信号</span></span><br><span class="line">[signalofsignals sendNext:signalA];</span><br><span class="line">[signalA sendNext:@<span class="number">4</span>];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听事件有没有完成</span></span><br><span class="line"><span class="comment">// 注意：当前命令内部发送数据完成，一定要主动发送完成</span></span><br><span class="line"><span class="comment">// 1.创建命令</span></span><br><span class="line">RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(<span class="keyword">id</span> input) &#123;</span><br><span class="line">    <span class="comment">// block调用：执行命令的时候就会调用</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, input);</span><br><span class="line">    <span class="comment">// 这里的返回值不允许为nil</span></span><br><span class="line">    <span class="keyword">return</span> [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        [subscriber sendNext:<span class="string">@"执行命令产生的数据"</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// *** 发送完成 **</span></span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">// 监听事件有没有完成</span></span><br><span class="line">[command.executing subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="keyword">if</span> ([x boolValue] == <span class="literal">YES</span>) &#123; </span><br><span class="line">        <span class="comment">// 正在执行</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"当前正在执行%@"</span>, x);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 执行完成/没有执行</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"执行完成/没有执行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.执行命令</span></span><br><span class="line">[command execute:@<span class="number">1</span>];</span><br></pre></td></tr></table></figure><h3 id="进阶用法"><a href="#进阶用法" class="headerlink" title="进阶用法"></a>进阶用法</h3><h4 id="RAC-常用宏"><a href="#RAC-常用宏" class="headerlink" title="RAC 常用宏"></a>RAC 常用宏</h4><p>RAC 有许多强大而方便的宏。如下代码所示</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RAC: 把一个对象的某个属性绑定一个信号，只要发出信号，就会把信号的内容给对象的属性赋值</span></span><br><span class="line"><span class="comment">// 给 label 的 text 属性绑定了文本框改变的信号</span></span><br><span class="line">RAC(<span class="keyword">self</span>.label, text) = <span class="keyword">self</span>.textField.rac_textSignal;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与上述同样功能</span></span><br><span class="line">[<span class="keyword">self</span>.textField.rac_textSignal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line"><span class="keyword">self</span>.label.text = x;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* KVO</span></span><br><span class="line"><span class="comment">* RACObserveL: 快速的监听某个对象的某个属性改变</span></span><br><span class="line"><span class="comment">* 返回的是一个信号，对象的某个属性改变的信号</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">[RACObserve(<span class="keyword">self</span>.view, center) subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例 textField 输入的值赋值给label，监听 label 文字改变</span></span><br><span class="line">RAC(<span class="keyword">self</span>.label, text) = <span class="keyword">self</span>.textField.rac_textSignal;</span><br><span class="line">[RACObserve(<span class="keyword">self</span>.label, text) subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"label的文字变化"</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 循环引用问题</span></span><br><span class="line"><span class="comment">* 使用 @weakify(self) 和 @strongify(self) 来避免循环引用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">@weakify(<span class="keyword">self</span>);</span><br><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    @strongify(<span class="keyword">self</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="keyword">self</span>.view);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">_signal = signal;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 元祖</span></span><br><span class="line"><span class="comment">* 快速包装一个元组</span></span><br><span class="line"><span class="comment">* 把包装的类型放在宏的参数里面，就会自动包装</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">RACTuple *tuple = RACTuplePack(@<span class="number">1</span>, @<span class="number">2</span>, @<span class="number">4</span>);</span><br><span class="line"><span class="comment">// 宏的参数类型要和元祖中元素类型一致，右边为要解析的元祖</span></span><br><span class="line">RACTupleUnpack_(<span class="built_in">NSNumber</span> *num1, <span class="built_in">NSNumber</span> *num2, <span class="built_in">NSNumber</span> * num3) = tuple;</span><br><span class="line"><span class="comment">// 4.元祖</span></span><br><span class="line"><span class="comment">// 快速包装一个元组</span></span><br><span class="line"><span class="comment">// 把包装的类型放在宏的参数里面，就会自动包装</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@ %@ %@"</span>, num1, num2, num3);</span><br></pre></td></tr></table></figure><h4 id="RAC-bind"><a href="#RAC-bind" class="headerlink" title="RAC-bind"></a>RAC-bind</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.创建信号</span></span><br><span class="line">RACSubject *subject = [RACSubject subject];</span><br><span class="line"><span class="comment">// 2.绑定信号</span></span><br><span class="line">RACSignal *bindSignal = [subject bind:^RACStreamBindBlock&#123;</span><br><span class="line">    <span class="comment">// block调用时刻：只要绑定信号订阅就会调用。</span></span><br><span class="line">    <span class="keyword">return</span> ^RACSignal *(<span class="keyword">id</span> value, <span class="built_in">BOOL</span> *stop)&#123;</span><br><span class="line">        <span class="comment">// 一般在这个block中做事 ，发数据的时候会来到这个block。</span></span><br><span class="line">        <span class="comment">// 只要源信号（subject）发送数据，就会调用block</span></span><br><span class="line">        <span class="comment">// block作用：处理源信号内容</span></span><br><span class="line">        <span class="comment">// value:源信号发送的内容，</span></span><br><span class="line">        value = @<span class="number">3</span>; <span class="comment">// 如果在这里把 value 的值改了，那么订阅绑定信号的值的 x 就变了</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"接受到源信号的内容：%@"</span>, value);</span><br><span class="line">        <span class="comment">// 返回信号，不能为nil,如果非要返回空---则empty或 alloc init。</span></span><br><span class="line">        <span class="keyword">return</span> [RACReturnSignal <span class="keyword">return</span>:value]; <span class="comment">// 把返回的值包装成信号</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.订阅绑定信号</span></span><br><span class="line">[bindSignal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"接收到绑定信号处理完的信号:%@"</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">// 4.发送信号</span></span><br><span class="line">[subject sendNext:<span class="string">@"123"</span>];</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><ol><li>bind（绑定）的使用思想和 Hook 的一样 —&gt; 都是拦截 API 从而可以对数据进行操作，而影响返回数据</li></ol><h4 id="RAC-过滤"><a href="#RAC-过滤" class="headerlink" title="RAC-过滤"></a>RAC-过滤</h4><p>有时候我们想要过滤一些信号，这时候我们便可以用 RAC 的过滤方法。过滤方法有好多种，如下代码，从不同情况下进行了分析。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 跳跃 ： 如下，skip传入 2 跳过前面两个值</span></span><br><span class="line"><span class="comment">// 实际用处： 在实际开发中比如 后台返回的数据前面几个没用，我们想跳跃过去，便可以用skip</span></span><br><span class="line">RACSubject *subject = [RACSubject subject];</span><br><span class="line">[[subject skip:<span class="number">2</span>] subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line">[subject sendNext:@<span class="number">1</span>];</span><br><span class="line">[subject sendNext:@<span class="number">2</span>];</span><br><span class="line">[subject sendNext:@<span class="number">3</span>];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// distinctUntilChanged: -- 如果当前的值跟上一次的值一样，就不会被订阅到</span></span><br><span class="line">RACSubject *subject = [RACSubject subject];</span><br><span class="line">[[subject distinctUntilChanged] subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">// 发送信号</span></span><br><span class="line">[subject sendNext:@<span class="number">1</span>];</span><br><span class="line">[subject sendNext:@<span class="number">2</span>];</span><br><span class="line">[subject sendNext:@<span class="number">2</span>]; <span class="comment">// 不会订阅到</span></span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// take: 可以屏蔽一些值，去掉前面几个值---这里 take 为2 则只拿到前两个值</span></span><br><span class="line">RACSubject *subject = [RACSubject subject];</span><br><span class="line">[[subject take:<span class="number">2</span>] subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">// 发送信号</span></span><br><span class="line">[subject sendNext:@<span class="number">1</span>];</span><br><span class="line">[subject sendNext:@<span class="number">2</span>];</span><br><span class="line">[subject sendNext:@<span class="number">3</span>]; <span class="comment">// 不会订阅到</span></span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//takeLast:和take的用法一样，不过他取的是最后的几个值，如下，则取的是最后两个值</span></span><br><span class="line"><span class="comment">//注意点:takeLast 一定要调用sendCompleted，告诉他发送完成了，这样才能取到最后的几个值</span></span><br><span class="line">RACSubject *subject = [RACSubject subject];</span><br><span class="line">[[subject takeLast:<span class="number">2</span>] subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">// 发送信号</span></span><br><span class="line">[subject sendNext:@<span class="number">1</span>]; <span class="comment">// 不会订阅到</span></span><br><span class="line">[subject sendNext:@<span class="number">2</span>];</span><br><span class="line">[subject sendNext:@<span class="number">3</span>];</span><br><span class="line">[subject sendCompleted];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// takeUntil: 给 takeUntil 传的是哪个信号，那么当这个信号发送信号或 sendCompleted，就不能再接受源信号的内容</span></span><br><span class="line">RACSubject *subject = [RACSubject subject];</span><br><span class="line">RACSubject *subject2 = [RACSubject subject];</span><br><span class="line">[[subject takeUntil:subject2] subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">// 发送信号</span></span><br><span class="line">[subject sendNext:@<span class="number">1</span>];</span><br><span class="line">[subject sendNext:@<span class="number">2</span>];</span><br><span class="line">[subject2 sendNext:@<span class="number">3</span>];  <span class="comment">// 1</span></span><br><span class="line">[subject2 sendCompleted]; <span class="comment">// 或2</span></span><br><span class="line">[subject sendNext:@<span class="number">4</span>];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ignore: 忽略掉一些值</span></span><br><span class="line"><span class="comment">// ignore:忽略一些值</span></span><br><span class="line"><span class="comment">// ignoreValues:表示忽略所有的值</span></span><br><span class="line"><span class="comment">// 1.创建信号</span></span><br><span class="line">RACSubject *subject = [RACSubject subject];</span><br><span class="line"><span class="comment">// 2.忽略一些值</span></span><br><span class="line">RACSignal *ignoreSignal = [subject ignore:@<span class="number">2</span>]; <span class="comment">// ignoreValues:表示忽略所有的值</span></span><br><span class="line"><span class="comment">// 3.订阅信号</span></span><br><span class="line">[ignoreSignal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">// 4.发送数据</span></span><br><span class="line">[subject sendNext:@<span class="number">2</span>];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般和文本框一起用，添加过滤条件</span></span><br><span class="line"><span class="comment">// 只有当文本框的内容长度大于 5，才获取文本框里的内容</span></span><br><span class="line">[[<span class="keyword">self</span>.textField.rac_textSignal filter:^<span class="built_in">BOOL</span>(<span class="keyword">id</span> value) &#123;</span><br><span class="line">    <span class="comment">// value 源信号的内容</span></span><br><span class="line">    <span class="keyword">return</span> [value length] &gt; <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// 返回值 就是过滤条件。只有满足这个条件才能获取到内容</span></span><br><span class="line">&#125;] subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h4 id="RAC-映射"><a href="#RAC-映射" class="headerlink" title="RAC-映射"></a>RAC-映射</h4><p>RAC的映射在实际开发中有什么用呢？比如我们想要拦截服务器返回的数据，给数据拼接特定的东西或想对数据进行操作从而更改返回值，类似于这样的情况下，我们便可以考虑用 RAC 的映射，实例代码如下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)map &#123;</span><br><span class="line">    <span class="comment">// 创建信号</span></span><br><span class="line">    RACSubject *subject = [RACSubject subject];</span><br><span class="line">    <span class="comment">// 绑定信号</span></span><br><span class="line">    RACSignal *bindSignal = [subject map:^<span class="keyword">id</span>(<span class="keyword">id</span> value) &#123;</span><br><span class="line">        <span class="comment">// 返回的类型就是你需要映射的值</span></span><br><span class="line">        <span class="comment">// 这里将源信号发送的“123” 前面拼接了 ws：</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"ws:%@"</span>, value]; </span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="comment">// 订阅绑定信号</span></span><br><span class="line">    [bindSignal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="comment">// 发送信号</span></span><br><span class="line">    [subject sendNext:<span class="string">@"123"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)flatMap &#123;</span><br><span class="line">    <span class="comment">// 创建信号</span></span><br><span class="line">    RACSubject *subject = [RACSubject subject];</span><br><span class="line">    <span class="comment">// 绑定信号</span></span><br><span class="line">    RACSignal *bindSignal = [subject flattenMap:^RACStream *(<span class="keyword">id</span> value) &#123;</span><br><span class="line">        <span class="comment">// block：只要源信号发送内容就会调用</span></span><br><span class="line">        <span class="comment">// value: 就是源信号发送的内容</span></span><br><span class="line">        <span class="comment">// 返回信号用来包装成修改内容的值</span></span><br><span class="line">        <span class="keyword">return</span> [RACReturnSignal <span class="keyword">return</span>:value];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// flattenMap 中返回的是什么信号，订阅的就是什么信号</span></span><br><span class="line">    <span class="comment">// (那么 x 的值等于 value 的值，如果我们操纵 value 的值那么 x 也会随之而变)</span></span><br><span class="line">    <span class="comment">// 订阅信号</span></span><br><span class="line">    [bindSignal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送数据</span></span><br><span class="line">    [subject sendNext:<span class="string">@"123"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)flattenMap2 &#123;</span><br><span class="line">    <span class="comment">// flattenMap 主要用于信号中的信号</span></span><br><span class="line">    <span class="comment">// 创建信号</span></span><br><span class="line">    RACSubject *signalofSignals = [RACSubject subject];</span><br><span class="line">    RACSubject *signal = [RACSubject subject];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 订阅信号</span></span><br><span class="line">    <span class="comment">//方式1</span></span><br><span class="line">    [signalofSignals subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">        [x subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">           <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="comment">// 方式2</span></span><br><span class="line">    [signalofSignals.switchToLatest];</span><br><span class="line">    <span class="comment">// 方式3</span></span><br><span class="line">    RACSignal *bignSignal = [signalofSignals flattenMap:^RACStream *(<span class="keyword">id</span> value) &#123;</span><br><span class="line">        <span class="comment">//value: 就是源信号发送内容</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;];</span><br><span class="line">    [bignSignal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="comment">// 方式4 也是开发中常用的</span></span><br><span class="line">    [[signalofSignals flattenMap:^RACStream *(<span class="keyword">id</span> value) &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;] subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送信号</span></span><br><span class="line">    [signalofSignals sendNext:signal];</span><br><span class="line">    [signal sendNext:<span class="string">@"123"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="RAC-组合"><a href="#RAC-组合" class="headerlink" title="RAC-组合"></a>RAC-组合</h4><p>把多个信号聚合成你想要的信号</p><p>使用场景：当多个输入框都有值的时候，按钮状态可点击</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把输入框输入值的信号都聚合成按钮是否能点击的信号</span></span><br><span class="line">- (<span class="keyword">void</span>)combineLatest &#123;</span><br><span class="line">    RACSignal *combinSignal = [RACSignal combineLatest:@[<span class="keyword">self</span>.accountField.rac_textSignal, <span class="keyword">self</span>.pwdField.rac_textSignal] reduce:^<span class="keyword">id</span>(<span class="built_in">NSString</span> *account, <span class="built_in">NSString</span> *pwd)&#123; </span><br><span class="line">        <span class="comment">//reduce里的参数一定要和combineLatest数组里的一一对应。</span></span><br><span class="line">    <span class="comment">// block: 只要源信号发送内容，就会调用，组合成一个新值。</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@ %@"</span>, account, pwd);</span><br><span class="line">    <span class="keyword">return</span> @(account.length &amp;&amp; pwd.length);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅信号</span></span><br><span class="line">[combinSignal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="keyword">self</span>.loginBtn.enabled = [x boolValue];</span><br><span class="line">&#125;];    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这样写有些麻烦，可以直接用RAC宏</span></span><br><span class="line">    RAC(<span class="keyword">self</span>.loginBtn, enabled) = combinSignal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)zipWith &#123;</span><br><span class="line">    <span class="comment">// zipWith:把两个信号压缩成一个信号，只有当两个信号同时发出信号内容时</span></span><br><span class="line">    <span class="comment">// 并且把两个信号的内容合并成一个元祖，才会触发压缩流的next事件。</span></span><br><span class="line">    <span class="comment">// 创建信号A</span></span><br><span class="line">    RACSubject *signalA = [RACSubject subject];</span><br><span class="line">    <span class="comment">// 创建信号B</span></span><br><span class="line">    RACSubject *signalB = [RACSubject subject];</span><br><span class="line">    <span class="comment">// 压缩成一个信号</span></span><br><span class="line">    <span class="comment">// **-zipWith-**: 当一个界面多个请求的时候，要等所有请求完成才更新UI</span></span><br><span class="line">    <span class="comment">// 等所有信号都发送内容的时候才会调用</span></span><br><span class="line">    RACSignal *zipSignal = [signalA zipWith:signalB];</span><br><span class="line">    [zipSignal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">        <span class="comment">//所有的值都被包装成了元组</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x); </span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送信号 交互顺序，元组内元素的顺序不会变，跟发送的顺序无关，</span></span><br><span class="line">    <span class="comment">// 而是跟压缩的顺序有关 [signalA zipWith:signalB] --- 先是 A 后是 B</span></span><br><span class="line">    [signalA sendNext:@<span class="number">1</span>];</span><br><span class="line">    [signalB sendNext:@<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任何一个信号请求完成都会被订阅到</span></span><br><span class="line"><span class="comment">// merge: 多个信号合并成一个信号，任何一个信号有新值就会调用</span></span><br><span class="line">- (<span class="keyword">void</span>)merge &#123;</span><br><span class="line">    <span class="comment">// 创建信号A</span></span><br><span class="line">    RACSubject *signalA = [RACSubject subject];</span><br><span class="line">    <span class="comment">// 创建信号B</span></span><br><span class="line">    RACSubject *signalB = [RACSubject subject];</span><br><span class="line">    <span class="comment">// 组合信号</span></span><br><span class="line">    RACSignal *mergeSignal = [signalA merge:signalB];</span><br><span class="line">    <span class="comment">// 订阅信号</span></span><br><span class="line">    [mergeSignal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="comment">// 发送信号---交换位置则数据结果顺序也会交换</span></span><br><span class="line">    [signalB sendNext:<span class="string">@"下部分"</span>];</span><br><span class="line">    [signalA sendNext:<span class="string">@"上部分"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// then 使用需求：有两部分数据：想让上部分先进行网络请求但是过滤掉数据，然后进行下部分的，拿到下部分数据</span></span><br><span class="line">- (<span class="keyword">void</span>)then &#123;</span><br><span class="line">    <span class="comment">// 创建信号A</span></span><br><span class="line">    RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        <span class="comment">// 发送请求</span></span><br><span class="line">        [subscriber sendNext:<span class="string">@"上部分数据"</span>];</span><br><span class="line">        [subscriber sendCompleted]; <span class="comment">// 必须要调用sendCompleted方法！</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建信号B</span></span><br><span class="line">    RACSignal *signalsB = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        <span class="comment">// 发送请求</span></span><br><span class="line">        [subscriber sendNext:<span class="string">@"下部分数据"</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="comment">// 创建组合信号</span></span><br><span class="line">    <span class="comment">// then;忽略掉第一个信号的所有值</span></span><br><span class="line">    RACSignal *thenSignal = [signalA then:^RACSignal *&#123;</span><br><span class="line">        <span class="comment">// 返回的信号就是要组合的信号</span></span><br><span class="line">        <span class="keyword">return</span> signalsB;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 订阅信号</span></span><br><span class="line">    [thenSignal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// concat 使用需求：有两部分数据：想让上部分先执行，完了之后再让下部分执行（都可获取值）</span></span><br><span class="line">- (<span class="keyword">void</span>)concat &#123;</span><br><span class="line">    <span class="comment">// 创建信号A</span></span><br><span class="line">    RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        <span class="comment">// 发送请求</span></span><br><span class="line">        [subscriber sendNext:<span class="string">@"上部分数据"</span>];</span><br><span class="line">        [subscriber sendCompleted]; <span class="comment">// 必须要调用sendCompleted方法！</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建信号B</span></span><br><span class="line">    RACSignal *signalsB = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        <span class="comment">// 发送请求</span></span><br><span class="line">        [subscriber sendNext:<span class="string">@"下部分数据"</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// concat: 按顺序去链接</span></span><br><span class="line">    <span class="comment">//**-注意-**：concat，第一个信号必须要调用sendCompleted</span></span><br><span class="line">    <span class="comment">// 创建组合信号</span></span><br><span class="line">    RACSignal *concatSignal = [signalA concat:signalsB];</span><br><span class="line">    <span class="comment">// 订阅组合信号</span></span><br><span class="line">    [concatSignal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>究其本质核心就是各种 signals，也就是bind（绑定），处理相关事物的时候首先想到的就是绑定，基本大多数操作也都是围绕着信号进行的，以上不仅仅是 RAC 的基本用法，在 MVVM 中也是同样适用，只是把业务和逻辑通过 ViewModel 分离解耦，更大程度的利用了 RAC 在开发中的高效优势。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://halfrost.com/tag/reactivecocoa/" target="_blank" rel="noopener">函数响应式编程(FRP)从入门到”放弃”</a></li><li><a href="http://blog.harrisonxi.com/2017/07/iOS%E4%BD%BF%E7%94%A8RAC%E5%AE%9E%E7%8E%B0MVVM%E7%9A%84%E6%AD%A3%E7%BB%8F%E5%A7%BF%E5%8A%BF.html" target="_blank" rel="noopener">iOS使用RAC实现MVVM的正经姿势</a></li><li><a href="https://draveness.me/tag/RAC/" target="_blank" rel="noopener">『状态』驱动的世界：ReactiveCocoa 系列</a></li><li><a href="http://chaoxn.com/2015/11/12/ReactiveCocoa%E4%B8%8EMVVM/" target="_blank" rel="noopener">ReactiveCocoa学习总结</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;开篇&quot;&gt;&lt;a href=&quot;#开篇&quot; class=&quot;headerlink&quot; title=&quot;开篇&quot;&gt;&lt;/a&gt;开篇&lt;/h2&gt;&lt;p&gt;在 iOS 开发中，或多或少都会见过 RAC 的身影，它为提高开发效率而生，在某些特定情况下开发时可以大大简化代码，并且目前来看安全可靠。如果你还没有接触 RAC，建议你工作之余稍作研究，并尝试体验一下。&lt;br&gt;
    
    </summary>
    
      <category term="rac" scheme="https://blog.yuhanle.com/categories/rac/"/>
    
    
      <category term="rac" scheme="https://blog.yuhanle.com/tags/rac/"/>
    
  </entry>
  
  <entry>
    <title>代码中的缩进线</title>
    <link href="https://blog.yuhanle.com/2018/04/24/line-of-sight-in-code/"/>
    <id>https://blog.yuhanle.com/2018/04/24/line-of-sight-in-code/</id>
    <published>2018-04-24T01:00:00.000Z</published>
    <updated>2021-10-21T08:18:48.338Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/studygolang/gctt-images/master/line-of-sight/1_CBjBs9EzL8q1AL6XvjjpJg.png" alt="我在2016年伦敦Golang英国会议上谈论代码缩进线"></p><p>在近期伦敦举行的 <a href="https://www.youtube.com/watch?v=yeetIgNeIkc" target="_blank" rel="noopener">Golang 英国会议</a> 上，我在<a href="https://www.youtube.com/watch?v=yeetIgNeIkc" target="_blank" rel="noopener">地道的Go 语言窍门</a> 交流（<a href="http://go-talks.appspot.com/github.com/matryer/present/idiomatic-go-tricks/main.slide#1" target="_blank" rel="noopener">幻灯片</a>）中讲到关于代码中的缩进线， 我想在这里稍微解释一下。</p><a id="more"></a><blockquote><p>缩进线是“观察者无障碍视线的直线”</p></blockquote><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images/master/line-of-sight/1_nXXRSHi_1kmgorkcDHyc1Q.png" alt="代码中的缩进线：左图的缩进是错误处理和边缘情况的快乐路径"></p><p>良好的代码缩进线不仅对你的功能没有任何影响，还可以帮助其他需要的人阅读你的代码。其他程序员（包括你未来的自己）可以浏览一个专栏并且理解代码的预期流程。如果他们不得不在脑子里分析 <code>if</code> 语句，若没有良好的缩进线，将会使这个任务变得非常艰难。</p><blockquote><p>大多数人关注编写代码的代价（比如“这需要多长时间才能完成？”）但是维护代码的成本要高得多 - 特别是在成熟的项目中。 让功能明显，清晰，简单易懂才是至关重要的。</p></blockquote><p>良好缩进线的建议：</p><ul><li>让<a href="https://en.wikipedia.org/wiki/Happy_path" target="_blank" rel="noopener">快乐路径</a>居左侧对齐，这样你就可以快速扫描一列来查看预期的执行流程</li><li>不要隐藏缩进大括号中代码逻辑</li><li>尽早的退出 <code>function</code></li><li>避免 <code>else return</code>，考虑翻转 <code>if</code> 语句</li><li>把 <code>return</code> 声明作为最后一行</li><li>提取 <code>function</code> 和 <code>method</code> 以保持结构小巧和可读</li><li>如果你需要大缩进的代码，考虑当做一个 <code>function</code> 分解出来</li></ul><p>当然，会有很多很好的理由来打破所有这些规则 - 但是采用这种风格作为默认规则，我们发现我们的代码变得更具可读性。</p><h2 id="避免-else-return"><a href="#避免-else-return" class="headerlink" title="避免 else return"></a>避免 <code>else return</code></h2><p>编写具有良好视觉效果的代码的关键是保持 <code>else</code> 结构小巧，或者如果可以的话，完全避免它们。 看下这个代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">if something.OK() &#123;</span><br><span class="line">    something.Lock()</span><br><span class="line">    defer something.Unlock()</span><br><span class="line">    err := something.Do()</span><br><span class="line">    if err == nil &#123;</span><br><span class="line">        stop := StartTimer()</span><br><span class="line">        defer stop()</span><br><span class="line">        log.Println(&quot;working...&quot;)</span><br><span class="line">        doWork(something)</span><br><span class="line">        &lt;-something.Done() // wait for it</span><br><span class="line">        log.Println(&quot;finished&quot;)</span><br><span class="line">        return nil</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return err</span><br><span class="line">    &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    return errors.New(&quot;something not ok&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这代表了我们最初如何思考我们的功能在做什么（“如果某件事情没问题，那么就做，如果没有错误，那么做这些事情”等等），但是它变得很难遵循。</p><p>上面的代码很难遵循’快乐路径’（执行顺利进行的路线）。它在第二行开始缩进并从那里继续。 当我们检查来自 <code>something.Do()</code> 的错误返回时，我们进一步缩进。 事实上，语句“ <code>return nil</code> ”在代码中间完全丢失。</p><p><code>else</code> 结构在 Go 和其他语言中作为单一行返回很常见，因为它们要处理中止或退出函数。 我认为他们不能保证缩进我们的其他代码。</p><h2 id="翻转-if-语句"><a href="#翻转-if-语句" class="headerlink" title="翻转 if 语句"></a>翻转 if 语句</h2><p>如果我们要翻译 <code>if</code> 语句<em>（如果你喜欢</em> ， <em>就把它们</em>翻<em>过来）</em> ，你可以看到代码变得更加可读：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">if !something.OK() &#123;  // flipped</span><br><span class="line">    return errors.New(&quot;something not ok&quot;)</span><br><span class="line">&#125;</span><br><span class="line">something.Lock()</span><br><span class="line">defer something.Unlock()</span><br><span class="line">err := something.Do()</span><br><span class="line">if err != nil &#123;       // flipped</span><br><span class="line">    return err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stop := StartTimer()</span><br><span class="line">defer stop()</span><br><span class="line"></span><br><span class="line">log.Println(&quot;working...&quot;)</span><br><span class="line">doWork(something)</span><br><span class="line">&lt;-something.Done() // wait for it</span><br><span class="line">log.Println(&quot;finished&quot;)</span><br><span class="line">return nil</span><br></pre></td></tr></table></figure><p>在此代码中，我们正在尽早退出，退出代码与正常代码不同。而且，</p><ul><li>快乐路径沿着左侧向下保持，</li><li>我们缩进只是为了处理错误和边缘情况，</li><li>我们的 <code>retutn</code> 声明“ <code>return nil</code> ”在最后一行，并且，</li><li>我们有更少的缩进代码块。</li></ul><h2 id="促进大型条件块的功能"><a href="#促进大型条件块的功能" class="headerlink" title="促进大型条件块的功能"></a>促进大型条件块的功能</h2><p>如果你不能避免一个笨重的 <code>else</code> 结构或臃肿的选择切换的情况（我明白了，有时候你不能），那么就考虑把每个结构分解成它自己的功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func processValue(v interface&#123;&#125;) error &#123;</span><br><span class="line">    switch val := v.(type) &#123;</span><br><span class="line">    case string:</span><br><span class="line">        return processString(val)</span><br><span class="line">    case int:</span><br><span class="line">        return processInt(val)</span><br><span class="line">    case bool:</span><br><span class="line">        return processBool(val)</span><br><span class="line">    default:</span><br><span class="line">        return fmt.Errorf(&quot;unsupported type %T&quot;, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这比读取大量的处理代码更容易阅读。</p><h2 id="分享你的经验"><a href="#分享你的经验" class="headerlink" title="分享你的经验"></a>分享你的经验</h2><p>如果你同意我的观点，请考虑分享这篇文章 - 随着越来越多的人注册，更好的（更一致的）Go 代码将会出现。</p><p>你有一些难以阅读的代码吗？ 为什么不在 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;hl=zh-CN&amp;prev=search&amp;rurl=translate.google.com.hk&amp;sl=en&amp;sp=nmt4&amp;u=https://twitter.com/matryer&amp;xid=17259,15700023,15700124,15700149,15700168,15700173,15700186,15700201&amp;usg=ALkJrhgR995EkjexZDOQl9LYu8Sl7eq3TA" target="_blank" rel="noopener">Twitter @matryer</a> 上分享它，可以看看我们是否可以找到一个更清洁，更简单的版本。</p><h2 id="致谢…"><a href="#致谢…" class="headerlink" title="致谢…"></a>致谢…</h2><p>评论家<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;hl=zh-CN&amp;prev=search&amp;rurl=translate.google.com.hk&amp;sl=en&amp;sp=nmt4&amp;u=http://dave.cheney.net/&amp;xid=17259,15700023,15700124,15700149,15700168,15700173,15700186,15700201&amp;usg=ALkJrhgTC1jmfDNNabAZ1iX8dJSOjyuddw" target="_blank" rel="noopener">戴夫切尼</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;hl=zh-CN&amp;prev=search&amp;rurl=translate.google.com.hk&amp;sl=en&amp;sp=nmt4&amp;u=http://twitter.com/dahernan&amp;xid=17259,15700023,15700124,15700149,15700168,15700173,15700186,15700201&amp;usg=ALkJrhhm04bLuew6j4VCw3ACIxtPeMMmxA" target="_blank" rel="noopener">大卫埃尔南德斯</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;hl=zh-CN&amp;prev=search&amp;rurl=translate.google.com.hk&amp;sl=en&amp;sp=nmt4&amp;u=https://twitter.com/goinggodotnet&amp;xid=17259,15700023,15700124,15700149,15700168,15700173,15700186,15700201&amp;usg=ALkJrhi57B943koWpS6pe4_aRslBMy-7mw" target="_blank" rel="noopener">威廉肯尼迪</a> 。</p><hr><p>via: <a href="https://medium.com/@matryer/line-of-sight-in-code-186dd7cdea88" target="_blank" rel="noopener">https://medium.com/@matryer/line-of-sight-in-code-186dd7cdea88</a></p><p>作者：<a href="https://medium.com/@matryer" target="_blank" rel="noopener">Mat Ryer</a>  译者：<a href="https://github.com/yuhanle" target="_blank" rel="noopener">yuhanle</a>  校对：<a href="https://github.com/polaris1119" target="_blank" rel="noopener">polaris1119</a></p><p>本文由 <a href="https://github.com/studygolang/GCTT" target="_blank" rel="noopener">GCTT</a> 原创编译，<a href="https://studygolang.com/articles/12928" target="_blank" rel="noopener">Go语言中文网</a> 荣誉推出</p><p>本文由 GCTT 原创翻译，<a href="https://studygolang.com/articles/12928" target="_blank" rel="noopener">Go语言中文网</a> 首发。也想加入译者行列，为开源做一些自己的贡献么？欢迎加入 <a href="https://studygolang.com/gctt" target="_blank" rel="noopener">GCTT</a>！<br>翻译工作和译文发表仅用于学习和交流目的，翻译工作遵照 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh" target="_blank" rel="noopener">CC-BY-NC-SA 协议规定</a>，如果我们的工作有侵犯到您的权益，请及时联系我们。<br>欢迎遵照 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh" target="_blank" rel="noopener">CC-BY-NC-SA 协议规定</a> 转载，敬请在正文中标注并保留原文/译文链接和作者/译者等信息。<br>文章仅代表作者的知识和看法，如有不同观点，请楼下排队吐槽</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/studygolang/gctt-images/master/line-of-sight/1_CBjBs9EzL8q1AL6XvjjpJg.png&quot; alt=&quot;我在2016年伦敦Golang英国会议上谈论代码缩进线&quot;&gt;&lt;/p&gt;
&lt;p&gt;在近期伦敦举行的 &lt;a href=&quot;https://www.youtube.com/watch?v=yeetIgNeIkc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Golang 英国会议&lt;/a&gt; 上，我在&lt;a href=&quot;https://www.youtube.com/watch?v=yeetIgNeIkc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;地道的Go 语言窍门&lt;/a&gt; 交流（&lt;a href=&quot;http://go-talks.appspot.com/github.com/matryer/present/idiomatic-go-tricks/main.slide#1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;幻灯片&lt;/a&gt;）中讲到关于代码中的缩进线， 我想在这里稍微解释一下。&lt;/p&gt;
    
    </summary>
    
      <category term="Translate" scheme="https://blog.yuhanle.com/categories/Translate/"/>
    
      <category term="Go" scheme="https://blog.yuhanle.com/categories/Translate/Go/"/>
    
    
      <category term="Translate" scheme="https://blog.yuhanle.com/tags/Translate/"/>
    
      <category term="Go" scheme="https://blog.yuhanle.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go 实现对 HTTP 对象的查找</title>
    <link href="https://blog.yuhanle.com/2018/02/24/seeking-around-in-an-http-object/"/>
    <id>https://blog.yuhanle.com/2018/02/24/seeking-around-in-an-http-object/</id>
    <published>2018-02-24T01:00:00.000Z</published>
    <updated>2021-10-21T08:18:48.340Z</updated>
    
    <content type="html"><![CDATA[<p>已发布：<a href="https://studygolang.com/articles/12638" target="_blank" rel="noopener">https://studygolang.com/articles/12638</a></p><h1 id="Go-实现对-HTTP-对象的查找"><a href="#Go-实现对-HTTP-对象的查找" class="headerlink" title="Go 实现对 HTTP 对象的查找"></a>Go 实现对 HTTP 对象的查找</h1><p>想象一下，在 <code>HTTP</code> 服务器上有一个巨大的 <code>ZIP</code> 文件，你想知道里面的内容。你不知道压缩包内是否有你需要的东西，而且你不想下载整个文件。是否可以像执行  <code>unzip -l https://example.com/giant.zip</code> 的操作来查看压缩包的内容呢？</p><p>这并不是一个为了用 <code>Go</code> 展示某些知识的理论问题。实际上，我也不想写一篇文章，除了我想通过那些压缩文件了解如何从 <a href="https://bulkdata.uspto.gov/data/patent/officialgazette/2017/" target="_blank" rel="noopener">美国专利和商标局（USPTO）</a> 下载大量专利。或者，我认为，能够从这些 <code>tar</code> 文件中获取 <a href="https://bulkdata.uspto.gov/data/patent/grant/multipagepdf/1790_1999/" target="_blank" rel="noopener">1790 年发布的一些专利图像</a> 有多酷？</p><p>去看看。那里有数百个巨大的 <code>ZIP</code> 和 <code>tarfiles</code> 值得探索！</p><a id="more"></a><p>在 <code>ZIP</code> 文件中最后的位置，有一个目录。因此在本地磁盘上，<code>“unzip -l”</code> 就像“寻求最终结果，找到 <code>TOC</code>，解析并打印它”一样简单。事实上，我们可以知道 <code>Go</code> 是如何处理的，因为在 <a href="https://godoc.org/archive/zip#NewReader" target="_blank" rel="noopener"><code>zip.NewReader</code> 函数</a> 需要传入一个文件路径。至于 <code>TAR</code> 文件，它们被设计用于磁带流式传输和内存稀少的时候，因此它们的目录在文件本身之间交错排列。</p><p>但我们不在本地，要从 <code>URL</code> 中读取内容对我们来说很有挑战。该怎么办？从哪里开始？</p><p>我们有几件事需要考虑，然后我们可以规划接下来的方向。寻找和读取 <code>HTTP</code> 文件也就是要找到和读取 <code>Range</code> 标头。那么，<code>USPTO</code> 服务器是否支持 <code>Range</code> 头呢？这很容易检查，使用 <code>curl</code> 和 <code>HTTP HEAD</code> 请求：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -I https://bulkdata.uspto.gov/data/patent/officialgazette/2017/e-OG20170103_1434-1.zip</span></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Mon, 11 Dec 2017 21:10:26 GMT</span><br><span class="line">Server: Apache</span><br><span class="line">Last-Modified: Tue, 03 Jan 2017 11:58:45 GMT</span><br><span class="line">ETag: "afb8ac8-5452f63e0a82f"</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Content-Length: 184257224</span><br><span class="line">X-Frame-Options: DENY</span><br><span class="line">Content-Type: application/zip</span><br></pre></td></tr></table></figure><p>请注意那里的 <code>“Accept-Ranges”</code> 标头，它表示我们可以向它发送字节范围。<code>Range</code> 头允许您像随机访问读取操作系统的一样操作 <code>HTTP</code>。（例如 <a href="https://godoc.org/io#ReaderAt" target="_blank" rel="noopener">io.ReaderAt</a> 接口）</p><p>因此理论上可以选择从 <code>Web</code> 服务器下载其中包含元数据（目录）的文件部分来决定下载哪些字节。</p><p>现在我们需要写一个处理 <code>ZIP</code> 文件格式的方法，它可以让我们使用具有 <code>Range</code> 头部的 <code>HTTP</code> 的 <code>GET</code> 请求，只读取元数据的方式，实现替换“读取下一个目录头文件”的某个部分。这就是 <code>Go</code> 的 <a href="https://golang.org/pkg/archive/zip" target="_blank" rel="noopener"><code>archive/zip</code></a> 和 <a href="https://godoc.org/archive/tar" target="_blank" rel="noopener"><code>archive/tar</code></a> 包的实现！</p><p>正如我们前面所说，<a href="https://godoc.org/archive/zip#NewReader" target="_blank" rel="noopener">zip.NewReader</a> 正在琢磨什么位置开始查找。然而，当我们看看 <code>TAR</code> 时，我们发现了一个问题。<code>tar.NewReader</code> 方法需要一个 <code>io.Reader</code>。<code>io.Reader</code> 的问题在于，它不会让我们随机访问资源，就像<code>io.ReaderAt</code> 一样。它是这样实现的，因为它使 <code>tar</code> 包更具适应性。特别是，您可以将 <code>Go tar</code> 包直接挂接到 <code>compress/gzip</code> 包并读取 <code>tar.gz</code> 文件 - 只要您按顺序读取它们，而不是像我们希望的那样跳过。</p><p>那么该怎么办？使用源码。环顾四周，找找<a href="https://github.com/golang/go/blob/c007ce824d9a4fccb148f9204e04c23ed2984b71/src/archive/tar/reader.go#L88" target="_blank" rel="noopener">下一个方法</a>。这就是我们期望它能够找到下一个元数据的地方。在几行代码内，对于 <a href="https://github.com/golang/go/blob/c007ce824d9a4fccb148f9204e04c23ed2984b71/src/archive/tar/reader.go#L407" target="_blank" rel="noopener"><code>skipUnread</code></a> 函数， 我们发现一个有趣的调用。在那里，我们发现一些非常有趣的东西：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// skipUnread skips any unread bytes in the existing file entry, as well as any alignment padding.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tr *Reader)</span> <span class="title">skipUnread</span><span class="params">()</span></span> &#123;</span><br><span class="line">  nr := tr.numBytes() + tr.pad <span class="comment">// number of bytes to skip</span></span><br><span class="line">  tr.curr, tr.pad = <span class="literal">nil</span>, <span class="number">0</span></span><br><span class="line">  <span class="keyword">if</span> sr, ok := tr.r.(io.Seeker); ok &#123;</span><br><span class="line">    <span class="keyword">if</span> _, err := sr.Seek(nr, os.SEEK_CUR); err == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  _, tr.err = io.CopyN(ioutil.Discard, tr.r, nr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Note: This is from Go 1.4, which had a simpler skipUnread than go 1.9 does.</span></span><br></pre></td></tr></table></figure><p>这里表示：”如果 <code>io.Reader</code> 实际上也能够搜索，那么我们不是直接读取和丢弃，而是直接找到正确的地方。“找到了！我们只需要将 <code>tar</code> 文件传给 <code>io.Reader</code>。<code>NewReader</code> 也满足 <a href="https://golang.org/pkg/io/#Seeker" target="_blank" rel="noopener"><code>io.Seeker</code></a>的功能（因此，它是一个<a href="https://golang.org/pkg/io/#ReadSeeker" target="_blank" rel="noopener"><code>io.ReadSeeker</code></a>）。</p><p>所以，现在请查看包 <a href="https://godoc.org/github.com/jeffallen/seekinghttp" target="_blank" rel="noopener"><code>github.com/jeffallen/seekinghttp</code></a>，就像它的名字所暗示的那样，它是一个用于在 <code>HTTP</code> 对象（<a href="https://github.com/jeffallen/seekinghttp" target="_blank" rel="noopener"><code>Github</code> 上的源代码</a> 中查找的软件包。</p><p>这个软件包不仅<a href="https://github.com/jeffallen/seekinghttp/blob/master/seekinghttp.go#L26" target="_blank" rel="noopener">实现</a>了 <code>io.ReadSeeker</code>，还实现了 <code>io.ReaderAt</code>。</p><p>为什么？因为，正如我上面提到的，读取 <code>ZIP</code> 文件需要一个 <code>io.ReaderAt</code>。它还需要传递给它的文件的长度，以便它可以查看目录文件的末尾。<code>HTTP HEAD</code> 方法可以很好地获取 <code>HTTP</code> 对象的 <code>Content-Length</code>，而不需要下载整个文件。</p><p>用于远程获取 <code>tar</code> 和 <code>zip</code> 文件目录的命令行工具位于 <code>remote-archive-ls</code> 中。打开 <code>“-debug”</code> 选项用来查看日志。<strong>将 <code>Go</code> 的标准库作为 <code>TAR</code> 或 <code>ZIP</code> 阅读器“回调”到我们的代码中，并在这里请求几个字节，这里有几个字节是很有趣的。</strong> </p><p>在我第一次运行这个程序后不久，我发现了一个严重的缺陷。这是一个示例运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./remote-archive-ls -debug <span class="string">'https://bulkdata.uspto.gov/data/patent/grant/multipagepdf/1790_1999/grant_pdf_17900731_18641101.tar'</span></span></span><br><span class="line">2017/12/12 00:07:38 got read len 512</span><br><span class="line">2017/12/12 00:07:38 ReadAt len 512 off 0</span><br><span class="line">2017/12/12 00:07:38 Start HTTP GET with Range: bytes=0-511</span><br><span class="line">2017/12/12 00:07:39 HTTP ok.</span><br><span class="line">File: 00000001-X009741H/</span><br><span class="line">2017/12/12 00:07:39 got read len 512</span><br><span class="line">2017/12/12 00:07:39 ReadAt len 512 off 512</span><br><span class="line">2017/12/12 00:07:39 Start HTTP GET with Range: bytes=512-1023</span><br><span class="line">2017/12/12 00:07:39 HTTP ok.</span><br><span class="line">File: 00000001-X009741H/00/</span><br><span class="line">2017/12/12 00:07:39 got read len 512</span><br><span class="line">2017/12/12 00:07:39 ReadAt len 512 off 1024</span><br><span class="line">2017/12/12 00:07:39 Start HTTP GET with Range: bytes=1024-1535</span><br><span class="line">2017/12/12 00:07:39 HTTP ok.</span><br><span class="line">File: 00000001-X009741H/00/000/</span><br><span class="line">2017/12/12 00:07:39 got read len 512</span><br><span class="line">2017/12/12 00:07:39 ReadAt len 512 off 1536</span><br><span class="line">2017/12/12 00:07:39 Start HTTP GET with Range: bytes=1536-2047</span><br><span class="line">2017/12/12 00:07:39 HTTP ok.</span><br><span class="line">File: 00000001-X009741H/00/000/001/</span><br><span class="line">2017/12/12 00:07:39 got read len 512</span><br><span class="line">2017/12/12 00:07:39 ReadAt len 512 off 2048</span><br><span class="line">2017/12/12 00:07:39 Start HTTP GET with Range: bytes=2048-2559</span><br><span class="line">2017/12/12 00:07:39 HTTP ok.</span><br><span class="line">File: 00000001-X009741H/00/000/001/us-patent-image.xml</span><br><span class="line">2017/12/12 00:07:39 got seek 0 1</span><br><span class="line">2017/12/12 00:07:39 got seek 982 1</span><br><span class="line">2017/12/12 00:07:39 got read len 42</span><br><span class="line">2017/12/12 00:07:39 ReadAt len 42 off 3542</span><br><span class="line">2017/12/12 00:07:39 Start HTTP GET with Range: bytes=3542-3583</span><br><span class="line">2017/12/12 00:07:39 HTTP ok.</span><br><span class="line">2017/12/12 00:07:39 got read len 512</span><br><span class="line">2017/12/12 00:07:39 ReadAt len 512 off 3584</span><br><span class="line">2017/12/12 00:07:39 Start HTTP GET with Range: bytes=3584-4095</span><br><span class="line">2017/12/12 00:07:39 HTTP ok.</span><br><span class="line">File: 00000001-X009741H/00/000/001/00000001.pdf</span><br><span class="line">2017/12/12 00:07:39 got seek 0 1</span><br><span class="line">2017/12/12 00:07:39 got seek 320840 1</span><br><span class="line">2017/12/12 00:07:39 got read len 184</span><br><span class="line">2017/12/12 00:07:39 ReadAt len 184 off 324936</span><br><span class="line">...etc...</span><br></pre></td></tr></table></figure><p>你能看到问题吗？这是很多 <code>HTTP</code> 事务！ <code>TAR reader</code> 正在一次一点点地完成 <code>TAR</code> 流，发出一小串 <code>bit</code>。所有这些短的 <code>HTTP</code> 事务在服务器上都很难实现，并且对于吞吐量来说很糟糕，因为每个 <code>HTTP</code> 事务都需要多次往返服务器。</p><p>当然，解决方案是缓存。<strong>读取TAR读取器要求的前 512 个字节，而不是读取其中的 10 倍，以便接下来的几个读取将直接从缓存中获取。</strong>如果读取超出了缓存的范围，我们假设其他读取也将进入该区域，并删除整个当前缓存，以便用当前偏移量的 10 倍填充它。</p><p><code>TAR</code> 阅读器发送<strong>大量小读数</strong>的事实指出了有关缓冲的一些非常重要的事情。将 <a href="https://godoc.org/os#Open" target="_blank" rel="noopener"><code>os.Open</code></a> 的结果直接发送给 <code>tar</code>。<code>NewReader</code> 不是很聪明，尤其是如果你打算跳过文件寻找元数据。尽管 <code>* os.File</code> 实现了 <code>io.ReadSeeker</code>，我们现在知道 <code>TAR</code> 将会向内核发出大量的<strong>小系统调用</strong>。该解决方案与上面的解决方案非常相似，可能是使用 <a href="https://godoc.org/bufio" target="_blank" rel="noopener"><code>bufio</code></a> 包来缓冲 <code>* os.File</code>，以便 <code>TAR</code> 发出的小数据将从 <code>RAM</code> 中取出，而不是转到操作系统。但请注意：它真的是解决方案吗？<code>bufio.Reader</code> 是否真的实现了 <code>io</code>？<code>ReadSeeker</code> 和 <code>io.ReadAt</code> 就像我们需要的一样？ <strong>（破坏者：它没有;也许你们有读者想告诉我们如何使用下一个的替代品 <code>bufio</code> 加速 <code>Go</code> 的 <code>tar</code>？</strong></p><p>我希望你喜欢通过标准库和 <code>HTTP</code>，看看如何与标准库一起工作，以帮助它实现更多的功能，以便它可以帮助你完成你的工作这个小小的旅程。当你实现 <code>io.Reader</code> 和朋友时，你有机会走到你所调用的库的幕后，并从他们的作者从未期望的地方给他们提供数据！</p><hr><p>via：<a href="https://blog.gopheracademy.com/advent-2017/seekable-http/" target="_blank" rel="noopener">https://blog.gopheracademy.com/advent-2017/seekable-http/</a></p><p>作者：<a href="https://github.com/jeffallen" target="_blank" rel="noopener">Jeff R. Allen</a><br>译者：<a href="https://github.com/yuhanle" target="_blank" rel="noopener">yuhanle</a><br>校对：<a href="https://github.com/Unknwon" target="_blank" rel="noopener">Unknwon</a></p><p>本文由 <a href="https://github.com/studygolang/GCTT" target="_blank" rel="noopener">GCTT</a> 原创编译，<a href="https://studygolang.com/" target="_blank" rel="noopener">Go中文网</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;已发布：&lt;a href=&quot;https://studygolang.com/articles/12638&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://studygolang.com/articles/12638&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;Go-实现对-HTTP-对象的查找&quot;&gt;&lt;a href=&quot;#Go-实现对-HTTP-对象的查找&quot; class=&quot;headerlink&quot; title=&quot;Go 实现对 HTTP 对象的查找&quot;&gt;&lt;/a&gt;Go 实现对 HTTP 对象的查找&lt;/h1&gt;&lt;p&gt;想象一下，在 &lt;code&gt;HTTP&lt;/code&gt; 服务器上有一个巨大的 &lt;code&gt;ZIP&lt;/code&gt; 文件，你想知道里面的内容。你不知道压缩包内是否有你需要的东西，而且你不想下载整个文件。是否可以像执行  &lt;code&gt;unzip -l https://example.com/giant.zip&lt;/code&gt; 的操作来查看压缩包的内容呢？&lt;/p&gt;
&lt;p&gt;这并不是一个为了用 &lt;code&gt;Go&lt;/code&gt; 展示某些知识的理论问题。实际上，我也不想写一篇文章，除了我想通过那些压缩文件了解如何从 &lt;a href=&quot;https://bulkdata.uspto.gov/data/patent/officialgazette/2017/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;美国专利和商标局（USPTO）&lt;/a&gt; 下载大量专利。或者，我认为，能够从这些 &lt;code&gt;tar&lt;/code&gt; 文件中获取 &lt;a href=&quot;https://bulkdata.uspto.gov/data/patent/grant/multipagepdf/1790_1999/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1790 年发布的一些专利图像&lt;/a&gt; 有多酷？&lt;/p&gt;
&lt;p&gt;去看看。那里有数百个巨大的 &lt;code&gt;ZIP&lt;/code&gt; 和 &lt;code&gt;tarfiles&lt;/code&gt; 值得探索！&lt;/p&gt;
    
    </summary>
    
      <category term="Translate" scheme="https://blog.yuhanle.com/categories/Translate/"/>
    
      <category term="Go" scheme="https://blog.yuhanle.com/categories/Translate/Go/"/>
    
    
      <category term="Translate" scheme="https://blog.yuhanle.com/tags/Translate/"/>
    
      <category term="Go" scheme="https://blog.yuhanle.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>iOS 真机调试如何安装 WebDriverAgent</title>
    <link href="https://blog.yuhanle.com/2018/01/03/how-to-install-web-driver-agent-on-device/"/>
    <id>https://blog.yuhanle.com/2018/01/03/how-to-install-web-driver-agent-on-device/</id>
    <published>2018-01-03T10:30:47.000Z</published>
    <updated>2021-10-21T08:18:48.337Z</updated>
    
    <content type="html"><![CDATA[<p>近期，微信<a href="https://github.com/wangshub/wechat_jump_game" target="_blank" rel="noopener">跳一跳外挂</a>火了，看了作者的思路和教程，感觉挺简单，不过在实现（照葫芦画瓢）的过程中，遭遇到不少问题。</p><p><img src="https://raw.githubusercontent.com/yuhanle/blogbag/master/uploads/images/wda.png" alt="WDA 工作原理"> </p><p>其中之一便是，真机调试 WDA，参考 iOS 真机如何安装 <a href="https://testerhome.com/topics/7220" target="_blank" rel="noopener">WebDriverAgent · TesterHome</a>，下面就按照这篇教程，各个击破真机调试WDA 的问题：</p><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>首先按照教程，尽量更新下Xcode 的版本，从github 上下载WDA 的最新版本，直接克隆到本地</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/facebook/WebDriverAgent.git</span><br></pre></td></tr></table></figure><p>切换到WDA 根目录，运行初始化脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd WebDriverAgent</span><br><span class="line">./Scripts/bootstrap.sh</span><br></pre></td></tr></table></figure><p>以上脚本是安装依赖库，同时使用npm 打包响应的js 文件。感兴趣的同学可以浏览脚本文件，同级目录下还有一个<code>build.sh</code>，也可以直接执行该脚本来编译安装WDA。当然，初次接触，希望一步步操作的话会好一些。</p><p>如果中途出现错误，需要先解决，否则接下来的操作都无法进行。</p><h1 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h1><p>接下来，通过Xcode 打开<code>WebDriverAgent.xcodeproj</code> 这个文件。</p><p>可以先尝试编译一下，方便定位目前存在的问题，使用组合键或者通过鼠标操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command + b</span><br></pre></td></tr></table></figure><p>这个时候，肯定会有提示配置证书的问题，真机调试证书是必须设置的。可以设置个人开发者免费证书，或者其他付费证书。</p><p><img src="https://raw.githubusercontent.com/yuhanle/blogbag/master/uploads/images/WX20180103-141257.png" alt></p><p>然后选择<code>WebDriverAgentRunner</code> 这个Target 和 真机设备，执行测试。组合键<code>command+u</code>，或从菜单栏Product 中通过鼠标操作</p><blockquote><p>一切正常的话，手机上会出现一个无图标的WebDriverAgent应用，启动之后，马上又返回到桌面。这是很正常的不要奇怪。</p></blockquote><p>应用教程中的原话，上述现象正常，但是也有可能会在控制台报错，从而无法打印出ip 地址。</p><p>当把所有的流程重新捋一遍，你会发现，根本发现不了哪一步做错了，我遇到的情况就是，一直停留在控制台的那里，不会出现奇迹。经过一番搜索，发现<a href="https://testerhome.com/topics/9666" target="_blank" rel="noopener">有个帖子</a>里的警告提示，我决定放手一搏！</p><blockquote><p>你们以为这样就能运行吗？</p><p>并不是！<br>最关键一步来了：</p><p>你要用数据线连着电脑重启你的手机！！！！</p><p>你要用数据线连着电脑重启你的手机！！！！</p><p>你要用数据线连着电脑重启你的手机！！！！</p><p>重要的话要说三遍！</p></blockquote><p>反正是在保证数据线连接的情况下，重启一下手机，然后重新build 就成功看到ip 地址！而且在以后操作中，这种情况还会复现，所以重启手机吧，不用浪费无辜的时间研究~</p><p>通过上面给出的IP和端口，加上<code>/status</code>合成一个url地址。例如<code>http://10.0.0.1:8100/status</code>，然后浏览器打开。如果出现一串JSON输出，说明WDA安装成功了。</p><h1 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h1><p>有些国产的iPhone机器通过手机的IP和端口还不能访问，此时需要将手机的端口转发到Mac上。关于这个问题，我是通过端口转发才看到效果，所以你也应该会遇到同样的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ brew install imobiledevice</span><br><span class="line">$ iproxy 8100 8100 [4c47766e78f9d84e1da55b07d69f2747e9fb4f71]</span><br></pre></td></tr></table></figure><p>使用iproxy –help 可以查到更具体的用法。 这时通过访问<code>http://localhost:8100/status</code> 确认WDA是否运行成功。</p><p>而inspector的地址是<code>http://localhost:8100/inspector</code>， inspector是用来查看UI的图层，方便写测试脚本用。</p><blockquote><p>注：端口转发后，域名不再是IP 地址，而是你的本机IP或者使用<code>localhost</code>+ 端口号</p></blockquote><h1 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h1><p>完成上述操作以后，可以随意开启应用内的某个应用，就能看到如下效果。</p><p><img src="https://raw.githubusercontent.com/yuhanle/blogbag/master/uploads/images/WX20180103-143535.png" alt></p><p>这里结合 <a href="https://testerhome.com/topics/7840" target="_blank" rel="noopener">Appium Desktop</a> 一起食用，效果更佳~</p><p>Good luck!!!</p><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><p>相信你会对这个感兴趣，通过WDA 做自动化测试，恩！</p><p>接下来演示一下怎么用ATX打开iPhone自带的计时器，开始然后退出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/local/bin/python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> atx</span><br><span class="line"></span><br><span class="line">d = atx.connect(<span class="string">"http://localhost:8100"</span>)</span><br><span class="line">d.start_app(<span class="string">"com.apple.mobiletimer"</span>)</span><br><span class="line">d(text=<span class="string">u'计时器'</span>).click()</span><br><span class="line">d(text=<span class="string">u'开始计时'</span>).click()</span><br><span class="line">d(text=<span class="string">u'取消'</span>).click()</span><br><span class="line">d.stop_app()</span><br></pre></td></tr></table></figure><p>执行以上代码即可体验</p><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>最后墙裂推荐基于Python自动化框架地址 <a href="https://github.com/NetEaseGame/ATX" target="_blank" rel="noopener">https://github.com/NetEaseGame/ATX</a></p><p>Xcode问题多多，愿WDA与你同在。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://testerhome.com/topics/7220" target="_blank" rel="noopener">ATX 文档 - iOS 真机如何安装 WebDriverAgent</a></p><p><a href="https://testerhome.com/topics/8820#reply47" target="_blank" rel="noopener">Macaca App Inspector 2.0 发布</a></p><p><a href="https://testerhome.com/topics/7840" target="_blank" rel="noopener">Appium Desktop 简单介绍 —— xcodebuild failed with code 65 解决</a></p><p><a href="https://testerhome.com/topics/9666" target="_blank" rel="noopener">WebDriverAgent 天坑记</a></p><p><a href="https://testerhome.com/topics/7324" target="_blank" rel="noopener">启动 WebDriverAgent 后再启动 appium，运行脚本一直卡在 Waiting for WebDriverAgent to start on device</a></p><p><a href="https://testerhome.com/topics/6331" target="_blank" rel="noopener">ATX 支持 iOS10 手机测试 方法说明</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近期，微信&lt;a href=&quot;https://github.com/wangshub/wechat_jump_game&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;跳一跳外挂&lt;/a&gt;火了，看了作者的思路和教程，感觉挺简单，不过在实现（照葫芦画瓢）的过程中，遭遇到不少问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yuhanle/blogbag/master/uploads/images/wda.png&quot; alt=&quot;WDA 工作原理&quot;&gt; &lt;/p&gt;
&lt;p&gt;其中之一便是，真机调试 WDA，参考 iOS 真机如何安装 &lt;a href=&quot;https://testerhome.com/topics/7220&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;WebDriverAgent · TesterHome&lt;/a&gt;，下面就按照这篇教程，各个击破真机调试WDA 的问题：&lt;/p&gt;
&lt;h1 id=&quot;开始&quot;&gt;&lt;a href=&quot;#开始&quot; class=&quot;headerlink&quot; title=&quot;开始&quot;&gt;&lt;/a&gt;开始&lt;/h1&gt;&lt;p&gt;首先按照教程，尽量更新下Xcode 的版本，从github 上下载WDA 的最新版本，直接克隆到本地&lt;/p&gt;
    
    </summary>
    
      <category term="UI Auto Test" scheme="https://blog.yuhanle.com/categories/UI-Auto-Test/"/>
    
    
      <category term="WDA" scheme="https://blog.yuhanle.com/tags/WDA/"/>
    
      <category term="UI Test" scheme="https://blog.yuhanle.com/tags/UI-Test/"/>
    
  </entry>
  
  <entry>
    <title>Xcode9.2 编译在iOS8.1 系统上图片显示异常</title>
    <link href="https://blog.yuhanle.com/2017/12/09/xocde9-2-and-iOS-8-1-image-unnormal/"/>
    <id>https://blog.yuhanle.com/2017/12/09/xocde9-2-and-iOS-8-1-image-unnormal/</id>
    <published>2017-12-09T01:52:47.000Z</published>
    <updated>2021-10-21T08:18:48.340Z</updated>
    
    <content type="html"><![CDATA[<h2 id="最新消息"><a href="#最新消息" class="headerlink" title="最新消息"></a>最新消息</h2><blockquote><p>目前 xcode 9.3 已经解决了该问题</p></blockquote><a id="more"></a><blockquote><p>Asset Catalog<br>Known Issues<br>When using Xcode 9.2 to create apps that deploy to iOS 8 and later, images in the asset catalog may be corrupted when viewed on devices running iOS 8.3 and earlier. (35379713)<br>Workaround: Build the app using Xcode 9.1, or use Xcode 9.2 and set the deployment target to iOS 8.4 or later.</p></blockquote><hr><p>趁着下载 <code>Xcode 9.1</code> 的空隙，在周末的早晨记录一下这个坑，希望能解决相同遭遇同行的困惑。</p><p><img src="https://github.com/yuhanle/blogbag/raw/master/uploads/images/0342bcd3280e6eaafcd3e99e0f4bc362.jpg" alt></p><h2 id="始因"><a href="#始因" class="headerlink" title="始因"></a>始因</h2><p>昨天刚发布了适配 <code>iPhone X</code> 的最新版本，之所以使用 <code>Xcode 9.2</code> 打包，是因为早期的适配，通过 <code>Xcode 8.2</code> 打包，安装到 <code>iPhone X</code> 上显示的效果是没有适配。</p><p>这个也是无法解释的，我们开发使用的 <code>Xcode 9</code>，在适配过程中没有遇到该问题，总是升级就对了。</p><p>刚好最近苹果爹发布了 <code>Xcode 9.2</code>，就索性升级到最新版本。</p><p>持续化集成就是方便，代码提交以后，喝杯咖啡的工具，就上传成功，等待审核。</p><p>也就是在昨天中午，收到审核通过的提醒，很奇怪，这个时候应该是他们休息的时间。</p><p>然后，就非常肯定，因为在适配的过程中，特意找了两个 <code>iPhone X</code> 的用户帮助测试体验。随着审核通过，就很快发布出去。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>大概下午3点钟，距离发布版本只过了 3 个小时左右。收到客服妹子的一个大写的问号。</p><p><img src="https://github.com/yuhanle/blogbag/raw/master/uploads/images/WX20171209-100043@2x.png" alt></p><p>这一瞬间，整个人都是懵的，慌忙让用户重启 <code>APP</code>，重启系统，升级系统，最后被用户拒绝掉。</p><p>既然是必现的问题，不能将问题推到升级系统上，该解决还是要尽快解决的。</p><p>接着就开始着手另外一个项目，晚上回到家开始思考，问题存在的版本近期究竟改了什么内容。同时也下载了 <code>iOS8.1</code> 的模拟器，使用最新版本的 <code>Xcode</code> 运行看了下效果，确实如此是复现的。</p><p>所以，要马上改变态度，和客服同志搞好关系，早点认错才能走得更远。</p><p><img src="https://github.com/yuhanle/blogbag/raw/master/uploads/images/WX20171209-101223@2x.png" alt></p><h2 id="回忆"><a href="#回忆" class="headerlink" title="回忆"></a>回忆</h2><h3 id="1-删掉LaunchScreen-sb-文件"><a href="#1-删掉LaunchScreen-sb-文件" class="headerlink" title="1. 删掉LaunchScreen.sb 文件"></a>1. 删掉LaunchScreen.sb 文件</h3><p>为了适配 <code>iPhone X</code> 的启动图，同时在启动后使用启动图做了简单的效果，决定使用 <code>LaunchImage</code> 的方式设置启动图。</p><p>在更改代码后，尝试了一下修改结果，依然是非正常的。</p><p>效果如下，丝毫没有改变：</p><p><img src="https://github.com/yuhanle/blogbag/raw/master/uploads/images/Simulator Screen Shot - iPhone 6 - 2017-12-09 at 10.17.01.png" alt></p><h3 id="2-Xcode-版本升级"><a href="#2-Xcode-版本升级" class="headerlink" title="2. Xcode 版本升级"></a>2. Xcode 版本升级</h3><p>这次的改动比较小，所以在排除上述的改动后，直接想到的就是可能就是这个问题，但是很少会怀疑苹果爹会挖这么大的坑，让开发者跳进去。</p><p>不管如何，降级版本试试就知道是不是这个原因。</p><table><thead><tr><th>Xcode9.2</th><th>Xcode9.1</th></tr></thead><tbody><tr><td><img src="https://github.com/yuhanle/blogbag/raw/master/uploads/images/Simulator Screen Shot - iPhone 6 - 2017-12-09 at 10.17.01.png" alt="修改前"></td><td><img src="https://github.com/yuhanle/blogbag/raw/master/uploads/images/Simulator%20Screen%20Shot%20-%20iPhone%206%20-%202017-12-09%20at%2010.51.55.png" alt="修改后"></td></tr></tbody></table><p>通过上述对比，确定问题就处在 <code>Xcode</code> 版本上。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="1-等苹果爹更新"><a href="#1-等苹果爹更新" class="headerlink" title="1. 等苹果爹更新"></a>1. 等苹果爹更新</h3><p>如果苹果爹一直没注意到这个问题，或者没有人提，谁知道还要等多久？<br>关于此问题，我已经向苹果爹提交了 <code>bug</code>，期待后续修复：</p><p><a href="https://bugreport.apple.com/web/?problemID=35948702" target="_blank" rel="noopener">ProblemID=35948702</a></p><h3 id="2-先降级-Xcode"><a href="#2-先降级-Xcode" class="headerlink" title="2. 先降级 Xcode"></a>2. 先降级 Xcode</h3><p>确切的说，这是目前最快捷的一个方式，保证没有问题</p><h3 id="3-改变图片资源存储"><a href="#3-改变图片资源存储" class="headerlink" title="3. 改变图片资源存储"></a>3. 改变图片资源存储</h3><p>图片不要放在 <code>asset</code> 里面，方法放在<code>bundle</code> 里面就没问题。不知道是 <code>Xcode9.2</code> <code>bug</code> 还是没设置相关属性</p><h3 id="4-资源问题优化"><a href="#4-资源问题优化" class="headerlink" title="4. 资源问题优化"></a>4. 资源问题优化</h3><p>换成9.1，不过我发现 @2x, @3x 这三个图标都填满的就没这 <code>BUG</code>，只放一个才有</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://www.cocoachina.com/bbs/read.php?tid=1729079" target="_blank" rel="noopener">Xcode9.2 运行iOS8.1图片异常</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;最新消息&quot;&gt;&lt;a href=&quot;#最新消息&quot; class=&quot;headerlink&quot; title=&quot;最新消息&quot;&gt;&lt;/a&gt;最新消息&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;目前 xcode 9.3 已经解决了该问题&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="tools" scheme="https://blog.yuhanle.com/categories/tools/"/>
    
    
      <category term="tips" scheme="https://blog.yuhanle.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>升级 macOS High Sierra 后与 Cocoapods 的兼容问题</title>
    <link href="https://blog.yuhanle.com/2017/12/06/macos-high-sierra-with-cocoapods/"/>
    <id>https://blog.yuhanle.com/2017/12/06/macos-high-sierra-with-cocoapods/</id>
    <published>2017-12-06T03:42:36.000Z</published>
    <updated>2021-10-21T08:18:48.338Z</updated>
    
    <content type="html"><![CDATA[<p>当你发觉自己没有问题的时候，那就尝试着重启一下，万一问题解决了呢？</p><p>最近实在厌烦苹果推送了 macOS High Sierra 更新，于是一下班前打开电脑更新系统。过程还算顺利，网络很快，大概 10左右就下载完毕，升级过程中卡死，随后就行下班回家，让其升级了一个夜晚</p><p>不过在使用 Cocoapods 的时候还是遇到了问题：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">06-Dec-2017 09:28:38/Users/tianyi/bamboo-agent-home/temp/IOS-PB-JOB1-382-ScriptBuildTask-1550561307052749322.sh: /usr/local/bin/pod: /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/bin/ruby: bad interpreter: No such file or directory</span><br><span class="line">06-Dec-2017 11:24:58env: ruby_executable_hooks: No such file or directory</span><br><span class="line">06-Dec-2017 11:30:11/Users/tianyi/bamboo-agent-home/temp/IOS-PB-JOB1-382-ScriptBuildTask-5355633338674781643.sh: line 7: pod: command not found</span><br><span class="line">06-Dec-2017 11:31:27env: ruby_executable_hooks: No such file or directory</span><br></pre></td></tr></table></figure><p>看起来是 Cocoapods 依赖的 Ruby 版本问题，Google 一下，发现已经有人在 Cocoapods 的 repo 下提了这个 <a href="https://github.com/CocoaPods/CocoaPods/issues/6778" target="_blank" rel="noopener">issue</a>，下面也有开发者给出了解决方案：重新安装 Cocoapods. </p><p>Pod 命令需要用到 2.0 版本的 Ruby 解释器 <code>/System/Library/Frameworks/Ruby.framework/Versions/2.0</code>，而 <code>macOS High Sierra</code> 将系统的 Ruby 解释器升级到了 <code>2.3</code> <code>/System/Library/Frameworks/Ruby.framework/Versions/2.3</code>，因此执行 pod 命令的时候由于找不到 Ruby 解释器而报错。</p><p>于是按照提示重装 Cocoapods：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo gem install cocoapods</span><br></pre></td></tr></table></figure><p>安装完成后继续执行 pod install，又报了同样的错误。我决定继续重装一次 Cocoapods，不过这次加上 –verbose 参数，看看安装过程中做了哪些操作。log 太长我就不贴了，不过注意到最后输出的 pod 命令位置似乎跟上面执行 which pod 输出有点不一样，它是 /usr/bin/pod，而 which pod 的输出是 /usr/local/bin/pod，再看一下我的 $PATH 路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo $PATH</span><br><span class="line">/Users/tianyi/.rvm/gems/ruby-2.4.1/bin:/Users/tianyi/.rvm/gems/ruby-2.4.1@global/bin:/Users/tianyi/.rvm/rubies/ruby-2.4.1/bin:/Users/tianyi/.rvm/bin:/Library/Java/JavaVirtualMachines/jdk1.8.0_91.jdk/Contents/Home/bin:/Users/tianyi/.jenv/shims:/Users/tianyi/.jenv/bin:/opt/subversion/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Applications/Server.app/Contents/ServerRoot/usr/bin:/Applications/Server.app/Contents/ServerRoot/usr/sbin:/usr/local/go/bin:/Users/tianyi/bin:/Users/tianyi/goProject/bin:/usr/local/go/bin:/usr/local/Cellar/nginx/1.12.0/bin:/usr/local/mysql/bin</span><br></pre></td></tr></table></figure><p>可以看到在我的 $PATH 环境变量里，/usr/local/bin 的优先级是高于 /usr/bin 的，因此当这两个地方都存在一个名叫 pod 的命令时，系统优先执行 /usr/local/bin/pod，于是错误就这么产生了。因此我直接删除 /usr/local/bin/pod 文件，再执行 pod install –verbose，这一次果然安装成功了。</p><p>这个问题应该是由于 Cocoapods 改变了安装路径导致的，记得 macOS 启用 System Integrity Protection 之后 Cocoapods 的安装路径也修改过，这次应该也是类似的问题吧，由于 $PATH 这个环境变量的问题，导致老版本的 pod 命令优先被执行。</p><p>事情至此还未结局</p><p>本地执行pod 指令已经没问题了，但是我们通过Bamboo 集成，使用脚本打包，却一直重复前面的错误无法自拔。</p><p>重启bamboo 服务，依然不能解决问题</p><p>尝试着使用重启治百病的手段，电脑关机重启试试看！</p><p>祈祷中…🙏</p><p>2017年12月6日午时三刻更</p><p>说了你可能不相信，重启电脑后，一切问题都好了~</p><p>更新</p><p>解决macOS Sierra下注册机无法运行的问题</p><p>很多软件都不兼容了<br>「安全性与隐私」设置中「任何来源」选项消失<br>几乎所有注册机都用不了</p><p>恢复任何来源选项<br>ps：如果系统升级前就已经选择了任何来源，升级后还会正常显示</p><p>打开终端(Terminal.app)<br>执行<code>sudo spctl --master-disable</code></p><p>“任何来源”恢复~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当你发觉自己没有问题的时候，那就尝试着重启一下，万一问题解决了呢？&lt;/p&gt;
&lt;p&gt;最近实在厌烦苹果推送了 macOS High Sierra 更新，于是一下班前打开电脑更新系统。过程还算顺利，网络很快，大概 10左右就下载完毕，升级过程中卡死，随后就行下班回家，让其升级了一个夜晚&lt;/p&gt;
&lt;p&gt;不过在使用 Cocoapods 的时候还是遇到了问题：&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://blog.yuhanle.com/categories/iOS/"/>
    
    
      <category term="tips" scheme="https://blog.yuhanle.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>伙计们，Go 并没有那么简单</title>
    <link href="https://blog.yuhanle.com/2017/12/04/go-is-not-very-simple-folks/"/>
    <id>https://blog.yuhanle.com/2017/12/04/go-is-not-very-simple-folks/</id>
    <published>2017-12-04T01:00:00.000Z</published>
    <updated>2021-10-21T08:18:48.336Z</updated>
    
    <content type="html"><![CDATA[<p>已发布：<a href="https://studygolang.com/articles/12330" target="_blank" rel="noopener">https://studygolang.com/articles/12330</a></p><h1 id="伙计们，Go-并没有那么简单"><a href="#伙计们，Go-并没有那么简单" class="headerlink" title="伙计们，Go 并没有那么简单"></a>伙计们，Go 并没有那么简单</h1><p>出于好奇，我最近开始接触一些 Go 的代码。我之前对它有一些了解，但是从来没有尝试去写（没有需求）。但是现在我们团队选择使用 Go 来开发一个项目，所以我觉得这是一个获得实际经验的好机会。</p><p>到目前为止，关于这门语言我已经学习了很长时间。在这个博文的末尾，我会写更多关于 Go 的干货。</p><a id="more"></a><p>社区实际上并不那么令人愉快，特别是那些因为它的简单性而主张使用 Go 的人。似乎简单已经成为 Go 社区中的一个流行语，许多人反复重复提到这点，却没有给出太多实际的想法。</p><p>这对我来说似乎很不幸，因为在我看来，Go 是一个“极其简单的语言”：</p><ol><li>不应该作为考虑使用 Go 的主要原因</li><li>从他们的关注点中找到其他更有利的推荐理由</li><li>甚至不是真的（不是真的简单）</li></ol><p>在这篇文章中，我想围绕 Go 来分析一些简单观点。</p><p><em>在深入之前，我想强调一件事情</em>：这篇文章并不是对 Go 的批评，而是一种对 Go 的宣传和倡导的方式。有时候，我可能会批评这个语言的某个方面，但这不是我们关注的重点，我只会试图用一种非正式的、事实的，每种语言都会涉及的方式来讲述。</p><h2 id="我来自哪里"><a href="#我来自哪里" class="headerlink" title="我来自哪里"></a>我来自哪里</h2><p>出于工作和业余爱好，我同时使用多种编程语言。我不赞成有“最喜欢的语言”的概念。过去我曾经有过一些最喜欢的语言，但这种认识往往是一时的情感，随着时间推移，会发生变化。</p><p>在我的工作中，我使用 <code>C++</code> 和 <code>Python</code> 写大型服务的后端代码。过去我曾经在一个你可能知道的操作系统上工作，而且我也做了嵌入式工作。在业余项目中，我做了其他各种事情。</p><p>我并不是夸耀什么（我不是一个专家），我只是想表明，我在编程的许多领域至少有一些见解，而且我一直努力保持开放的心态。</p><p>所以，不要着急，让我们开始讨论正题，看看几个观点。</p><h3 id="1-“与主流语言相比，Go-的关键字非常少”"><a href="#1-“与主流语言相比，Go-的关键字非常少”" class="headerlink" title="1. “与主流语言相比，Go 的关键字非常少”"></a>1. “与主流语言相比，Go 的关键字非常少”</h3><p>我从一个最常见的例子开始。当推广 Go 时，这会是大家的口头禅。</p><p>首先，即使它是真实的，我不知道为什么关键字数量会是判断一个语言的学习曲线或复杂性的重要依据。当然，如果有成千上万的关键字，这可能是一个问题。但是大多数语言最多只有几十个关键字，这种规模下，关键字的多少是无关紧要的。</p><p>我还没有听到有人因为关键字的数量而抱怨某门语言</p><p>其次，Go 所谓的“很少”的关键字实际上只不过是一个聪明律师的伎俩（也许，我甚至会认为这是 Go 的虚假广告）。<a href="https://golang.org/ref/spec#Keywords" target="_blank" rel="noopener">Go 规范</a> 列出了 25 个关键字，这的确比大多数语言要少些。但在我看来，Go 并没有比其他语言关键字表示更少的概念，Go 虽然没有这些关键字，但相应的概念依然是语言的一部分（即实际的复杂性保持不变）。</p><p>为了说明我的意思，请考虑一个 <code>while</code> 循环。 Go 没有这个关键字，这是真的，但它仍然有一个 while 循环，<a href="https://tour.golang.org/flowcontrol/3" target="_blank" rel="noopener">文档</a>甚至是这样说的，它的目的只是重用其他关键字。</p><p>另一个这样的例子是 <code>private</code> 和 <code>public</code>。 Go 没有这些关键字，但它仍然有 <code>private</code> 和 <code>public</code>，它只是使用字母大小写而不是关键字。</p><p>用来删减关键字的另一个技巧叫 <a href="https://golang.org/ref/spec#Predeclared_identifiers" target="_blank" rel="noopener">预定义标识符（Predeclared identifiers）</a>，在技术上它不是关键字，但是在实践中仍然需要它们，创建一个和它同名的变量仍然不是一个好主意，因此，最后看来…它们基本上是关键字。此外，其中一些预定义标识符是其他语言的关键字，因此仅将它们与 Go 的关键字列表进行比较是非常不公平的。就像苹果和桔子。</p><h3 id="2-接收者参数"><a href="#2-接收者参数" class="headerlink" title="2. 接收者参数"></a>2. 接收者参数</h3><p><a href="https://tour.golang.org/methods/1" target="_blank" rel="noopener">接受者参数</a>对我来说有些古怪。看起来 Go 似乎并不建议使用 <code>this</code> 和 <code>self</code>，但是仍然需要方法，所以就存在 “接收者参数”，除了方法签名看上去很奇怪之外，它们基本上是一样的。</p><p>接收者参数有一个问题，当访问一个方法时，我需要知道接收者参数（这是任意的）的名称，以明确这个方法的作用。因为缺少关键字（译注：如 this），语法高亮成为一个问题。（看吧？这是如何减少关键字实际上使事情变得更加复杂的例子。）这有点像 <code>C++</code> 中的隐式 <code>this</code>。</p><p>这里有一个新人容易混淆的<a href="https://stackoverflow.com/questions/17932722/go-difference-between-parameter-and-receiver" target="_blank" rel="noopener">例子</a>。</p><p>恕我直言，最简单、最直接的方式来表达一个接收器是 <a href="https://en.wikipedia.org/wiki/Uniform_Function_Call_Syntax" target="_blank" rel="noopener">UFCS</a>，而不是 C++ 或 Go 的方式。但就像我说的，我不是在抱怨 Go，我真的不介意接受者参数的观点（如果我忍受不了 C++ 的怪异，我可以忍受 Go 的）。</p><h3 id="3-函数返回值"><a href="#3-函数返回值" class="headerlink" title="3. 函数返回值"></a>3. 函数返回值</h3><p>如果接收参数不够，函数甚至能够通过各种形式的返回值来声明。通常语言允许你通过 <code>return</code> 语句返回函数中的一个值。而在 Go 语言中，你可以返回多个值（我认为可以用更优雅的方式通过元组来解决，但是就这样吧）。除此之外，还有<a href="https://tour.golang.org/basics/7" target="_blank" rel="noopener">命名返回值</a>。在我看来，并不是一个好主意，因为它允许我们在那些很难找到返回值的地方写上晕头转向的代码。结合接收方参数，您可以创建这样的函数签名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f Foobar)</span> <span class="title">Something</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>, c <span class="keyword">int</span>)</span> <span class="params">(foo <span class="keyword">int</span>, bar <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是有效的 Go 代码。如您所见，有三个参数。我真的不希望任何人试图选择这个“简单”，因为这个语法除了简单，什么也不是。</p><h3 id="4-“没有继承”"><a href="#4-“没有继承”" class="headerlink" title="4. “没有继承”"></a>4. “没有继承”</h3><p>Go（或许只是社区）似乎很反对“传统的 OOP”（不管这是指哪个，可能是 Java 或者 C++），我记得有人说 Go 没有继承是一件好事。</p><p>除此之外，Go 有一个功能叫做<a href="https://golang.org/doc/effective_go.html#embedding" target="_blank" rel="noopener">嵌入</a>，这个文档以及一些博客文章声称 Go 没有继承。我试着用各种方式使用它，我没法认为 Go 反对继承。上面链接的文档说：</p><blockquote><p>还有种区分内嵌与子类的重要手段。当内嵌一个类型时，该类型的方法会成为外部类型的方法，但当它们被调用时，该方法的接收者是内部类型，而非外部的。</p></blockquote><p>有差别吗？继承通常以相同的方式工作，继承的方法也对内部类型起作用。</p><p>在我看来，在 Go 中，真正唯一不同的是，多态性从结构中解耦。你需要使用接口来使用多态性。但一旦你做了，做的事情和传统的 OOP 非常相似，包括方法覆盖 - <a href="https://play.golang.org/p/DRozP3HCAk" target="_blank" rel="noopener">这里是个演示</a>。</p><p>关于 Go，有件事令我很惊讶 —— 这门所谓简单的语言 —— 你甚至可以实现多重继承。<strong>确实很糟糕。</strong> <a href="https://groups.google.com/forum/#!topic/golang-nuts/fRfkPNlA7Pk" target="_blank" rel="noopener">golang-nut 的邮件列表</a>中，有人提到，Go 并不能很好的处理继承的歧义。我已经调整了其中提及的代码，以便它展示了著名的“可怕的钻石问题”（Dreaded diamond problem）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T1 <span class="keyword">struct</span> &#123;</span><br><span class="line">T2</span><br><span class="line">T3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T2 <span class="keyword">struct</span> &#123;</span><br><span class="line">T4</span><br><span class="line">foo <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T3 <span class="keyword">struct</span> &#123;</span><br><span class="line">T4</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T4 <span class="keyword">struct</span> &#123;</span><br><span class="line">foo <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">t2 := T2&#123; T4&#123; <span class="number">9000</span> &#125;, <span class="number">2</span> &#125;</span><br><span class="line">t3 := T3&#123; T4&#123; <span class="number">3</span> &#125; &#125;</span><br><span class="line">fmt.Printf(<span class="string">"foo=%d\n"</span>, t2.foo)</span><br><span class="line">fmt.Printf(<span class="string">"foo=%d\n"</span>, t3.foo)</span><br><span class="line">t1 := T1&#123;</span><br><span class="line">t2,</span><br><span class="line">t3,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"foo=%d\n"</span>, t1.foo)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://play.golang.org/p/cSCLyGHssR" target="_blank" rel="noopener">在线运行以上代码</a></p><p>上面的代码没有任何编译时警告或者错误。<a href="https://ideone.com/gfKYqR" target="_blank" rel="noopener">这是 C++ 的类似的代码</a>，你可以看到，它编译不通过，因为存在歧义。</p><p>结果会如何？首先，我认为具有多重继承功能，几乎不能在描述该编程语言时使用“简单”一词。<strong>在我看到上面的代码后，没有人能说服我，Go 是最简单的语言之一，甚至连简单语言都不算。</strong>甚至没有其他一些你可以用嵌入来做的事情，比如通过指针嵌入或者通过指针嵌入接口。 （我甚至不确定这些功能的真正含义。）</p><p>其次，我想做一个简短、对 Go 语言本身的批评。不处理这样的歧义似乎是一个设计或者实现错误。甚至连 C++ 都没有如此疯狂，让这种代码编译通过。这足以告诉你一些事情。</p><h3 id="5-错误处理"><a href="#5-错误处理" class="headerlink" title="5. 错误处理"></a>5. 错误处理</h3><p>各种错误处理通常会导致一个巨大的口水战。我不想谈那件事。我曾经在不同的语言中使用过所有常见的错误处理风格（我认为），我也不喜欢所有这些语言。我认为，错误处理无论什么一直是一个 <code>PITA</code>（译注：应该是国外的一种比喻）。把一种风格换成另一种风格，你只需把一套问题换成另一套。没有好的方法。</p><p>回到简单的话题：Go 让我选择不使用异常，这使事情更简单了。多个返回值的特征不能使事情变得简单，这意味着不能返回一个错误或成功的结果，你可以返回所有值或者都不返回（<code>CS</code> 术语，你可以说这个问题是一个产品类型而不是总和式的用法）。事实上，我看过的许多对于新人的代码审查。</p><p>如果 Go 不允许多个返回值，而有一些合适的或者喜欢的类型，在我看来，这会使事情变得更简单。出于同样的原因，在 Go 中忽略错误或者不向向调用者或其他适当目的地报告错误是相当容易的。</p><p>另一不简单的是 panic。不要误解我的意思，我理解它在 Go 中存在的原因以及它的用处，事实上，其他语言也有类似的处理。我只是提出来作为反对简单性的一个论据。恕我直言，对于一个新人，很可能会混淆 error 和 panic 之间的区别，以及什么时候适合用什么。</p><h3 id="6-泛型"><a href="#6-泛型" class="headerlink" title="6. 泛型"></a>6. 泛型</h3><p>这个主题和错误处理比起来，可能是一个更大的蠕虫。</p><p>和 errors 一样，我只想考虑一下这里的复杂性或者简单性。Go 社区的许多人似乎认为，泛型的本质上是复杂的（=坏，嗯嗯嗯咳），有这样或那样的巨大开销。这在某种程度上是事实，但我不认为它像有些人描述的那么糟糕。似乎那些人已经经历了 <code>C++</code> 模板的痛苦，从那以后，无论何时提及泛型，都会遭受 PTSD（创伤后应激障碍） 的攻击。</p><p>看到这里的人，<strong>泛型不是一个怪物</strong>。它们当然绝对不应该像 <code>C++</code> 那样复杂（或者其他一些奇怪的语言）。我的意思是，甚至前端的人都用泛型工作了一段时间（TypeScript, Flow, …），如果他们不害怕泛型，其他程序员应该是没有理由害怕：）（对不起，前端开发者，只是开个玩笑。）</p><p>人们还没有意识到，如果正确地使用泛型，它可以使许多类型和函数的使用更加简单。例如，考虑 Go 中的<a href="https://golang.org/pkg/container/heap/" target="_blank" rel="noopener">堆接口</a>。这就是从一个堆中声明这个接口的方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">popped := heap.Pop(&amp;someheap)</span><br><span class="line">myfoo := popped.(*Foo)       <span class="comment">// ZOMG what just happened here?</span></span><br></pre></td></tr></table></figure><p>对新人解释这些，包括 panic 的问题。也许可以考虑一下，如果他们没有真正把整个 <code>interface{}</code> 搞对，那么会发生什么。相比之下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myfoo := heap.Pop(&amp;someheap) <span class="comment">// myfoo has the correct type</span></span><br></pre></td></tr></table></figure><p>这更容易阅读、更容易解释（你解释它，就像你将解释 <code>map</code> 类型已经存在于 Go！）。而且在编写代码时也更难弄乱。</p><p>缺乏泛型是造成额外复杂性的原因，它在 Go 的其他部分也会造成相当多的复杂性，主要是需要存在各种“神奇”的函数/类型。<code>map</code>，<code>slice</code> 和 <code>channel</code> 类型的魔法，以及伴随的 <code>make()</code> 功能，这是它们三个的构造函数。<code>slice</code> 类型既可以作为数组的引用，也可以作为动态数组。（不管发生什么事，“做一件事，并做好它”？）</p><p>（只是为了提醒大家，我并不介意这些，只是为了不简单的争论而提及它。）</p><h3 id="7-其他"><a href="#7-其他" class="headerlink" title="7. 其他"></a>7. 其他</h3><p>我想我已经把主要的简单违反者排除在外了。我的单子上只剩下几个简单的：</p><ol><li><code>&lt;-</code> 和 <code>-&gt;</code> 操作符。这些可能只是 <code>channel</code> 类型的方法。</li><li><code>iota</code> - 基本一样，但奇怪的枚举。</li><li>内置的复数。</li><li><a href="https://tour.golang.org/flowcontrol/6" target="_blank" rel="noopener">if 支持短语句</a>（有时可能有用，但 <code>if</code> 语法比其他语言中更复杂）</li></ol><p>我想就是这样。可能忘记了什么，但我想已经足够了。</p><p>那么，我觉得如果不是简单的话，Go 实际上会带来什么呢？</p><h2 id="任务-“goroutines”"><a href="#任务-“goroutines”" class="headerlink" title="任务 - “goroutines”"></a>任务 - “goroutines”</h2><p>这可能看起来有点显而易见，因为 <code>goroutines</code> 是一个经常被提及的特性，就像“简单”一样，所以我觉得需要区分下：我认为这不是通常意义上的并发性，它不能认为是 Go 的优势。不要误解我的意思，Go 的并发性是没问题的。只是说这没有什么特别的。你有 channel，这肯定是好的，但基本上，它们只是像我在别处常用的并发队列。然后你有常规的并发原语，像 mutex，读写锁，条件变量等。你可以同步你的代码，你可能会遇到像许多其他语言一样的竞争条件和死锁。</p><p>我喜欢 <code>goroutines</code>（除了明显的事实，它们是轻量级的用户空间线程）是它们可以使用 I/O 的方式 - 调度连接到主机操作系统的低级 I/O API 的方式（如 epoll、kqueue、IOCP…）。这对于程序员来说通常很难做出令人愉快和有用的东西，特别是在编译本地语言的时候。我仍然在这里了解细节，但在我看来，这是一个很好的做法，也是为什么我认为 Go 是未来工程的一个亮点。</p><p>正如已经暗示的，我也喜欢 Go 这种编译为本地代码的语言。看到新的语言使用垃圾收集来保持这种不可思议的效果真是太好了。（或其他形式的自动内存管理 - <code>Swift</code> 中有提及）</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>所以，读者们，为什么所有这些都离开了你呢？是 Go 复杂还是其他什么原因？</p><p>当然不是，绝对不像 <code>C++</code> 或 <code>Haskell</code> 那样复杂。相比之下，Go 的确很简单。另一方面，比较 Go 和其他常见语言（如<code>Java</code> ，<code>JavaScript</code> ，<code>Python</code> 等）的复杂性时，情况就不太清楚了，正如我希望的那样。 （此外，这是一个很难，没有明确定义的任务。）</p><p>我可以提供类似的例子。在某些方面，Go 可能比这些语言更简单，有些则不是…大致上我会说它和其他常用语言的平均差不多。我也不认为简单，无论是感觉上还是实际使用中，最终的体验很重要。</p><p>最后，这篇文章从哪里来，作者是谁？我不肯定。我还不知道 Go 是否会在我的日常工作中被选为一个（子）项目，或者我是否可能将它用于兴趣爱好项目。我想避免像本文提到的那种教条的社区推广的一份子。有没有意识形态导向的地方呢？ 大家可以随意就此提出建议。</p><p>我和 <code>Rust</code> 社区有同样的问题，请不要介意，我也知道离开那些更狂热的支持者会更好。 （Q：“你能否在 <code>Rust</code> 重写你的项目？”A：“迷失了”）也许这就是这些新语言的性质，以及他们为激励人们如此激励阳光的争斗。</p><hr><p>via: <a href="https://medium.com/@bob.clark_34506/go-is-not-very-simple-folks-3e84220e73c7" target="_blank" rel="noopener">https://medium.com/@bob.clark_34506/go-is-not-very-simple-folks-3e84220e73c7</a></p><p>作者：<a href="https://medium.com/@bob.clark_34506" target="_blank" rel="noopener">The Other Bob</a><br>译者：<a href="https://github.com/yuhanle" target="_blank" rel="noopener">yuhanle</a><br>校对：<a href="https://github.com/polaris1119" target="_blank" rel="noopener">polaris1119</a></p><p>本文由 <a href="https://github.com/studygolang/GCTT" target="_blank" rel="noopener">GCTT</a> 原创编译，<a href="https://studygolang.com/" target="_blank" rel="noopener">Go 中文网</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;已发布：&lt;a href=&quot;https://studygolang.com/articles/12330&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://studygolang.com/articles/12330&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;伙计们，Go-并没有那么简单&quot;&gt;&lt;a href=&quot;#伙计们，Go-并没有那么简单&quot; class=&quot;headerlink&quot; title=&quot;伙计们，Go 并没有那么简单&quot;&gt;&lt;/a&gt;伙计们，Go 并没有那么简单&lt;/h1&gt;&lt;p&gt;出于好奇，我最近开始接触一些 Go 的代码。我之前对它有一些了解，但是从来没有尝试去写（没有需求）。但是现在我们团队选择使用 Go 来开发一个项目，所以我觉得这是一个获得实际经验的好机会。&lt;/p&gt;
&lt;p&gt;到目前为止，关于这门语言我已经学习了很长时间。在这个博文的末尾，我会写更多关于 Go 的干货。&lt;/p&gt;
    
    </summary>
    
      <category term="Translate" scheme="https://blog.yuhanle.com/categories/Translate/"/>
    
      <category term="Go" scheme="https://blog.yuhanle.com/categories/Translate/Go/"/>
    
    
      <category term="Translate" scheme="https://blog.yuhanle.com/tags/Translate/"/>
    
      <category term="Go" scheme="https://blog.yuhanle.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>GCD 同步异步以及串并行详解</title>
    <link href="https://blog.yuhanle.com/2017/05/02/gcd-sync-parallel/"/>
    <id>https://blog.yuhanle.com/2017/05/02/gcd-sync-parallel/</id>
    <published>2017-05-02T00:00:00.000Z</published>
    <updated>2021-10-21T08:18:48.336Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://cdn.yuhanle.com/gcd/wind-surfing-67627_1920.jpg" alt="浪起来"></p><p>GCD是iOS开发多线程中经常使用的技术，先看一下GCD中的常见的术语<br><a id="more"></a></p><p>描述多个任务之间同一时刻的运行关系：</p><ul><li>serial（串行） 某一时刻，只执行一个任务</li><li>concurrent（并行） 可以同时执行多个任务</li></ul><p>侧重描述一个函数的执行完成，对其他任务的影响 (既 是否任务在等待某个函数完成，然后才可以运行)：</p><ul><li>synchronous（同步） 任务执行完成后reture，（阻塞）</li><li>asynchronous（异步） 不等待任务执行完成，立即reture，（不阻塞当前）</li></ul><p>在GCD中，我们用串行并行描述队列。这就是在描述，该队列里面的所有任务，相互之间在同一时刻，是怎样的运行关系。是指队列内本身的任务运行顺序。 </p><p>我们还用同步异步，描述某一个任务。比如说任务A是同步执行的。这就是在说，A任务，会阻塞当前任务，直到A结束。这是指不同任务之间的关系，与队列无关，可以是不同队列，也可以是相同队列。</p><p>接下来，我们先来看下，GCD里面的不同队列。</p><h2 id="Serial-Queues"><a href="#Serial-Queues" class="headerlink" title="Serial Queues"></a>Serial Queues</h2><p>在串行队列里，同一时间只能执行一个任务。任务按照被添加进入队列的顺序依次执行。每一个任务只有在前面的任务完成后，才可以开始执行。</p><p>系统为我们提供的串行队列</p><ul><li>main queue ( dispatch_get_main_queue )</li></ul><p>main queue是一个串行队列，有串行队列的一切特性。比较特殊的一点是加入这个队列的任务，都是在主线程执行的。</p><h2 id="Concurrent-Queues"><a href="#Concurrent-Queues" class="headerlink" title="Concurrent Queues"></a>Concurrent Queues</h2><p>加入并行队列的任务，执行的顺序也是按照任务被加入队列的顺序执行，这是我们唯一可以保证的。每个任务都不用等待之前的任务完成，同一时刻可以多个任务同时执行。</p><p>系统同样有一个全局的并发队列</p><ul><li>global dispatch queue ( dispatch_get_global_queue )</li></ul><p>这是另一个我们熟悉的并发队列，很多时候我们直接使用这个队列，可以简单处理一些我们需要并发执行的任务。</p><h2 id="Custom-Queue"><a href="#Custom-Queue" class="headerlink" title="Custom Queue"></a>Custom Queue</h2><p>除了系统提供的全局队列之外，我们还可以自定义串行或者并行的队列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t mySerialQueue = dispatch_queue_create(&quot;com.mySerialQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">dispatch_queue_t myConcurrentQueue = dispatch_queue_create(&quot;com.myConcurrentQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure><p>上面是几种我们用GCD时，需要使用到的队列。</p><p>另外，使用GCD，除了选择正确的队列外，还要关注：我们要执行的任务是同步还是异步执行。</p><h2 id="dispatch-async-异步执行"><a href="#dispatch-async-异步执行" class="headerlink" title="dispatch_async 异步执行"></a>dispatch_async 异步执行</h2><p>dispatch_async 用来用异步的方式执行串行或者并行队列里面的任务，我们来看一下使用 dispatch_async 的几种常见情况：</p><ul><li>custom Serial Queue：当我们需要执行几个应该串行执行的任务，又不阻塞当前的时候。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// task1 task2 顺序依次执行，同时不阻塞others</span><br><span class="line"></span><br><span class="line">dispatch_queue_t mySerialQueue = dispatch_queue_create(&quot;com.mySerialQueue&quot;, NULL);</span><br><span class="line"></span><br><span class="line">dispatch_async(mySerialQueue, ^&#123;</span><br><span class="line">   ...task1</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(mySerialQueue, ^&#123;</span><br><span class="line">  ...task2</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">...others</span><br></pre></td></tr></table></figure><ul><li><p>main Queue：当我们执行并完成了一段异步的任务，需要回到主线程更新UI的时候，很常见的选择就是使用GCD的 main queue。</p></li><li><p>custom or global concurrent Queue：这个是我们执行非UI任务的常见选择。要注意的是，加入队列的多个任务之间并发执行，我们无法知道那个任务先完成。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t myConcurrentQueue = dispatch_queue_create(&quot;com.myConcurrentQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">dispatch_async(myConcurrentQueue, ^&#123;</span><br><span class="line">  </span><br><span class="line">  ...task1    </span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">          Update UI </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="dispatch-sync-同步执行"><a href="#dispatch-sync-同步执行" class="headerlink" title="dispatch_sync 同步执行"></a>dispatch_sync 同步执行</h2><p>大部分时候我们执行dispatch_sync操作，都要格外小心些。</p><ul><li>custom or main Serial Queue： 同步执行串行队列时，要注意防止发生死锁，比如下面的代码:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/串行队列中，task2 等待 task1完成，所以不会开始。而task1又完成不了，因为task2还没有执行完(甚至都没有开始)。死锁。</span><br><span class="line">  </span><br><span class="line">dispatch_queue_t mySerialQueue = dispatch_queue_create(&quot;com.mySerialQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    </span><br><span class="line">dispatch_sync(mySerialQueue, ^&#123;</span><br><span class="line">    </span><br><span class="line">    ...task1</span><br><span class="line">    dispatch_sync(mySerialQueue, ^&#123;</span><br><span class="line">       </span><br><span class="line">       ...task2            </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>concurrent Queue：合理使用可以解决一些并发读写问题。例如</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//task1 执行结束后，task2才会开始执行。</span><br><span class="line">dispatch_queue_t myConcurrentQueue = dispatch_queue_create(&quot;com.myConcurrentQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">dispatch_sync(myConcurrentQueue, ^&#123;</span><br><span class="line">    </span><br><span class="line">  ...task1 读</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line">dispatch_async(myConcurrentQueue, ^&#123;</span><br><span class="line">    </span><br><span class="line">  ...task2 写</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="dispatch-after"><a href="#dispatch-after" class="headerlink" title="dispatch_after"></a>dispatch_after</h2><p>异步延迟操作。实际上 dispatch_after 就像一个延迟执行的 dispatch_async。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">double delayInSeconds = 1.0;</span><br><span class="line">dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * NSEC_PER_SEC));</span><br><span class="line"> dispatch_after(popTime, dispatch_get_main_queue(), ^(void)&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://cdn.yuhanle.com/gcd/wind-surfing-67627_1920.jpg&quot; alt=&quot;浪起来&quot;&gt;&lt;/p&gt;
&lt;p&gt;GCD是iOS开发多线程中经常使用的技术，先看一下GCD中的常见的术语&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://blog.yuhanle.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://blog.yuhanle.com/tags/iOS/"/>
    
      <category term="GCD" scheme="https://blog.yuhanle.com/tags/GCD/"/>
    
  </entry>
  
  <entry>
    <title>GCD 同步操作之 Resource Competition</title>
    <link href="https://blog.yuhanle.com/2017/04/28/gcd-sync-barriers-groups-semaphore/"/>
    <id>https://blog.yuhanle.com/2017/04/28/gcd-sync-barriers-groups-semaphore/</id>
    <published>2017-04-28T00:00:00.000Z</published>
    <updated>2021-10-21T08:18:48.335Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://cdn.yuhanle.com/gcd/surfer-2212948_1920.jpg" alt="更快更高更强"></p><p>在学会简单的使用GCD处理多线程之后，我们来再深入了解下GCD对多线程的一些同步控制。<br><a id="more"></a></p><h2 id="dispatch-barriers"><a href="#dispatch-barriers" class="headerlink" title="dispatch barriers"></a>dispatch barriers</h2><p>在使用 Concurrent Queue 的时候，有时候我们希望队列中的某项任务，能够被串行执行，来避免资源竞争等多线程问题。比如遇到读写问题，这时候我们就需要使用 dispatch barriers。来保证即使在并行队列中，对某个对象的读和写操作，在同一时刻，只有一个可以被执行。这时候就可以用到 dispatch barriers了。下面我们来讨论一下，不同的队列中barriers的使用：</p><ul><li><p>Custom Serial Queue: 在串行队列中，队列都是顺序串行执行，使用barriers没有任何好处。一般来讲我们不需要这么做。</p></li><li><p>Global Concurrent Queue: 这里虽然是并行队列，但这个队列是全局的，我们不能保证别人没有使用这个队列。对这个队列加barriers，可能会影响到其他模块的功能。所以不建议在这个队列中使用。</p></li><li><p>Custom Concurrent Queue: 在自定义的并行队列中使用barriers，是比较合适的方式。</p></li></ul><p>所以当我们要做的并行操作，可能存在线程安全问题的时候。我们最好考虑新建自定义并行队列，而不是简单地使用系统提供的 Global Queue。</p><p>举一个例子，假设某一个类要管理MyClass这个类型的读写，下面列举这个类的一些相关方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//初始化自定义并发队列</span><br><span class="line">  - (instancetype)init&#123;</span><br><span class="line">      </span><br><span class="line">      if(self = [super init])&#123;</span><br><span class="line">          customConcurrentQueue = dispatch_queue_create(&quot;com.customConcurrentQueue&quot;, DISPATCH_QUEUE_CONCURRENT); </span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //写方法</span><br><span class="line">  - (void)write:(MyClass *)myClass &#123;</span><br><span class="line">  </span><br><span class="line">      if( myClass )&#123;</span><br><span class="line">          </span><br><span class="line">          //使用barrier，保证写方法，可以串行执行</span><br><span class="line">            dispatch_barrier_async(self.customConcurrentQueue, ^&#123; </span><br><span class="line">              </span><br><span class="line">              //写操作</span><br><span class="line">              ...</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //读方法</span><br><span class="line">  - (MyClass *)read&#123;</span><br><span class="line">      </span><br><span class="line">      //要保证，读和写方法不能同时执行，</span><br><span class="line">      //首先，他们要在同一个队列中 ：self.customConcurrentQueue</span><br><span class="line">      //其次，读方法要等待读出数据后返回，所以应该是同步操作 ：dispatch_sync</span><br><span class="line">      </span><br><span class="line">      __block MyClass *myClass = [[MyClass alloc] init];</span><br><span class="line">      </span><br><span class="line">      dispatch_sync(self.customConcurrentQueue, ^&#123;</span><br><span class="line">      </span><br><span class="line">          //读操作</span><br><span class="line">          myClass = ...</span><br><span class="line">      &#125;);</span><br><span class="line">      </span><br><span class="line">      return myClass;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="dispatch-groups"><a href="#dispatch-groups" class="headerlink" title="dispatch groups"></a>dispatch groups</h2><p>有时候，我们需要在多个并行任务全部完成后，做一些操作，这时候就需要用到 group来管理了。</p><p>举一个简单的例子。我有4个任务要使用并发处理，任务4要等待，任务1、2、3完成后执行。同时，任务4不阻塞当前的线程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">- (void)testDispatchGroup&#123;</span><br><span class="line"></span><br><span class="line">  dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;com.test.testConcurrent&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">  dispatch_group_t group = dispatch_group_create();</span><br><span class="line"></span><br><span class="line">  //异步操作</span><br><span class="line">  dispatch_group_async(group, concurrentQueue, ^&#123;</span><br><span class="line">         </span><br><span class="line">      任务1</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  dispatch_group_async(group, concurrentQueue, ^&#123;</span><br><span class="line">         </span><br><span class="line">      任务2</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  dispatch_group_async(group, concurrentQueue, ^&#123;</span><br><span class="line">         </span><br><span class="line">      任务3</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  //dispatch_group_notify 中的block执行的是我们最后要做的任务。同时，这里是异步操作，不会阻塞后面其他代码的执行。</span><br><span class="line">  dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">      </span><br><span class="line">      //前面3个任务，都执行完成后，执行里面的block</span><br><span class="line">      任务4</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看另一个需求，还是之前的4个任务。唯一的区别是，任务4除了要等待其他任务完成，还要阻塞当前线程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (void)testDispatchGroup&#123;</span><br><span class="line"></span><br><span class="line">  dispatch_group_t group = dispatch_group_create();</span><br><span class="line"></span><br><span class="line">  //异步操作</span><br><span class="line">  dispatch_group_async(group, concurrentQueue, ^&#123;</span><br><span class="line">         </span><br><span class="line">      任务1</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  dispatch_group_async(group, concurrentQueue, ^&#123;</span><br><span class="line">         </span><br><span class="line">      任务2</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  dispatch_group_async(group, concurrentQueue, ^&#123;</span><br><span class="line">         </span><br><span class="line">      任务3</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  //dispatch_group_wait 等待上面任务全部完成，阻塞当前线程，直到超过设置的时间</span><br><span class="line">  //使用时，要注意避免阻塞主线程等问题</span><br><span class="line">  dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span><br><span class="line">  </span><br><span class="line">  任务4</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，除了使用<code>dispatch_group_async</code>管理要做的任务。还可以使用<code>dispatch_group_enter</code>、 <code>dispatch_group_leave</code> 组合的方式，手动通知任务完成。如果使用手动管理的话，我们要注意：<code>enter</code>和<code>leave</code>方法，应该是成对出现的。</p><p>dispatch_group_enter(customGroup) : 手动告知customGroup，表示一个任务已经开始执行。</p><p>dispatch_group_leave(customGroup) : 手动告知<code>customGroup</code>，表示一个任务已经完成。当所有<code>enter</code>对应的<code>leave</code>方法都执行过后。我们的<code>dispatch_group_notify()</code>或者<code>dispatch_group_wait()</code>，就可以接到任务完成的通知。</p><h2 id="dispatch-semaphore-信号量"><a href="#dispatch-semaphore-信号量" class="headerlink" title="dispatch semaphore 信号量"></a>dispatch semaphore 信号量</h2><p>当有多个消费者，访问有限的资源的时候，<a href="https://en.wikipedia.org/wiki/Semaphore_(programming" target="_blank" rel="noopener">信号量</a>) 可以让我们更好的控制。简单来说，我们通过对信号个数的控制，来达到线程间的同步操作。当信号个数为0的时候，当前线程被阻塞，等待信号量增加，当信号量个数大于0的时候，则线程继续执行。</p><p>注意，同步的操作都要小心使用，避免死锁等问题。</p><p>另外，根据dispatch_semaphore_wait的返回值，可以用于判断某任务是否超时操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (void)testSemaphore&#123;</span><br><span class="line"></span><br><span class="line">  //创建 信号量 参数代表初始个数</span><br><span class="line">  dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">  </span><br><span class="line">      sleep(2);</span><br><span class="line">  </span><br><span class="line">      //发送一个信号，信号量个数 +1   </span><br><span class="line">      dispatch_semaphore_signal(semaphore);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">  </span><br><span class="line">      dispatch_time_t timeoutTime = dispatch_time(DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC);</span><br><span class="line">  </span><br><span class="line">      //线程等待，当信号量大于0时 任务继续执行，信号量 -1</span><br><span class="line">      //线程等待，超过预定的超时时间 任务继续执行 信号量不变</span><br><span class="line">      //关于返回值：当返回值 不为0 的时候，说明超时</span><br><span class="line">      if( dispatch_semaphore_wait(semaphore, timeoutTime) )&#123;</span><br><span class="line">          NSLog(@&quot;time out&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://cdn.yuhanle.com/gcd/surfer-2212948_1920.jpg&quot; alt=&quot;更快更高更强&quot;&gt;&lt;/p&gt;
&lt;p&gt;在学会简单的使用GCD处理多线程之后，我们来再深入了解下GCD对多线程的一些同步控制。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://blog.yuhanle.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://blog.yuhanle.com/tags/iOS/"/>
    
      <category term="GCD" scheme="https://blog.yuhanle.com/tags/GCD/"/>
    
  </entry>
  
  <entry>
    <title>离开象牙塔以后</title>
    <link href="https://blog.yuhanle.com/2017/04/18/say-hello-work/"/>
    <id>https://blog.yuhanle.com/2017/04/18/say-hello-work/</id>
    <published>2017-04-18T00:00:00.000Z</published>
    <updated>2021-10-21T08:18:48.339Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://cdn.yuhanle.com/nenshuocijun/architecture-768432_1920.jpg" alt="离开象牙塔以后"></p><p>学校出来有很多区别，其中有一点是最无聊的。</p><a id="more"></a><p>由过去的三点一线，转变成两点一线，没了教室，没了食堂，变成了公司和宿舍。</p><p>没有认真数过，平均每天，在同一条路上来回，将近三年，磨平了几双鞋子，擦碰过多少次路边的槐树。</p><p>出了地铁站，有一个红绿灯路口，八点半钟是高峰期，人正多，很多人迫不及待，趁着车来车往，迅速的窜到对面，急匆匆地消失在视线里。</p><p>习惯过了马路，穿过停车场，因为路边的小路很窄，如果对面同时走过来一个人，就需要相互侧身，就像那篇雨巷，也经常的不小心踩到石坑，污泥溅到另一双鞋子。</p><p>停车场里走着，很危险，可能正在玩手机，我没注意。有一次，有位女士，低着头走着走着，穿过停车杆，没想到停车杆当时正在下落，我能听到敲击头部的声音，很脆，接着就是歇斯底里的嗷叫。</p><p>路边有个快客，我一直以为他是假的快客，在我印象中，这个名字不应该是感冒药吗？很少去光顾这家便利店，因为东西少，不合口味，还特别的贵，除了早餐，还有午饭，零食，如果时间来得及，我会去那家罗森买杯永和豆浆，虽然喝起来没有大豆的味道，但还蛮合口味，特别是冬天，路上顺便暖暖手。</p><p>办公楼里的电梯，工作日上班时间，我没有乘过。就在五楼，闭着眼我都摸上去了，平日里吹嘘着锻炼身体，要减肥，这也是唯一能够坚持下去，锻炼的方式了。</p><p>很想念，两年前每天来回骑行20公里的日子，身体是好了些，腿越来越粗，越有力，凌晨两点的路上，迎着风，骑在快车道上，肚子饿的话就在路边吃点路边摊。摊主们出来的很晚，以至于我的很多朋友都说没见过路边摊，也许是上海整治的很严格吧！</p><p>不管这一天，如何如何，也不会影响新的一天。</p><p>或许，只有清华北大才能称之为象牙塔吧？</p><hr><p>题图：aobahorse 不要求署名</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://cdn.yuhanle.com/nenshuocijun/architecture-768432_1920.jpg&quot; alt=&quot;离开象牙塔以后&quot;&gt;&lt;/p&gt;
&lt;p&gt;学校出来有很多区别，其中有一点是最无聊的。&lt;/p&gt;
    
    </summary>
    
      <category term="suibi" scheme="https://blog.yuhanle.com/categories/suibi/"/>
    
    
      <category term="motion" scheme="https://blog.yuhanle.com/tags/motion/"/>
    
  </entry>
  
  <entry>
    <title>通过Sonar 初步构建代码持续审查</title>
    <link href="https://blog.yuhanle.com/2017/02/15/continuous-code-quality-sonarqube-install/"/>
    <id>https://blog.yuhanle.com/2017/02/15/continuous-code-quality-sonarqube-install/</id>
    <published>2017-02-15T00:00:00.000Z</published>
    <updated>2021-10-21T08:18:48.334Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://cdn.yuhanle.com/continuous-code-quality-sonarqube-install/Benefits-of-Using-SonarQube-For-Code-Reviews.jpg" alt="SonarQube"></p><h2 id="介绍篇"><a href="#介绍篇" class="headerlink" title="介绍篇"></a>介绍篇</h2><h3 id="SonarQube-介绍"><a href="#SonarQube-介绍" class="headerlink" title="SonarQube 介绍"></a>SonarQube 介绍</h3><p><a href="https://www.sonarqube.org/" target="_blank" rel="noopener">SonarQube</a> 是一款领先的持续代码质量监控平台，开源在github 上，现在已更新到6.2 版本，star 数量超过 1400+，可以轻松配置在内网服务器，实时监控代码，帮助了解提升提升团队项目代码质量。通过插件机制，SonarQube可以继承不同的测试工具，代码分析工具，以及持续集成工具。</p><a id="more"></a><p>与持续集成工具（例如 Hudson/Jenkins 等）不同，SonarQube 并不是简单地把不同的代码检查工具结果（例如 FindBugs，PMD 等）直接显示在 Web 页面上，而是通过不同的插件对这些结果进行再加工处理，通过量化的方式度量代码质量的变化，从而可以方便地对不同规模和种类的工程进行代码质量管理。</p><p>在对其他工具的支持方面，Sonar 不仅提供了对 IDE 的支持，可以在 Eclipse 和 IntelliJ IDEA 这些工具里联机查看结果；同时 SonarQube 还对大量的持续集成工具提供了接口支持，可以很方便地在持续集成中使用 SonarQube。</p><p>此外，SonarQube 的插件还可以对 Java 以外的其他编程语言提供支持，对国际化以及报告文档化也有良好的支持。</p><p>行业内提到”代码质量管理, 自动化质量管理”, 一般指的都是通过Sonar来实现。本文的目标是实现在Sonar上显示出iOS项目, 先看张最终的效果图:</p><p><img src="http://cdn.yuhanle.com/continuous-code-quality-sonarqube-install/main-des.png" alt="SonarQube"></p><p>用Sonar能够实现什么?</p><ul><li>技术债务(sonar根据”规则”扫描出不符合规则的代码)</li><li>覆盖率(单元测试覆盖率)</li><li>重复(重复的代码, 有利于提醒封装)</li><li>结构</li></ul><p>问题1: “规则”指的是什么? </p><pre><code>在Sonar工具中配置检测工具(规则), 然后sonar根据规则检测&quot;质量报告文件&quot;, 得出问题数目。 比如本文配置的规则是OCLint</code></pre><p>问题2: 技术债务的天数怎么得出?</p><pre><code>每个规则都有对应的处理时间, 最后:问题类型1数目 * 对应时间 + 问题类型2数目 * 对应时间 +... 得到时间。</code></pre><h3 id="SonarQube-工作流程"><a href="#SonarQube-工作流程" class="headerlink" title="SonarQube 工作流程"></a>SonarQube 工作流程</h3><p>SonarQube 并不是简单地将各种质量检测工具的结果（例如 FindBugs，PMD 等）直接展现给客户，而是通过不同的插件算法来对这些结果进行再加工，最终以量化的方式来衡量代码质量，从而方便地对不同规模和种类的工程进行相应的代码质量管理。</p><p>SonarQube 在进行代码质量管理时，会从图 1 所示的七个纬度来分析项目的质量。</p><p><img src="http://cdn.yuhanle.com/continuous-code-quality-sonarqube-install/image001.png" alt="图 1"></p><p>SonarQube 不是那种安装即可用的工具，他需要数据库的支持，用于存储检测项目后的分析数据，同时为了实现可持续监测，还需要项目持续集成工具（如Jenkins）的支持，在构建版本前，通过Jenkins+Sonar 插件执行项目分析指令，最终的结果会通过SonarQube 服务器的Web 页面展示。</p><p><img src="http://cdn.yuhanle.com/continuous-code-quality-sonarqube-install/image4.png" alt="网络图"></p><p>下面我们就通过mysql+Jenkins+SonarQube 实现项目代码质量的可持续监测</p><p><img src="http://cdn.yuhanle.com/continuous-code-quality-sonarqube-install/SQ55Integration.png" alt></p><h2 id="安装篇"><a href="#安装篇" class="headerlink" title="安装篇"></a>安装篇</h2><h3 id="SonarQube-的安装"><a href="#SonarQube-的安装" class="headerlink" title="SonarQube 的安装"></a>SonarQube 的安装</h3><h4 id="涉及到的知识点"><a href="#涉及到的知识点" class="headerlink" title="涉及到的知识点"></a>涉及到的知识点</h4><ul><li>XCTool工具</li><li>OClint工具</li><li>Gcovr工具</li><li>Git, SVN命令</li><li>Linux 命令</li><li>mysql 操作</li><li>Jenkins工具</li><li>Sonar工具</li><li>Shell语法</li><li>Sonar-runner工具</li></ul><h4 id="软件及硬件的要求"><a href="#软件及硬件的要求" class="headerlink" title="软件及硬件的要求"></a>软件及硬件的要求</h4><p>SonarQube 的安装通常需要满足一定的软硬件条件，具体要求如下所示：</p><ol><li><p>Server 要求</p><p> Web server 最少需要 500MB 的内存空间，推荐内存空间大小 2GB。Sonar 在进行代码质量分析时，通常大约每 1 KLOC 需要存储 350KB 左右的数据，所以要尽量为 SonarQube 的 web server 提供大的内存。</p></li><li><p>Database 要求</p><p> 尽管 SonarQube 本身自带嵌入的 Derby 数据库，但是由于 Derby 比较简单，所以在生产环境中强烈推荐安装相应的企业版数据库，SonarQube 支持的数据库包括： MySQL 5.x+、Oracle10g+、PostgreSQL 9.x 和 MS SQLServer 2005 and 2008，推荐使用 MySQL。</p></li><li><p>Browser 要求</p><p> SonarQube 支持大多数的浏览器，包括 Firefox、Internet Explorer 7.x and 8.x and chromed 等，推荐使用 chromed。</p><p> <del>目前官方最新的版本是6.2，但是对于部分插件会存在不兼容的问题，导致Sonar 服务启动失败，所以为了使用和演示，我采用了旧版本4.5.7，因为此版本兼容 sonar-objective-c-plugin-0.3.1 插件。</del></p><p> <strong>更新：</strong></p><p> 关于XCode8的兼容方案, 请看<a href="https://my.oschina.net/ChenTF/blog/806565" target="_blank" rel="noopener">这篇文章</a></p></li></ol><h4 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h4><ol><li><p>数据库配置</p><p> 进入数据库命令模式或者直接使用GUI 工具，创建Sonar-Qube 服务所需的数据库</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br><span class="line">mysql&gt; CREATE DATABASE sonar CHARACTER SET utf8 COLLATE utf8_general_ci; </span><br><span class="line">mysql&gt; CREATE USER &apos;sonar&apos; IDENTIFIED BY &apos;sonar&apos;;</span><br><span class="line">mysql&gt; GRANT ALL ON sonar.* TO &apos;sonar&apos;@&apos;%&apos; IDENTIFIED BY &apos;sonar&apos;;</span><br><span class="line">mysql&gt; GRANT ALL ON sonar.* TO &apos;sonar&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;sonar&apos;;</span><br><span class="line">mysql&gt; FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><p> <img src="http://cdn.yuhanle.com/continuous-code-quality-sonarqube-install/init-sql.png" alt="创建数据库"></p><p> 完成以后测试一下连接是否正确</p></li><li><p>安装SonarQube 与SonarQube-Runner</p><p> SonarQube Runner 2.4 <a href="https://docs.sonarqube.org/display/SONARQUBE45/Installing+and+Configuring+SonarQube+Runner" target="_blank" rel="noopener">下载地址</a></p><p> 从官网下载 SonarQube 的最新版本并解压到<code>/usr/local/</code>文件夹    </p><p> <img src="http://cdn.yuhanle.com/continuous-code-quality-sonarqube-install/sonar-install-2.png" alt="SonarQube"></p><p> 添加SONAR_HOME、SONAR_RUNNER_HOME 环境变量，并将SONAR_RUNNER_HOME 加入PATH</p></li><li><p>修改Sonar-Qube 配置文件</p><p> 配置文件路径在 <code>./conf/sonar.properties</code></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 设置数据库的账户密码</span><br><span class="line">sonar.jdbc.username=ua</span><br><span class="line">sonar.jdbc.password=pwd</span><br><span class="line"></span><br><span class="line">sonar.jdbc.url=jdbc:mysql://localhost:3306/sonar?useUnicode=true&amp;characterEncoding=utf8&amp;rewriteBatchedStatements=true&amp;useConfigs=maxPerformance</span><br><span class="line"></span><br><span class="line"># By default, ports will be used on all IP addresses associated with the server.</span><br><span class="line">sonar.web.host=0.0.0.0</span><br><span class="line"></span><br><span class="line"># The default value is root context (empty value).</span><br><span class="line">sonar.web.context=/</span><br><span class="line"># TCP port for incoming HTTP connections. Default value is 9000.</span><br><span class="line">sonar.web.port=9003</span><br></pre></td></tr></table></figure></li><li><p>运行如下命令启动 Sonar-Qube，根据操作系统选择</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Last login: Wed Feb 15 18:15:05 on ttys000</span><br><span class="line">localhost:~ tianyi$ /usr/local/sonarqube-6.2/bin/macosx-universal-64/sonar.sh start</span><br><span class="line"></span><br><span class="line">localhost:~ tianyi$ /usr/local/sonarqube-6.2/bin/macosx-universal-64/sonar.sh start</span><br><span class="line">Starting SonarQube...</span><br><span class="line">Started SonarQube.</span><br></pre></td></tr></table></figure></li><li><p>创建一个简单的工程</p><p> 默认密码是admin：admin，登陆管理员账号以后，配置系统参数</p><p> 创建一个Demo 工程</p><p> <img src="http://cdn.yuhanle.com/continuous-code-quality-sonarqube-install/make-new1.png" alt="创建一个工程"></p><p> Demo 工程简介</p><p> <img src="http://cdn.yuhanle.com/continuous-code-quality-sonarqube-install/make-demo.png" alt="Demo 工程简介"></p><p> 因为还没有进行过分析，所以Demo 暂时只能配置，在使用篇我们会详细介绍如果通过指令或自动化执行分析审查。</p></li><li><p>安装一些必备插件，都可以从官网或者github 上搜索到</p><p> Sonar支持多种插件，插件的下载地址为：<a href="http://docs.codehaus.org/display/SONAR/Plugin+Library" target="_blank" rel="noopener">http://docs.codehaus.org/display/SONAR/Plugin+Library</a></p><p> 将下载后的插件上传到${SONAR_HOME}extensions\plugins目录下，重新启动sonar。</p></li></ol><h4 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h4><p>（注意版本号兼容性问题）</p><ul><li>SonarQube 汉化包：<a href="https://github.com/SonarQubeCommunity/sonar-l10n-zh" target="_blank" rel="noopener">https://github.com/SonarQubeCommunity/sonar-l10n-zh</a></li><li>Objective-C 代码检查：<a href="https://github.com/octo-technology/sonar-objective-c" target="_blank" rel="noopener">https://github.com/octo-technology/sonar-objective-c</a></li><li>JavaScript 代码检查：<a href="http://docs.codehaus.org/display/SONAR/JavaScript+Plugin" target="_blank" rel="noopener">http://docs.codehaus.org/display/SONAR/JavaScript+Plugin</a></li><li>python 代码检查：<a href="http://docs.codehaus.org/display/SONAR/Python+Plugin" target="_blank" rel="noopener">http://docs.codehaus.org/display/SONAR/Python+Plugin</a></li><li>Web页面检查（HTML、JSP、JSF、Ruby、PHP等）：<a href="http://docs.codehaus.org/display/SONAR/Web+Plugin" target="_blank" rel="noopener">http://docs.codehaus.org/display/SONAR/Web+Plugin</a></li><li>xml文件检查：<a href="http://docs.codehaus.org/display/SONAR/XML+Plugin" target="_blank" rel="noopener">http://docs.codehaus.org/display/SONAR/XML+Plugin</a></li><li>scm源码库统计分析：<a href="http://docs.codehaus.org/display/SONAR/SCM+Stats+Plugin" target="_blank" rel="noopener">http://docs.codehaus.org/display/SONAR/SCM+Stats+Plugin</a></li><li>文件度量：<a href="http://docs.codehaus.org/display/SONAR/Tab+Metrics+Plugin" target="_blank" rel="noopener">http://docs.codehaus.org/display/SONAR/Tab+Metrics+Plugin</a></li><li>中文语言包：<a href="http://docs.codehaus.org/display/SONAR/Chinese+Pack" target="_blank" rel="noopener">http://docs.codehaus.org/display/SONAR/Chinese+Pack</a></li><li>时间表显示度量结果：<a href="http://docs.codehaus.org/display/SONAR/Timeline+Plugin" target="_blank" rel="noopener">http://docs.codehaus.org/display/SONAR/Timeline+Plugin</a></li><li>度量结果演进图：<a href="http://docs.codehaus.org/display/SONAR/Motion+Chart+Plugin" target="_blank" rel="noopener">http://docs.codehaus.org/display/SONAR/Motion+Chart+Plugin</a></li></ul><h4 id="我的资源"><a href="#我的资源" class="headerlink" title="我的资源"></a>我的资源</h4><p><img src="http://cdn.yuhanle.com/continuous-code-quality-sonarqube-install/commonly-used1.png" alt></p><h2 id="使用篇"><a href="#使用篇" class="headerlink" title="使用篇"></a>使用篇</h2><h3 id="使用SonarQube-Runner分析源码"><a href="#使用SonarQube-Runner分析源码" class="headerlink" title="使用SonarQube Runner分析源码"></a>使用SonarQube Runner分析源码</h3><h4 id="预置条件"><a href="#预置条件" class="headerlink" title="预置条件"></a>预置条件</h4><p>已安装SonarQube Runner且环境变量已配置，即sonar-runner命令可在任意目录下执行</p><p>如何配置环境变量，参考<a href="http://www.cnblogs.com/caowei/p/mac-path_2013-08-26.html" target="_blank" rel="noopener">这篇文章</a></p><h4 id="如何分析"><a href="#如何分析" class="headerlink" title="如何分析"></a>如何分析</h4><p><strong>1. 在项目源码的根目录下创建sonar-project.properties配置文件</strong></p><p>以iOS 项目为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Required metadata</span><br><span class="line">sonar.projectKey=iOS::Demo</span><br><span class="line">sonar.projectName=iOS::Demo</span><br><span class="line">sonar.projectVersion=1.0</span><br><span class="line"></span><br><span class="line"># Comma-separated paths to directories with sources (required)</span><br><span class="line">sonar.sources=Demo</span><br><span class="line"></span><br><span class="line"># Language</span><br><span class="line">sonar.language=objectivec</span><br><span class="line"></span><br><span class="line"># Encoding of the source files</span><br><span class="line">sonar.sourceEncoding=UTF-8</span><br></pre></td></tr></table></figure><p><strong>注意：sonar.language 和安装的代码审查插件有关，需要安装 sonar-objective-c 插件，否则运行时会提示无法找到这个语言</strong></p><p><strong>2. 执行分析</strong></p><p>在项目的根目录执行分析指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/sonar-runner-2.4/bin/sonar-runner</span><br></pre></td></tr></table></figure><p><img src="http://cdn.yuhanle.com/continuous-code-quality-sonarqube-install/sonar-ext.png" alt="执行分析指令"></p><p>查看Sonar 分析的结果</p><p><img src="http://cdn.yuhanle.com/continuous-code-quality-sonarqube-install/sonar-ext-result.png" alt="分析结果"></p><p>以上是创建Demo 工程后，通过手动执行分析指令完成代码审查分析。</p><h3 id="与Jenkins-持续集成"><a href="#与Jenkins-持续集成" class="headerlink" title="与Jenkins 持续集成"></a>与Jenkins 持续集成</h3><h4 id="构建前操作"><a href="#构建前操作" class="headerlink" title="构建前操作"></a>构建前操作</h4><p>在jenkins的插件管理中选择安装SonarQube-Scanner，该插件可以使项目每次构建都调用sonar进行代码度量。</p><p>进入配置页面对sonar插件进行配置，如下图：</p><p><img src="http://cdn.yuhanle.com/continuous-code-quality-sonarqube-install/jenkins-goujian.png" alt="新增构建前操作"></p><p>以上配置可以使项目在构建前，自动执行代码审查和分析，结果会自动保存并上传到数据库，通过Sonar 服务器展示给开发者。</p><h4 id="设置触发器"><a href="#设置触发器" class="headerlink" title="设置触发器"></a>设置触发器</h4><p>每5分钟检查一次仓库，若有上库，则自动执行代码检测</p><p><img src="http://cdn.yuhanle.com/continuous-code-quality-sonarqube-install/jenkins-chufa.png" alt="设置触发器"></p><p>至此，通过Sonar 初步构建代码持续审查的工作完成。</p><h2 id="问题篇"><a href="#问题篇" class="headerlink" title="问题篇"></a>问题篇</h2><h3 id="安装中的问题"><a href="#安装中的问题" class="headerlink" title="安装中的问题"></a>安装中的问题</h3><ol><li><p>资源找寻的问题</p><p> 文中提到的资源文件，网上谷歌百度都用上，也找了很久，包括一些插件的问题，必须安装的就是 Sonar-Qube，Runner 其实不必要安装，因为Jenkins 里有插件，可以直接使用。</p></li><li><p>环境配置问题</p><p> 如果不常用指令的话，可以不配置，直接通过绝对路径做操作，环境配置的方法参考<a href="http://www.cnblogs.com/caowei/p/mac-path_2013-08-26.html" target="_blank" rel="noopener">这篇文章</a></p></li><li><p>初始化时遇到Sorry 的问题</p><p> 遇到这种问题可以去根目录 /log/xx.log 中查看日志，具体问题具体解决</p><p> <img src="http://cdn.yuhanle.com/continuous-code-quality-sonarqube-install/qa-3.png" alt="sorry"></p></li><li><p>汉化包的问题</p><p> 如果你不习惯英文的使用，想做一做汉化的事情时，汉化包一定要对，如果有问题会导致服务启动失败。</p><p> 附上：<a href="https://github.com/SonarQubeCommunity/sonar-l10n-zh" target="_blank" rel="noopener">汉化包下载地址</a></p></li></ol><h3 id="SonarQube-实际使用中遇到的问题及解决方案"><a href="#SonarQube-实际使用中遇到的问题及解决方案" class="headerlink" title="SonarQube 实际使用中遇到的问题及解决方案"></a>SonarQube 实际使用中遇到的问题及解决方案</h3><p>在使用 SonarQube6.2 分析代码质量时，可能会遇到的问题：</p><ol><li><p>Xcode 8 兼容性问题</p><p> 原有的xctool已不支持XCode8, 改用xcodebuild + xcpretty 来替代xctool环节生成对应的产出物。</p><p> 关于XCode8的兼容方案, 请看<a href="https://my.oschina.net/ChenTF/blog/806565" target="_blank" rel="noopener">这篇文章</a></p></li></ol><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>代码质量管理对提高项目质量意义重大。本文介绍了 SonarQube 的工作原理，并从项目实战的角度讲解了使用 SonarQube 进行项目代码质量管理的流程和注意事项。</p><p>代码规范贵在坚持与执行力，自动审查只是做了提醒的作用，当然根据语言的规则，很多规范在使用者来讲看似不合理或者不好用，有了这个工具，参与者们可以切身感受到团队的成长。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://my.oschina.net/ChenTF/blog/708646" target="_blank" rel="noopener">[实践]iOS Sonar集成流程详解</a></p><p><a href="https://my.oschina.net/ChenTF/blog/806565" target="_blank" rel="noopener">[实践]Sonar Xcode8兼容</a></p><p><a href="http://www.uml.org.cn/rjzl/201312132.asp" target="_blank" rel="noopener">SonarQube代码质量管理平台安装与使用</a></p><p><a href="http://www.cnblogs.com/gao241/p/3190701.html" target="_blank" rel="noopener">配置sonar、jenkins进行持续审查</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://cdn.yuhanle.com/continuous-code-quality-sonarqube-install/Benefits-of-Using-SonarQube-For-Code-Reviews.jpg&quot; alt=&quot;SonarQube&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;介绍篇&quot;&gt;&lt;a href=&quot;#介绍篇&quot; class=&quot;headerlink&quot; title=&quot;介绍篇&quot;&gt;&lt;/a&gt;介绍篇&lt;/h2&gt;&lt;h3 id=&quot;SonarQube-介绍&quot;&gt;&lt;a href=&quot;#SonarQube-介绍&quot; class=&quot;headerlink&quot; title=&quot;SonarQube 介绍&quot;&gt;&lt;/a&gt;SonarQube 介绍&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.sonarqube.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SonarQube&lt;/a&gt; 是一款领先的持续代码质量监控平台，开源在github 上，现在已更新到6.2 版本，star 数量超过 1400+，可以轻松配置在内网服务器，实时监控代码，帮助了解提升提升团队项目代码质量。通过插件机制，SonarQube可以继承不同的测试工具，代码分析工具，以及持续集成工具。&lt;/p&gt;
    
    </summary>
    
      <category term="continue" scheme="https://blog.yuhanle.com/categories/continue/"/>
    
    
      <category term="iOS" scheme="https://blog.yuhanle.com/tags/iOS/"/>
    
      <category term="Sonar" scheme="https://blog.yuhanle.com/tags/Sonar/"/>
    
      <category term="Quality" scheme="https://blog.yuhanle.com/tags/Quality/"/>
    
  </entry>
  
  <entry>
    <title>见字如面的过去一年</title>
    <link href="https://blog.yuhanle.com/2017/01/22/see-words-as-face/"/>
    <id>https://blog.yuhanle.com/2017/01/22/see-words-as-face/</id>
    <published>2017-01-22T04:29:59.000Z</published>
    <updated>2021-10-21T08:18:48.339Z</updated>
    
    <content type="html"><![CDATA[<p>见字如面，甚是想念。<br><a id="more"></a></p><center><br><img src="http://cdn.yuhanle.com/see-words-as-face/children-1807511_1920.jpg" alt><br></center><p>2016，时间总是如此，过的很快。工作后对于时间的概念只有在白天了，总觉得不够用，上班下班，吃饭睡觉，一如既往的重复重复，就像花钱一样，每一笔微小的开支，累积起来都让人不敢相信。</p><p>跟你在一起的这一年，庸庸碌碌，本该在元旦就跟你告别，没想到一拖就是一个月，从未想过你会走的如此之快，可能是我没太在意，因为你带给我的这是疲惫和不堪，甚至是我至今都不愿接受的未曾改变。</p><p>这个365天，我得到了这些：</p><h2 id="这一年的生活"><a href="#这一年的生活" class="headerlink" title="这一年的生活"></a>这一年的生活</h2><p>在2015 年11月底，女朋友来到了这个我们都很陌生的大都市，接着到了2016 年4月，她开始了正式的工作，小俩口挣得不多，部分房租，部分吃喝，余下的就更少了。</p><p>4月底，我们摆脱了不到20平米的单身公寓，摆脱了隔三差五停电，还得去灌天然气，走很远去买菜的生活，搬到了某小区50+ 平米的一室一厅。没错，房租很贵，足足翻了一倍多，距离我们上班的地方也很远，但这些都不重要，我们都很开心，附近有些朋友，周末可以聚聚，楼下就有菜市场，最总要的是主卧朝南，再也不用宅在冷冰冰的小房间里玩手机了。</p><p>紧接着，5月份最重要的是大学舍友从新疆过来玩，那一天，我们去了七宝，田子坊，在港汇广场吃过饭，夜晚还去了外滩看夜景，回想起来，这是来这个城市以后最好玩的一天。时间比较敢，大家一路上几乎都是跑起来的，为了外滩的夜景，也值。</p><p>接下来的几个月，天气很热，除了周末爬爬山，也就在家待着啃西瓜。</p><p>中秋节假期，我和女友约好去了趟南京，古都南京是个很适合游玩的地方，不仅有很多著名景点，还有很多各色小吃，两天一夜的时间，刚刚好，只是累了些，前同事作为地道的南京人，带我们吃了一遍大排档里的招牌菜，真是流连忘返，因为回去就得马上上班。</p><p>到了10 月，国庆节的假期很长，提前回了趟家，刚好家里的房子装修好，准备搬家呢。前前后后忙活了三四天，接着就一家人带着彩礼，去和女友的家人见面了。说起来也认识近7 年，阻力还好，日久见人心嘛！现在的父母都很开明，我们之间还是比较顺利的，至少彼此还算满意，不会让家里瞎操心。</p><p>国庆节结束后，在郑州见了几个朋友，临走前一直在锅大侠二七店吃了顿火锅，之所以选在这个地方，是因为马上就要坐上火车拜拜了。这顿饭吃起来，大家完全没有好久不见的样子，都在聊着工作，聊着房价，这一年，房价没有骗人，一直在涨。回到上海以后，我就开始着急了，按照我们的家庭条件来讲，首付的问题很大，也是最主要的问题。后来我们还是决定，在房价趋于稳定的11 月份，多次往返两个城市，将此事定了下来。当然还有一件好事，我们领了结婚证，这个意义很大。</p><p>很快，这一年就结束了，17 年元旦，带着女朋友去了趟巴黎春天，买了她向往已久的钻戒，对此毫无概念，30+ 分，虽然没有鹅卵石那么大，但是低调一些，我们都还是很高兴的。在此之前，也订好了17 年3 月份去三亚旅行的事情，顺便拍拍结婚照，准备好了，就该步入婚姻的殿堂了。</p><h2 id="这一年的工作"><a href="#这一年的工作" class="headerlink" title="这一年的工作"></a>这一年的工作</h2><p>原本一个人的项目，15 年底新增了个小伙伴，91 年的研究僧，大家相互学习，工作起来配合也很默契，很满意。</p><p>原有的1.0 版本新增功能，维护了一整年。蓝牙的项目在15 年底就搁置了，三四月份的时候，领导说，可能要继续启动蓝牙的项目，于是我们有加了一个小伙伴，于是3 个男人的小团队就开启了。</p><p>接着就是一个月的蓝牙项目，1.0 版本的更新迭代，内部销售系统的更新迭代，没有深入的学习机会，但是事情多而杂，有做不完的东西。</p><p>很快到了6 月份，1.0 的更新变慢了，更多的时间，我们开始了2.0 的软件研发，相比较而言，2.0 的软件更适合用户，体验提升了不少，但也增大了研发的难度，对技术的要求也高了很多。但是原本计划八九月份发布，没想到到了今天还只是在公测阶段，中间遇到的那些坑，还有需求的变更，简直让人生不如死。</p><p>接着8 月份，一位同事因为个人原因离职了，共事了一年，真的是挺舍不得，公司就像市集，来来往往很多人，谁也不知道回去买谁家的东西。项目仍然如此，同事离职以后，2.0 版本又迎来了大改版，不知道是该高兴还是怎么地，总之，继续改，继续同时维护几个版本，看起来总是那么遥遥无期。</p><p>到了11月份，项目又多了两个，不得不再找一个小伙伴，还好这个行业，资源很多，只是面试起来，找到合适的也挺难，最后要了一个内推的小姑娘，总算是调和了一下我们部门的男女比例，不过年龄惊人，瞬间拉低了公司的平均年龄。</p><p>截止到17 年1 月中旬，2.0 版本终于公测，新增的两个项目也可以拿出来展示，作为研发，不在意评价，有人尊重劳动成果就心满意足。</p><p>以上是这一年的工作，代码没少些，只是多了很多管理经验上的学习和历练。</p><h2 id="这一年的学习"><a href="#这一年的学习" class="headerlink" title="这一年的学习"></a>这一年的学习</h2><p>这块东西很少，因为大部分时间都是在工作嘛~</p><p>中间有一天时间参加了饿了么移动技术分享，在此之前也认识了卓同学，还有冰霜和冬瓜，只见了一次面，本人不善言语，只是听他们聊得多了一些，技术圈的微信群和QQ 群加了不少，每天都能看到有人问有人答，偶尔也会参与讨论。</p><p>具体的项目中，逐渐剥离了各个模块之间的联系，数据库方面也尝试了Realm 和CoreData，做了一些比较和分析，最后选择了后者。</p><p>工作之余也搭建了持续集成平台和远程持续代码审核平台，这些都比较简单，网上的教程看的细致都不会存在什么问题。</p><p>总之，学习的很欠缺。</p><h2 id="下一年的小目标"><a href="#下一年的小目标" class="headerlink" title="下一年的小目标"></a>下一年的小目标</h2><p>健林先生的目标我很欣赏，比如先挣他一个亿。</p><center><br><img src="http://cdn.yuhanle.com/see-words-as-face/lens-1209823_1920.jpg" alt><br></center><ul><li>Swift 一定要玩转，至少要在一个项目中使用Swift 开发</li><li>终身大事要尽早解决</li><li>见更多的朋友</li><li>情商</li></ul><p>2016 年，也并不是毫无收获，应当保持激情，做好每一件事，善待每一个人。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;见字如面，甚是想念。&lt;br&gt;
    
    </summary>
    
      <category term="word" scheme="https://blog.yuhanle.com/categories/word/"/>
    
    
      <category term="see a word" scheme="https://blog.yuhanle.com/tags/see-a-word/"/>
    
  </entry>
  
  <entry>
    <title>如何设计扫一扫功能才能更优雅</title>
    <link href="https://blog.yuhanle.com/2016/12/04/design-scan-function/"/>
    <id>https://blog.yuhanle.com/2016/12/04/design-scan-function/</id>
    <published>2016-12-04T00:00:00.000Z</published>
    <updated>2021-10-21T08:18:48.335Z</updated>
    
    <content type="html"><![CDATA[<p>当前二维码在生活中随处可见，他的功能无需多言，彻底的改变了消费者的使用习惯，提升了用户的操作体验，同时也拉近了人与人，人与物乃至物与物之间的距离<a id="more"></a>。</p><center><br><img src="http://cdn.yuhanle.com/Elegant-design-scan-function/Thematic1.jpg" alt="Thematic"><br></center><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>正如题图，当前二维码在生活中随处可见，他的功能无需多言，彻底的改变了消费者的使用习惯，提升了用户的操作体验，同时也拉近了人与人，人与物乃至物与物之间的距离。</p><p>二维码的使用场景很多，比如添加好友，关注公众号，移动支付，还有很多的某某活动入口，用户无需记住太多信息，拿出手机，轻轻的扫一扫对方的资料就能完成操作；移动支付时代，也是因为这个功能的便捷，才能发展的更普遍，剁起手来也就一瞬间；在商家举办的很多活动中，只需要提供一个二维码图片，再通过朋友圈等社交媒体的疯狂转发，亿万用户都能与商家零距离参与活动，接着二次分享，从而给商家带来蹭蹭蹭的流量。</p><p>然而，以上的种种便捷，都离不开扫一扫这个功能。下面，本人就站在一个刚刚接触此行业的基础上，跟大家聊一聊我脑袋里的扫一扫是如何设计的（如有非议，请艾特我）。</p><h2 id="正正正文"><a href="#正正正文" class="headerlink" title="正正正文"></a>正正正文</h2><h3 id="市场上主导应用是如何做的"><a href="#市场上主导应用是如何做的" class="headerlink" title="市场上主导应用是如何做的"></a>市场上主导应用是如何做的</h3><p>想必接触这个行业的产品和开发人员都了解，无论什么应用，这块的功能应该都是大差不差，条条大路通罗马，但其中的规则，应该都是统一的。</p><p>那我在这里就班门弄斧，顺便体验一下微信的扫一扫功能。</p><center><br><img src="http://cdn.yuhanle.com/Elegant-design-scan-function/wechat_qrcode_meitu_1.png" alt="该二维码图片由微信APP提供" title="该二维码图片由微信APP提供"><br></center><center><br>该二维码图片由微信APP提供<br></center><p><b>1. 先看一下微信扫描结果</b></p><center><br><img src="http://cdn.yuhanle.com/Elegant-design-scan-function/wechat_result_meitu_2.png" alt="该图片由微信APP提供" title="该图片由微信APP提供"><br></center><center><br>该图片由微信APP提供<br></center><p>这里因为是本人的二维码，所以下面显示的操作是<code>发消息</code>，如果是陌生人的二维码，就是<code>添加到通讯录</code>。这里可以知道，扫描这个二维码的操作，就是查看该用户的个人资料。那这个二维码里究竟藏有什么信息？我们可以通过其他工具扫描一下结果。</p><p><b>2. 看一下草料扫描结果</b></p><center><br><img src="http://cdn.yuhanle.com/Elegant-design-scan-function/cli_result.png" alt="该图片由草料二维码提供" title="该图片由草料二维码提供"><br></center><center><br>该图片由草料二维码提供<br></center><p>很显然，这是一个http 的url 链接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://weixin.qq.com/r/35zcxLnE_uSFrf2n98nN</span><br></pre></td></tr></table></figure><p>我们先分析一下这url 的大概参数，下面用一个表格来说明：</p><table><thead><tr><th>参数</th><th style="text-align:center">类型</th><th style="text-align:right">说明</th></tr></thead><tbody><tr><td><a href="http://weixin.qq.com" target="_blank" rel="noopener">http://weixin.qq.com</a></td><td style="text-align:center">String</td><td style="text-align:right">域名</td></tr><tr><td>r</td><td style="text-align:center">String</td><td style="text-align:right">看起来是路由 表示要查看资料</td></tr><tr><td>35zcxLnE_uSFrf2n98nN</td><td style="text-align:center">String</td><td style="text-align:right">看起来是加密后的能标识用户唯一属性</td></tr></tbody></table><p>值得一提的是，这个url 是真实可以访问的，通过电脑打开会直接跳转到官方网站。可能会有很多人（包括我们的QA人员）提出疑问，如此简单的一个扫码查看资料的功能，为什么要做成一个复杂逻辑的url 超链接呢？</p><p><b>3. UC 扫码结果</b></p><center><br><img src="http://cdn.yuhanle.com/Elegant-design-scan-function/uc_result.png" alt="该图片由UC提供" title="该图片由UC提供"><br></center><center><br>该图片由UC提供<br></center><p>以上是UC 浏览器扫码的结果，同样是跳转到微信官网，但是与之不同的是，紧接着直接打开微信APP（如果安装微信的话），否则就跳到应用市场告知用户下载微信APP。那这里就可以很好的解释一下，为什么二维码的扫描结果使用url 超链接，因为这样可以更好体验的引导用户，从而提升自身产品的流量，也就是说不管你通过何种方式，什么应用扫码，对于用户来讲，你可以很快速很直观的了解到你扫描的东西是什么，不再是二维码实际意义上的一段字符，从产品的角度来说，也能够保证这块的用户流量流失减少，操作体验上也有很大的提升。</p><h3 id="我们的应用该如何设计"><a href="#我们的应用该如何设计" class="headerlink" title="我们的应用该如何设计"></a>我们的应用该如何设计</h3><p>那这个，跟产品本身的需求有很大关系，但是开发的思路和逻辑都是统一的，类似微信这种超级APP，有各种牛人集思广益，项目中应该是会各种组件化，模块化的设计，拿一个简单的扫一扫功能来说，作为一个模块，在他的功能以及和其他模块之间的耦合性来说，肯定是值得我们借鉴和学些的，当然我没有找到任何相关资料，下面只能按照近期的项目来聊聊我是如何处理的。</p><p><b>1. 二维码扫描的结果必定是一个可以访问的超链接</b></p><p>这个应该是没人反驳的。</p><p>之所以这么定义，有两点优势。第一，用户体验和导流上，可以做到更好，具体上面的分析中也提到，就不再赘述；第二，在研发上，通过超链接，可以很方便的将功能集成到我们的路由模块，当然这里也有其他的方法，不过也同样是为了处理扫码结果来定义的。</p><center><br><img src="http://cdn.yuhanle.com/Elegant-design-scan-function/router.001.png" alt="路由模块的耦合设计" title="路由模块的耦合设计"><br><br></center><center><br>路由模块的耦合设计<br></center><p>上图中，扫一扫功能通过超链接的形式，可以直接整合到路由模块中，<b>通过scheme 的方式，先将域名 替换成 自定义的scheme，如果路由模块可以处理就丢过去处理，不能处理的情况下，就通过APP 内部的浏览器打开该链接，其他逻辑的操作就丢给web 页面处理，比如引导用户到官网，提醒用户下载应用</b>，等一些错误的处理。</p><p><b>2.为了更好地兼容扫码功能，做一些优化 </b></p><center><br><img src="http://cdn.yuhanle.com/Elegant-design-scan-function/router.002.png" alt="路由模块的扫码功能优化" title="路由模块的扫码功能优化"><br></center><center>路由模块的扫码功能优化</center><p>这里，我们把一些通用的处理操作，通过类别或者代理协议的方法，按功能分别添加到路由模块中，这种优化不仅优化了扫一扫的功能，也同时优化了其他各模块使用路由模块的逻辑。</p><h3 id="那我们可以开始着手研发了"><a href="#那我们可以开始着手研发了" class="headerlink" title="那我们可以开始着手研发了"></a>那我们可以开始着手研发了</h3><h4 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h4><p>Web或其他应用调用XXX应用特定功能，也可以用于应用内部功能跳转</p><h4 id="支持系统"><a href="#支持系统" class="headerlink" title="支持系统"></a>支持系统</h4><p>iOS，Android，H5</p><p>如有因系统特性导致的不一致，在协议中详细列出</p><h4 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h4><h5 id="Web端"><a href="#Web端" class="headerlink" title="Web端"></a>Web端</h5><p><a href="http://appwebv2.xxx.cn/" target="_blank" rel="noopener">http://appwebv2.xxx.cn/</a><action>/?parms (开发测试环境为appwebv2test.xxx.cn)</action></p><h5 id="App端"><a href="#App端" class="headerlink" title="App端"></a>App端</h5><p>xxxapp://<action>/?params</action></p><p>Web 调用端需要先判断XXX应用是否已经安装<br>如已安装，则通过xxxapp://调用<br>如未安装，视实际定义及功能，通过web调用或者提示用户下载应用</p><p>App 端需要先通过xxxapp:// 路由</p><p>如果本地已经注册，继续执行</p><p>没有注册，直接通过应用内浏览器打开 Web 页面（需要匹配模板填充必要参数）</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><a href="http://appwebv2.xxx.cn/action/bind/bike/{bikeid}/" target="_blank" rel="noopener">http://appwebv2.xxx.cn/action/bind/bike/{bikeid}/</a>?<font color="red">appversion={version}&amp;platform={platform}&amp;xxxkey={xxxkey}</font></p><p>链接前半部分，由服务器生成，后面红色部分参数需要客户端在不能正常通过路由打开该功能，调用浏览器时拼接在 url 里。</p><p>后面红色部分参数，根据服务器的模板链接匹配填充，然后生成二维码展示。</p><h5 id="必要参数"><a href="#必要参数" class="headerlink" title="必要参数"></a>必要参数</h5><table><thead><tr><th>参数</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>action/</td><td>Router</td><td>此路由是action 表示该链接是要实现某功能</td></tr><tr><td>bind</td><td>String</td><td>表示绑定的操作</td></tr><tr><td>bike</td><td>String</td><td>表示要绑定的是车</td></tr><tr><td>bikeid</td><td>String</td><td>需要处理的参数</td></tr></tbody></table><h3 id="功能已经实现"><a href="#功能已经实现" class="headerlink" title="功能已经实现"></a>功能已经实现</h3><p>按照上面的定义和逻辑，扫一扫的功能已经可以据此定义砌砖实现。对于路由的功能，可以本地实现，也可以像蘑菇街那样，通过后台的配置可以随时更改处理操作。</p><p>于是，web 端准备了一个页面，超链接是 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://appwebv2.xxx.cn/action/bind/bike</span><br></pre></td></tr></table></figure><p>生成二维码之前，服务端给了你一个字符串，内容是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://appwebv2.xxx.cn/action/bind/bike/11234/?appversion=&#123;version&#125;&amp;platform=&#123;platform&#125;&amp;xxxkey=&#123;xxxkey&#125;</span><br></pre></td></tr></table></figure><p>客户端根据字符串，通过匹配和填充，生成一个二维码</p><center><br><img src="http://cdn.yuhanle.com/Elegant-design-scan-function/qr_result.png" alt="生成二维码" title="生成二维码"><br></center><center>生成二维码</center><p>二维码的实际结果就是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://appwebv2.xxx.cn/action/bind/bike/11234/?appversion=V1.0&amp;platform=iOS&amp;xxxkey=3a10362d077cd27b5f2c537e1ff2fc48</span><br></pre></td></tr></table></figure><p>至此，通过XXX 应用扫码，就会调用添加车辆的功能。<br>通过第三方APP 扫码的话，会先打开浏览器，web 页面会再通过系统方法先尝试调用XXX 应用，如果不能调起，就提醒用户去商店下载，如果能调起应用，XXX 应用在启动以后，通过路由模块处理，首先跳转到扫一扫界面，然后调用添加车辆的功能，如果路由无法处理这个http 超链接，就会调用浏览器再加载这个web 页面。</p><p>到这里，我脑海里能想到的基本分析完了，如果有更好的想法或建议，请艾特我~ 新浪微博：<a href="http://weibo.com/2621837475/profile?topnav=1&amp;wvr=6&amp;is_all=1" target="_blank" rel="noopener">煜寒了</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当前二维码在生活中随处可见，他的功能无需多言，彻底的改变了消费者的使用习惯，提升了用户的操作体验，同时也拉近了人与人，人与物乃至物与物之间的距离
    
    </summary>
    
      <category term="mobile" scheme="https://blog.yuhanle.com/categories/mobile/"/>
    
    
      <category term="scan" scheme="https://blog.yuhanle.com/tags/scan/"/>
    
  </entry>
  
  <entry>
    <title>ObjC&amp;JavaScript 交互，在恰当的时机注入对象</title>
    <link href="https://blog.yuhanle.com/2016/11/30/oc-js-inpourjs-in-goodtime/"/>
    <id>https://blog.yuhanle.com/2016/11/30/oc-js-inpourjs-in-goodtime/</id>
    <published>2016-11-30T00:00:00.000Z</published>
    <updated>2021-10-21T08:18:48.338Z</updated>
    
    <content type="html"><![CDATA[<p>警告：文章中提到的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(id)unuse didCreateJavaScriptContext:(JSContext *)ctx forFrame:(id)frame;</span><br></pre></td></tr></table></figure><p>方法涉及私有API，有网友反馈说审核会被拒绝，希望看到的朋友们慎用</p><p>移动端项目开发中，免不了出现 Native App （以下简称Native）和 H5 页面（以下简称H5）的交互，网络上有很多第三方框架，比如<a href="https://github.com/marcuswestin/WebViewJavascriptBridge" target="_blank" rel="noopener">WebViewJavascriptBridge</a>，对于一些小的项目需求来说，其实不用那么麻烦，我们还是先从基础着手。<a id="more"></a></p><p><img src="http://cdn.yuhanle.com/inpurejs-in-goodtime/16.jpg" alt="图文无关"></p><h2 id="先了解几个基础方法"><a href="#先了解几个基础方法" class="headerlink" title="先了解几个基础方法"></a>先了解几个基础方法</h2><ul><li>网页即将加载（最先执行的代理方法），在每次load 页面的时候都会先走这个回调，可以在此做一些自己的操作，经常会在这儿拦截协议</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType &#123; </span><br><span class="line">    // do something...</span><br><span class="line">    </span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>网页已经加载完成（最后执行的代理方法），执行到这个地方，web 页面已经加载完成，相关代码也都执行完毕</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)webViewDidFinishLoad:(UIWebView *)webView &#123;</span><br><span class="line">    // 加载完成 隐藏HUD</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="根据不同的场景，找一个最合适的方法"><a href="#根据不同的场景，找一个最合适的方法" class="headerlink" title="根据不同的场景，找一个最合适的方法"></a>根据不同的场景，找一个最合适的方法</h2><h3 id="场景1"><a href="#场景1" class="headerlink" title="场景1"></a>场景1</h3><blockquote><p>（H5 通信 Native，告知Native 要做的事儿）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">H5 页面在某个标签点击后，要关闭当前加载网页的控制器VC</span><br></pre></td></tr></table></figure><p>需求分析：</p><blockquote><p>这应该不是最简单的一个需求，最简单的是Native 通过url 给H5 页面传参数，告知H5 要做的事儿。</p><p>这个需求中，H5 页面已经加载完毕，此时可以说H5 页面相关的Bug 和UI 缺陷都与Native 无关，我每次都是这么跟测试人员讲，类似问题直接assign 给他们。</p></blockquote><p>功能实现：</p><blockquote><p>对于这类比较简单的需求，最常用的做法就是，通过拦截协议的方法，在点击标签的时候，可以调用自定义协议的超链接，比如定义一个 <code>yuhanle://action/close</code>的链接，在页面即将load 的时候，判断url 的协议，如果协议是 <code>yuhanle</code>，就拦截掉这个请求，做自己的处理。</p></blockquote><p>图解：</p><p><img src="http://cdn.yuhanle.com/inpurejs-in-goodtime/brokenrule.001.png" alt></p><h3 id="场景2"><a href="#场景2" class="headerlink" title="场景2"></a>场景2</h3><blockquote><p>（H5 调用 Native App 的JS 方法，包括同步和异步操作）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">H5 页面在加载过程中，需要从Native 中取得部分数据，或调用某个功能，均包含同步</span><br><span class="line">操作或异步操作，比如只是简单的获取token，则直接同步返回，如果需要Native 异</span><br><span class="line">步拿到结果，Native 则需要考虑 JSExport 中的线程问题</span><br></pre></td></tr></table></figure><p>需求分析：</p><blockquote><p>这个需求中肯定需要Native 注入JS 方法，H5 通过调用JS 和Native 通信，其中包括同步和异步两种情况下的处理，需要注意的就是异步操作时，H5 需要在调用 App 时传入一个 JS 方法名，App 在拿到数据后可以回调 H5 的JS 方法，在调用这个回调的时候，需要使用webView 的currentThread，不然就会出现页面卡死。</p></blockquote><p>功能实现：</p><blockquote><p>1- 定义一个类，用于注入这个对象</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 此模型用于注入JS的模型，这样就可以通过模型来调用方法。</span><br><span class="line">@interface QWSJsObjCModel : NSObject &lt;JavaScriptObjectiveCDelegate&gt;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, weak) JSContext *jsContext;</span><br><span class="line">@property (nonatomic, weak) UIWebView *webView;</span><br><span class="line">@property (nonatomic, weak) G100WebViewController * webVc;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><blockquote><p>2- 声明协议，实现和JS 对应的方法</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;JavaScriptCore/JavaScriptCore.h&gt;</span><br><span class="line"></span><br><span class="line">@protocol JavaScriptObjectiveCDelegate &lt;JSExport&gt;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  获取客户端的token</span><br><span class="line"> *</span><br><span class="line"> *  @param qwsKey 客户端生成的密码key</span><br><span class="line"> *</span><br><span class="line"> *  @return 返回值token</span><br><span class="line"> */</span><br><span class="line">- (NSString *)getToken:(NSString *)qwsKey;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  H5 传递key 获取newToken 在调用其 callback 方法</span><br><span class="line"> *</span><br><span class="line"> *  @param key      qwskey</span><br><span class="line"> *  @param callback 回调方法名</span><br><span class="line"> *  @param property 方法参数</span><br><span class="line"> */</span><br><span class="line">- (void)getNewToken:(NSString *)key callback:(NSString *)callback property:(NSString *)property;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  H5 在加载完成后 告诉客户端在返回的时候调用该方法</span><br><span class="line"> *</span><br><span class="line"> *  @param callback js 方法名</span><br><span class="line"> */</span><br><span class="line">- (void)getExitMsgCallback:(NSString *)callback;</span><br></pre></td></tr></table></figure><blockquote><p>3- 我们需要在打开webView 的时候，找到一个好的时机注入 JS</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 首先拿到JSContext</span><br><span class="line">self.jsContext = [_jsWebView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;];</span><br><span class="line">   // 通过模型调用方法，这种方式更好些。</span><br><span class="line">   QWSJsObjCModel *model  = [[QWSJsObjCModel alloc] init];</span><br><span class="line">   self.jsContext[@&quot;nativeObj&quot;] = model;</span><br><span class="line">   model.jsContext = self.jsContext;</span><br><span class="line">   model.webView = _jsWebView;</span><br><span class="line">   </span><br><span class="line">   self.jsContext[@&quot;getUserinfo&quot;] = ^()&#123;</span><br><span class="line">       return @&quot;1234&quot;;</span><br><span class="line">   &#125;;</span><br><span class="line">   </span><br><span class="line">   self.jsContext.exceptionHandler = ^(JSContext *context, JSValue *exceptionValue) &#123;</span><br><span class="line">       context.exception = exceptionValue;</span><br><span class="line">       NSLog(@&quot;异常信息：%@&quot;, exceptionValue);</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure><blockquote><p>4- 对应H5 页面的JS 定义及调用</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;测试IOS与JS之前的互调&lt;/title&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">  * &#123;</span><br><span class="line">  font-size: 40px;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">  var jsFunc = function() &#123;</span><br><span class="line">    alert(&apos;Objective-C call js to show alert&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  var jsParamFunc = function(argument) &#123;</span><br><span class="line">    document.getElementById(&apos;jsParamFuncSpan&apos;).innerHTML</span><br><span class="line">    = argument[&apos;name&apos;];</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">  </span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  </span><br><span class="line">&lt;div style=&quot;margin-top: 100px&quot;&gt;</span><br><span class="line">&lt;h1&gt;Test how to use objective-c call js&lt;/h1&gt;</span><br><span class="line">&lt;input type=&quot;button&quot; value=&quot;getToken&quot; onclick=&quot;alert(nativeObj.getToken())&quot;&gt;</span><br><span class="line">&lt;input type=&quot;button&quot; value=&quot;Call ObjC system alert&quot; onclick=&quot;nativeObj.showAlertMsg(&apos;js title&apos;, &apos;js message&apos;)&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;input type=&quot;button&quot; value=&quot;Call ObjC func with JSON &quot; onclick=&quot;nativeObj.callWithDict(&#123;&apos;name&apos;: &apos;testname&apos;, &apos;age&apos;: 10, &apos;height&apos;: 170&#125;)&quot;&gt;</span><br><span class="line">&lt;input type=&quot;button&quot; value=&quot;Call ObjC func with JSON and ObjC call js func to pass args.&quot; onclick=&quot;nativeObj.jsCallObjcAndObjcCallJsWithDict(&#123;&apos;name&apos;: &apos;testname&apos;, &apos;age&apos;: 10, &apos;height&apos;: 170&#125;)&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;a href=&quot;test1.html&quot;&gt;Click to next page&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;span id=&quot;jsParamFuncSpan&quot; style=&quot;color: red; font-size: 50px;&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>按照以上的做法，就能达到Native 和H5 之间的相互通信，现在的问题是，在什么时候注入JS 对象，才能满足H5 页面的需求，因为实际情况中，H5 页面可能会随时调用你的JS。</p><h3 id="需要注意的几个问题"><a href="#需要注意的几个问题" class="headerlink" title="需要注意的几个问题"></a>需要注意的几个问题</h3><p>1- 场景2 中我们提到的，异步调用时的线程问题 首先看下下面的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (void)getNewToken:(NSString *)key callback:(NSString *)callback property:(NSString *)property &#123;</span><br><span class="line">    if (_webVc) &#123;</span><br><span class="line">        if ([_webVc.qwsKey isEqualToString:key]) &#123;</span><br><span class="line">            </span><br><span class="line">            __block NSString * newToken = @&quot;&quot;;</span><br><span class="line">            __block NSInteger result = 0;</span><br><span class="line">            </span><br><span class="line">            [[UserManager shareManager] autoLoginWithComplete:^(NSInteger statusCode, ApiResponse *response, BOOL requestSuccess) &#123;</span><br><span class="line">                if (requestSuccess) &#123;</span><br><span class="line">                    newToken = [[G100InfoHelper shareInstance] token];</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    newToken = @&quot;error&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                result = requestSuccess ? response.errCode : statusCode;</span><br><span class="line">                </span><br><span class="line">                JSValue * function = self.jsContext[callback];</span><br><span class="line">                NSArray * params = @[@(result), newToken, property];</span><br><span class="line">                [function callWithArguments:params];</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码，就是想在H5 页面调用的时候，App 这边自动登陆，重新获取到最新的token，拿到结果以后并回调H5，整个过程上是异步的，看起来是没问题的，但是一旦实际操作起来，会在这里卡死。具体原因，我也不好解释，解决办法是有的，只能通过webView 的currentThread 来执行perform 操作。</p><p>示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">- (void)getNewToken:(NSString *)key callback:(NSString *)callback property:(NSString *)property &#123;</span><br><span class="line">    if (_webVc) &#123;</span><br><span class="line">        if ([_webVc.qwsKey isEqualToString:key]) &#123;</span><br><span class="line">            </span><br><span class="line">            __block NSString * newToken = @&quot;&quot;;</span><br><span class="line">            __block NSInteger result = 0;</span><br><span class="line">            NSThread * webThread = [NSThread currentThread];</span><br><span class="line">            </span><br><span class="line">            [[UserManager shareManager] autoLoginWithComplete:^(NSInteger statusCode, ApiResponse *response, BOOL requestSuccess) &#123;</span><br><span class="line">                if (requestSuccess) &#123;</span><br><span class="line">                    newToken = [[G100InfoHelper shareInstance] token];</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    newToken = @&quot;error&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                result = requestSuccess ? response.errCode : statusCode;</span><br><span class="line">                // 这里通过此方法 在当前线程操作才不会造成卡死的现象</span><br><span class="line">                [self performSelector:@selector(callQWSJSWithArgument:) onThread:webThread withObject:@[callback, @(result), newToken, property] waitUntilDone:NO];</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)callQWSJSWithArgument:(NSArray *)argument &#123;</span><br><span class="line">    NSString * callback = argument[0];</span><br><span class="line">    JSValue * function = self.jsContext[callback];</span><br><span class="line">    </span><br><span class="line">    NSMutableArray * params = [NSMutableArray arrayWithArray:argument];</span><br><span class="line">    // 移除第一个 方法名</span><br><span class="line">    [params removeObjectAtIndex:0];</span><br><span class="line">    [function callWithArguments:params];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2- 同样是场景2 中的一个问题，什么时候注入对象</p><p>需求总是虚无缥缈的，对于H5 结合 Native 的开发结构中，Native 始终扮演着服务和入口的角色，H5 可能随时都会主动和Native 通信，但是Native 应该在什么时候准备好这些服务呢？</p><p>看了很多网上的资料，几乎全部都是在页面加载完成 webViewDidFinishLoad 这个回调中注入方法，但实际开发中，很多页面在加载的时候就需要和Native 通信，比如说拿到token，如果在这个时候才注入，肯定是来不及的，只能无功而返。</p><p>相信大多数人都没太在意这个问题，当然，如果强制让H5 的开发人员修改逻辑，将所有的通信都放在页面加载完成以后在做，也没问题，只不过对于用户的体验会变得糟糕。</p><p>深入研究官方文档，就会发现，webView 在加载过程中，会执行这么一个方法，他的作用是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_:didCreateJavaScriptContext:for:</span><br><span class="line"></span><br><span class="line">Notifies the delegate that a new JavaScript context has been created created.</span><br></pre></td></tr></table></figure><p><img src="http://cdn.yuhanle.com/inpurejs-in-goodtime/webView_didCreateJavaScriptContext.png" alt></p><p>具体参见官方文档说明 <a href="https://developer.apple.com/reference/webkit/webframeloaddelegate/1501462-webview?language=objc" target="_blank" rel="noopener">didCreateJavaScriptContext</a></p><p>看到这里，我们就能在收到这个消息的时候，拿到JSContext，然后注入我们的Model。</p><p>首先，新建一个NSObject 的Catagory，在这个代理方法中发送一个通知</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@implementation NSObject (JSTest)</span><br><span class="line"></span><br><span class="line">- (void)webView:(id)unuse didCreateJavaScriptContext:(JSContext *)ctx forFrame:(id)frame &#123;</span><br><span class="line">    [[NSNotificationCenter defaultCenter] postNotificationName:@&quot;DidCreateContextNotification&quot; object:ctx];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>然后，在webView 的控制器中监听这个消息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    // 监听可以注入js 方法的通知</span><br><span class="line">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(didCreateJSContext:) name:@&quot;DidCreateContextNotification&quot; object:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现@selector 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 可以注入js 的监听</span><br><span class="line">- (void)didCreateJSContext:(NSNotification *)notification &#123;</span><br><span class="line">    NSString *indentifier = [NSString stringWithFormat:@&quot;indentifier%lud&quot;, (unsigned long)self.webView.hash];</span><br><span class="line">    NSString *indentifierJS = [NSString stringWithFormat:@&quot;var %@ = &apos;%@&apos;&quot;, indentifier, indentifier];</span><br><span class="line">    [self.webView stringByEvaluatingJavaScriptFromString:indentifierJS];</span><br><span class="line">    </span><br><span class="line">    JSContext *context = notification.object;</span><br><span class="line">    </span><br><span class="line">    if (![context[indentifier].toString isEqualToString:indentifier]) return;</span><br><span class="line">    </span><br><span class="line">    self.jsContext = context;</span><br><span class="line">    // 通过模型调用方法，这种方式更好些。</span><br><span class="line">    QWSJsObjCModel *model  = [[QWSJsObjCModel alloc] init];</span><br><span class="line">    self.jsContext[@&quot;nativeObj&quot;] = model;</span><br><span class="line">    model.jsContext = self.jsContext;</span><br><span class="line">    model.webView   = self.webView;</span><br><span class="line">    model.webVc     = self;</span><br><span class="line">    </span><br><span class="line">    self.jsContext.exceptionHandler = ^(JSContext *context, JSValue *exceptionValue) &#123;</span><br><span class="line">        context.exception = exceptionValue;</span><br><span class="line">        DLog(@&quot;异常信息：%@&quot;, exceptionValue);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此，应该是一次比较完美的注入了~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;警告：文章中提到的&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)webView:(id)unuse didCreateJavaScriptContext:(JSContext *)ctx forFrame:(id)frame;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;方法涉及私有API，有网友反馈说审核会被拒绝，希望看到的朋友们慎用&lt;/p&gt;
&lt;p&gt;移动端项目开发中，免不了出现 Native App （以下简称Native）和 H5 页面（以下简称H5）的交互，网络上有很多第三方框架，比如&lt;a href=&quot;https://github.com/marcuswestin/WebViewJavascriptBridge&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;WebViewJavascriptBridge&lt;/a&gt;，对于一些小的项目需求来说，其实不用那么麻烦，我们还是先从基础着手。
    
    </summary>
    
      <category term="iOS" scheme="https://blog.yuhanle.com/categories/iOS/"/>
    
    
      <category term="tips" scheme="https://blog.yuhanle.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>无言逝水 回忆无声</title>
    <link href="https://blog.yuhanle.com/2016/08/21/passing-silent-silent-memories/"/>
    <id>https://blog.yuhanle.com/2016/08/21/passing-silent-silent-memories/</id>
    <published>2016-08-21T05:23:00.000Z</published>
    <updated>2021-10-21T08:18:48.338Z</updated>
    
    <content type="html"><![CDATA[<p>水的存在，延续了人的生命，却难以洗涤人的回忆。</p><p>在我们山里，每一个小的村落，某棵树荫下，就会有一口井，那是山泉。村西头的山脚下，那里地势稍高，有一条田间小路，来来往往的人们挑着木桶，路上湿漉漉的，仿佛刚下过雨，记忆全都小心翼翼的在这条路上穿梭，生怕碰到路人。</p><a id="more"></a><p><img src="http://cdn.yuhanle.com/passing-silent-silent-memories/626c7bb4022404ceab0bc29676963198df77461598b83-jE6pBi_fw658.jpeg" alt="无言逝水"></p><p>哑巴今天已经是第三趟了，这担水挑完，他就能带小伙伴儿们去山上摘茶果，每年清明前后，山里的吃货很多，但由于村里的老人渐渐离去，年轻人都很少去打柴，上山的路也没了踪迹，据说山上有野兽，所有家里人都不允许我们上山玩。</p><p>哑巴是我们对他的称呼，虽然大我们二十多岁，但是家里人从来没有教过我如何称呼他，他天生不会讲话，身体特别瘦小，也许正因如此，人们才不愿意去记住这个人吧！</p><p>从我记事儿开始，每天早上六点多钟，他都要从我家门前路过，挑着两个木桶，虽然不会说话，但是嘴里还哼唧哼唧着，晃晃悠悠的踏上那条去往水井的小路，不一会儿就带着满满两桶水回来了，母亲有时候正在做早饭，看见哑巴路过，就拿着水瓢去了。哑巴会生气，因为这种情况已经不是第一次了，村里人都喜欢这样欺负他，也许他这样生气，被村里人觉得不满，告诉了他的母亲。</p><p><img src="http://cdn.yuhanle.com/passing-silent-silent-memories/2730025799117722348.jpg" alt="扁担"></p><p>印象最深的一次，我被他打了一顿。</p><p>我和他的小侄儿一块玩，小孩子间疯疯闹闹的，不小心把他侄儿推到了，刚好被哑巴看见了，上来一巴掌就把我扇到地上，从来没有这样害怕过，这还是我认识的哑巴吗？他虽然很瘦，但力气很大，村里不少年轻人都和他打过，当然大多数是咋欺负他，这次我被打了，家里人肯定不愿意，还好没什么情况，又是乡里乡亲的，就没有下文了。</p><p>从那以后，我每次见他都要绕道走，因为害怕，我不知道这样自闭的爆发起来会是什么样的结果，村里的小孩儿，除了那特别爱护的那个小侄儿，都不再跟着哑巴玩。</p><p>过了几年，村里人开始厌倦挑水吃，就开始挨家挨户凑点儿钱，买了些水管，一头插进井里，贯穿村里十几户人家，这样大家就都能喝到自来水了。当水经过地下，从龙头里出来的时候，很清很甜，老人们都在感叹，几十年挑水吃的日子终于熬到头，同时那些旧的场景，都不会再出现。</p><p>哑巴的日子轻松了，不用再那么早起挑水来养一家人，但是他还是很早就起来了，村东头儿到村西头儿的瞎晃悠，嘴里哼着我们听不懂的调调，偶尔停留在我家门前的石板上，也很乐意跟村里早起的老人聊聊天，当然他不会说话，就是嘴里哼哼唧唧，手不停的在打手势，奇怪的是大家还能看懂大部分，不得不说哑巴很聪明，在与人交流上。</p><p><img src="http://cdn.yuhanle.com/passing-silent-silent-memories/p8033717.jpg" alt="闲聊"></p><p>他喜欢抽烟，也喜欢喝酒，当然这些都是在帮别人家干活人家付给他的“工钱”，不过干活的时候，大家可不敢让他喝酒，因为他一喝就停不下来，喝多了就一直笑，眼里还流着很多水，时不时的还哼些调调，然后活肯定是干不了了，所以一般都是在干完活，才把过节剩下的瓶底儿给他喝，他不嫌弃，而且还很高兴，很感激，烟给多了他也不要，一般小事情的话他只会接一根烟，忙了一天才会拿一盒两块钱的散花。</p><p>正因如此，大家家里有什么活都喜欢找他做，但是很多人都是偷偷的把他叫过来干活儿，不给工钱，仅仅是一些烟和酒，有时候他的母亲在村里找他都找不见，因为是被隔壁庄上的人叫去和水泥了，按照一般人的工钱一天至少也得有60块钱，但是对于他，如果雇主没有告知他的母亲的话，他自己都不清楚是在给谁干，也不要钱，就算告诉了他的母亲，一天顶多才有20几块钱的收入，当然对于他自己来说，这些钱足够他生活了，但是他还是个孝顺的孩子，钱都是父母收着，自己的衣服大多都是旧的，吃住都在家里。在老家，除了会有人欺负他，看起来他还是很满足的，可能他觉得这是一种与人沟通的方式吧，就是一直这么吃亏，才会有人找你做活儿。</p><p>往后好些年，我一直在外上学，就很少见到这位无言者了。直到有一天，家里打电话，让我在外面注意安全，别被骗了，我当时听了还很纳闷，作为一个在外生活多年的人而言，我还是见过些世面的，对于诈骗，不管不问不理会，就不会有危险。我继续追问才知道，原来是有位老乡，说是要给这位无言者讨个老婆，此时他已经四十多岁了，这么多年他父母也帮他攒了一两万块钱，父母听说是有人帮儿子讨老婆很高兴，又是熟人当中间人介绍，所以就毫无防备的被人骗了，从这以后，回家看到他感觉老了很多，没再见他笑过，仿佛对外界充满了敌意。</p><p>这么多年来，村子里的人慢慢都搬走了，村里的地也开始荒废了，有钱的在北京买了房，差不多的都在市里县里买的，最差的也都搬到镇上了，外面花花世界，交通方便，收入也多了，总之都算过上了小康生活。</p><p>这位无言者至今还村里，听说近几年有人给他介绍了一个新的工作，帮别人喂养扁嘴（学名鸭子），包吃包住，每年还有6000块钱的收入，年底结算，日子也算不错！</p><p>至今我也有三四年没有见到他了，不知道为什么，总觉得对于他有一些亏欠。我的童年是跟着他长大的，他带着我们掏鸟蛋，摘茶果，春茶季节还能带着我们去采茶卖钱，然后买一毛钱一根的棒冰，夏季太热，还会带着我们去河里网鱼，捉虾，放牛的时候还会把我们抱到牛背上，吹着树笛（乡下的玩意儿：就是柳树枝儿，地上搓一搓，把皮和干分离开），在和其他庄上的孩子冲突的时候，还能挺身而出为我们强出头。</p><p><img src="http://cdn.yuhanle.com/passing-silent-silent-memories/001puwxIgy6UR0N2dhga2&amp;690.jpeg" alt="白鹭骑牛"></p><p>这些细节，都很感激。</p><p>再说说如今，一线城市，工作近三年，每年回两次家，还都特别匆忙，朋友都没敢见，服么都来不及道别，就麻溜儿的滚回来上班了，说起工作，对于一个没有伟大志向的人来说，还算稳定，收入也能养活自己，但我们俩人每天发愁的都还是钱，什么时候买房，什么时候结婚，什么时候要孩子，每每聊到这儿，都是一声哀叹，然后就开始失眠，每逢周末如此。</p><p><img src="http://cdn.yuhanle.com/passing-silent-silent-memories/2013040213393813629.jpg" alt="上海外滩"></p><p>无言逝水，朋友间的关怀，一定要珍惜，如今的朋友圈，看起来很高大上，不是在炫耀就是发一些鸡汤，看多了人的智商会下降，身边处处都是低头族，方寸之间，世间万物，逝去的其实不是水，是光阴。</p><p>多年以后，你所能想起的会是某个好朋友曾经发过的一个状态？还是他曾经对你的帮助，对你的鼓励和关怀。而你呢？你给朋友留下的又是什么，是令你发愤图强的鸡汤？也许别人看着并没有任何感觉，却又不得不帮你点个赞，不点赞不是朋友等等，还是你刚买的肾6肾7呢？点赞的不是朋友，骂你傻X的才是真心的。</p><p>我也曾关闭过朋友圈，如今又打开了，因为我的智商负数，我只想让朋友知道我还活着。</p><p>愿世间多一些真诚，少一些套路，莫在浪费光阴，以致回忆无声。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;水的存在，延续了人的生命，却难以洗涤人的回忆。&lt;/p&gt;
&lt;p&gt;在我们山里，每一个小的村落，某棵树荫下，就会有一口井，那是山泉。村西头的山脚下，那里地势稍高，有一条田间小路，来来往往的人们挑着木桶，路上湿漉漉的，仿佛刚下过雨，记忆全都小心翼翼的在这条路上穿梭，生怕碰到路人。&lt;/p&gt;
    
    </summary>
    
      <category term="prose" scheme="https://blog.yuhanle.com/categories/prose/"/>
    
    
      <category term="prose" scheme="https://blog.yuhanle.com/tags/prose/"/>
    
  </entry>
  
  <entry>
    <title>我知道的太多</title>
    <link href="https://blog.yuhanle.com/2016/05/20/i-know-more-more/"/>
    <id>https://blog.yuhanle.com/2016/05/20/i-know-more-more/</id>
    <published>2016-05-20T01:00:00.000Z</published>
    <updated>2021-10-21T08:18:48.337Z</updated>
    
    <content type="html"><![CDATA[<p>正因为我们知道的太多，所以才会觉得压抑</p><p>许久没有写东西，有时候在想，思维会不会已经枯竭，除了简单的因为所以，完全忘了押韵。</p><a id="more"></a><p>记得开始想着写这篇是在去年了，原本打算写成年终总结，后来发现这一年过去了，除了胡须在长，体重在增加，别的没有什么变化。</p><p>有时候走在路上，想起以前经常背的那些宋词来，全都成了零星的句子，上下阙混在一起，甚至混合了不同的词牌，不同的作者，结果却出乎意料的押韵。</p><p>我知道，是工作和生活扰乱了我。</p><p>我很害怕身边的事情太多，因为我是一个很小心的人，而且很不会同时处理多个任务，会不知所措，当然处理的结果也是一团糟。</p><p>很多时候，总是会在用到某些的时候拼命去查找，找到了仅仅是用了一下，没有归类，如此往复，明明知道没有效率，却依然已经习惯了。</p><p>这是个不好的习惯。甚至我都决定过要去改掉它，我试着开始做笔记，开始收藏一些比较感兴趣的东西，后来慢慢发现，吸引我的东西太多太多，整理的笔记已经不知道该属于哪一类了，又出现了很多很多模棱两可的东西，彼此包含，实在是很难把它在我的记忆里分离开来。</p><p>我也试着在工作和生活中，尽量独立开来，不把工作带到生活中，不带回家，于是就有了加班，不想回家，直到感觉视力欠佳，原来不知不觉中，身边的一切都在改变，都在静静的影响着你的心情，你的身体，甚至你今后的路。</p><p>说到今后的路，一定会越来越艰难，但结局总会是越来越美好。</p><p>过了早婚的年龄就真的应该婚了，家庭才是绝大部分人努力的动力。这一刻，有感觉日子好长，日复一日，什么时候可以过上一家人想过的生活。</p><p>我到底还是没学会如何关心别人。</p><p>所以不拒绝迎来的人，不挽留离去的人。</p><p>看似顺其自然，实则懦弱逃避。</p><p>当时被谁说不珍惜自己的朋友时，还委屈的不行。</p><p>然而任何朋友到最后，都只会是失去和被失去。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;正因为我们知道的太多，所以才会觉得压抑&lt;/p&gt;
&lt;p&gt;许久没有写东西，有时候在想，思维会不会已经枯竭，除了简单的因为所以，完全忘了押韵。&lt;/p&gt;
    
    </summary>
    
      <category term="suibi" scheme="https://blog.yuhanle.com/categories/suibi/"/>
    
    
      <category term="outu" scheme="https://blog.yuhanle.com/tags/outu/"/>
    
  </entry>
  
  <entry>
    <title>iOS工程中网络请求管理的想法</title>
    <link href="https://blog.yuhanle.com/2016/02/25/about-ios-net-manager-idea/"/>
    <id>https://blog.yuhanle.com/2016/02/25/about-ios-net-manager-idea/</id>
    <published>2016-02-25T02:00:00.000Z</published>
    <updated>2021-10-21T08:18:48.333Z</updated>
    
    <content type="html"><![CDATA[<p>最近一直在想一些烧脑的逻辑问题。</p><p>在此之前，我们抛出了<a href="https://yuhanle.github.io/2016/01/04/a-perfect-package-afn-requests-demo/" target="_blank" rel="noopener">一个网络请求框架</a>，在这个框架中，能够很清晰的管理每一个请求，每一个回应，以及统一处理，特殊处理等，但对于开发人员来讲，这只是一个easy的文件目录而已。<a id="more"></a></p><p>目前这个框架仍然存在很多问题，例如请求重发机制有待优化，不支持冻结网络请求，还有在页面销毁时，不支持取消未完成的请求(ps:一次性取消所有请求，但这不是我希望的效果)</p><h5 id="先说说从新手以来对于网络请求管理这块的理解过程："><a href="#先说说从新手以来对于网络请求管理这块的理解过程：" class="headerlink" title="先说说从新手以来对于网络请求管理这块的理解过程："></a>先说说从新手以来对于网络请求管理这块的理解过程：</h5><p>说一下，我们讨论的前提是，希望无关请求都会正常cancel。</p><h6 id="1-统一单例类，管理所有请求"><a href="#1-统一单例类，管理所有请求" class="headerlink" title="1. 统一单例类，管理所有请求"></a>1. 统一单例类，管理所有请求</h6><p>该方法，提供一个单例类，还有几个请求API接口，然后在工程中任何需要网络请求的地方使用，加上url，相关参数以及callback，而且内部的核心代码也是直接与AFNetworking处理，方便快速，但是对于成百上千（这个数字可能会越来越大）的服务端接口来说，不易管理。</p><p>而且在取消全部请求的时候会出现一些意想不到的问题</p><blockquote><p>举个栗子</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A页面push B页面</span><br><span class="line">B页面发出了请求1</span><br><span class="line">请求1完成之后需要A页面发送请求2</span><br><span class="line">假设这个时候网络不佳而B刚好销毁了</span><br><span class="line">这样A的请求2还没回来就被取消</span><br><span class="line">所以A的数据不能及时更新</span><br></pre></td></tr></table></figure><p>request:<br>直接调用<br>response：<br>统一处理<br>cancel:<br>取消全部请求</p><p>如下图<br><img src="http://cdn.yuhanle.com/QQ20160223-0.png" alt="JZ"></p><h6 id="2-统一非单例类，分管请求"><a href="#2-统一非单例类，分管请求" class="headerlink" title="2.统一非单例类，分管请求"></a>2.统一非单例类，分管请求</h6><p>这种方法，创建一个类，每次调用请求的时候都new一个新的实例，然后由vc持有，这样做便于在页面dealloc时，直接取消当前页面发出的所有请求。请求管理类似于，谁请求，谁负责cancel。</p><p>很明显，这种方法大大增加了系统的开销，而且不符合设计思想，虽然可以方便的取消自己管理的请求，但是不支持取消全部请求。如果要支持取消全部请求的话，还需要一个管理类来管理管理请求的管理类，这样的话整个目录看起来横七竖八。</p><p>由于对回调的统一处理也是独立的，所以也会存在部分需求不满足的问题</p><blockquote><p>举个栗子</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">需求中存在token过期的问题</span><br><span class="line">此时队列中存在很多请求</span><br><span class="line">请求1收到了token过期的回应（一般token过期只会保留一次，因为旧token服务器不会帮你保存太多）</span><br><span class="line">需要立马做出处理，比如重新登录</span><br><span class="line">而此时请求2、请求3可能都已发出，或者已经收到回应</span><br><span class="line">由于这里的处理是独立的，难免会产生各种问题</span><br></pre></td></tr></table></figure><p>request:<br>创建新的实例，直接调用<br>response：<br>单独统一处理<br>cancel:<br>持有者取消独自管理的全部请求</p><h6 id="3-统一单例类，分管请求"><a href="#3-统一单例类，分管请求" class="headerlink" title="3.统一单例类，分管请求"></a>3.统一单例类，分管请求</h6><p>分管请求有很多种，例如可以根据功能、接口、或者页面属性来独自管理有共同特点的请求。</p><p>这里的独自管理，其实无非就是给请求加了一个标签，便于管理请求的时候，可以按照某一共同特征来管理。相比较第一种形式，他的优势在于可以按需求取消部分请求，比如在某个页面dealloc的时候，按照页面名称，取消请求队列中有关当前页面所有未完成的请求。</p><blockquote><p>举个栗子</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">首先支持按照标签取消请求</span><br><span class="line">其次统一处理可以在遇到突发情况（token过期）的时候，cancel所有请求</span><br></pre></td></tr></table></figure><p>request:<br>直接调用<br>response：<br>统一处理<br>cancel:<br>取消全部请求同时支持按照tag取消</p><h5 id="开源框架结构简析"><a href="#开源框架结构简析" class="headerlink" title="开源框架结构简析"></a>开源框架结构简析</h5><h6 id="1、YTKNetwork"><a href="#1、YTKNetwork" class="headerlink" title="1、YTKNetwork"></a>1、<a href="https://github.com/yuantiku/YTKNetwork" target="_blank" rel="noopener">YTKNetwork</a></h6><p><img src="http://cdn.yuhanle.com/QQ20160225-0.png" alt="YTK"></p><p>上面的截图来自<a href="https://github.com/yuantiku/YTKNetwork" target="_blank" rel="noopener">YTKNetwork</a>的设计框架，将服务端每个api也做简单的封装处理（例如图中的RegisterApi），使用起来很舒服，但是这样写下去，需要些成百上千个.h.m，想想都觉得不可思议，当然这只是一种设计模式，方便开拓使用者更广泛的思路。</p><p>我在工程中的做法都是根据功能，将服务端的api做了分类，接口中保留了服务端需要的info，由调用者填充即可。如下图<br><img src="http://cdn.yuhanle.com/QQ20160225-2.png" alt="WS"></p><p>有兴趣的朋友可以下载我的<a href="https://github.com/yuhanle/WSApiInvoker" target="_blank" rel="noopener">Demo</a>捋一捋。</p><h6 id="2、MGJRequestManager"><a href="#2、MGJRequestManager" class="headerlink" title="2、MGJRequestManager"></a>2、<a href="https://github.com/mogujie/MGJRequestManager" target="_blank" rel="noopener">MGJRequestManager</a></h6><p><img src="http://cdn.yuhanle.com/QQ20160225-1.png" alt="MGJ"></p><p>虽然这个框架仅有两个文件，但是功能很强大，而且支持缓存，用起来如图，我们可以简单的把他当做一个请求类来使用，最好还是配合YTK的模式，封装好请求和回应，接口统一管理，这样用起来才不失效率。</p><p>截图来自：<br><a href="https://github.com/lookingstars/nuomi" target="_blank" rel="noopener">JZNetworkSingleton</a><br>开源框架参考:<br><a href="https://github.com/yuantiku/YTKNetwork" target="_blank" rel="noopener">YTKNetwork</a><br><a href="https://github.com/mogujie/MGJRequestManager" target="_blank" rel="noopener">MGJRequestManager</a></p><p>看完YTK的框架设计，框架越复杂，功能越强大，用起来越方便</p><p>欢迎大家与我交流！！！</p><p>本站文章如无其他特殊说明，均为原创，转载请注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近一直在想一些烧脑的逻辑问题。&lt;/p&gt;
&lt;p&gt;在此之前，我们抛出了&lt;a href=&quot;https://yuhanle.github.io/2016/01/04/a-perfect-package-afn-requests-demo/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一个网络请求框架&lt;/a&gt;，在这个框架中，能够很清晰的管理每一个请求，每一个回应，以及统一处理，特殊处理等，但对于开发人员来讲，这只是一个easy的文件目录而已。
    
    </summary>
    
      <category term="iOS" scheme="https://blog.yuhanle.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://blog.yuhanle.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>一个关于蓝牙4.0的智能硬件Demo 详解</title>
    <link href="https://blog.yuhanle.com/2016/01/10/about-ble-intelligent-hd-demo-detailed/"/>
    <id>https://blog.yuhanle.com/2016/01/10/about-ble-intelligent-hd-demo-detailed/</id>
    <published>2016-01-10T09:00:00.000Z</published>
    <updated>2021-10-21T08:18:48.333Z</updated>
    
    <content type="html"><![CDATA[<p>写这篇详解是因为最近很多人都在问相关问题，但是上篇文章<a href="https://yuhanle.github.io/2015/06/24/ble-development-continuously-update/" target="_blank" rel="noopener">iOS-BLE蓝牙开发持续更新</a>已经过去半年，很多东西已经开始遗忘，今天重新拾起，并在Demo中新添了具体功能和详细注释，顺便屡一下当初设计的思路，我想用图片来解释会更好理解。<a id="more"></a></p><p>首先看一下几个文件的大概功能，后面在用图来分析其中的设计理念。</p><h4 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h4><p>整个文件主要包含四大块，每一块的功能都是独立开的，不过当中却又设计不足的地方，希望各位能够积极fork，贡献代码！</p><ul><li>QWSDiscovery</li></ul><p>这个文件是功能的核心，主要负责和系统的CoreBluetooth沟通，比如扫描设备，连接，断开等操作。其中维护了一个设备列表，使用设备的uuid来唯一识别。在这个文件中，同时也定义了通知和错误类型，方便处理与设备之间的信息交流。</p><ul><li>QWSBleHelper </li></ul><p>用心的读者一定发现，在我们的每一个viewController中，只要与蓝牙功能相关，那他一定维护了一个helper。在这里我称这个页面为监护人，智能设备就像是一个孩子，很多孩子在幼儿园里，我只关心我的孩子，而这个helper就像幼儿园老师，他负责告知我们孩子在校的情况，也可以让我和孩子直接沟通。</p><p>helper中会维护两个集合，一个是我关心的设备集合，一个是即将断开的设备集合。并不是连接成功的设备就会加入到这个集合中，只有监护人发出了与这个设备相关的请求（比如说，连接，获取信息等），这个时候，hepler可以判定这个设备是被监护人关心的，从而这个设备有信息更新的时候，他会告知所有监护这个设备的监护人。</p><p>在这里之所以即将断开的设备集合是为了，在监护人发出断开请求之后，仍然能够清晰的告知监护人该设备的状态信息，等到真正断开连接之后通知到每一个监护人。</p><ul><li>QWSBleHandler</li></ul><p>这个文件顾名思义，就是一些代理方法。设计中是将他加入到helper中，当helper收到设备发来的信息时，通过代理将信息拆解并封装模型通知到所有监护人，写在这里纯粹只是为了看起来更加清晰，分担一下各个文件的代码压力。</p><ul><li>QWSDevControlService</li></ul><p>继承NSObject，封装的智能硬件设备的模型。<br>对于智能硬件设备来讲，单单一个CBPeripheral（CoreBluetooth里的对象）是远远不够的。我们可能需要为他丰富更多的扩展信息，比如这个设备是否自动重连，是否需要断开后连接，是否认证，重连次数，版本号等，当然也可以继承CBPeripheral，但这里我觉得将CBPeripheral作为其一个属性会比较清晰。</p><p>这个对象会维护自己所有的读写操作，不管外界发来什么指令信息，他都能根据自己当前的状态，该报错报错，该执行执行，并将结果反馈给每一个监护人。</p><hr><h4 id="图解说明"><a href="#图解说明" class="headerlink" title="图解说明"></a>图解说明</h4><p>1.智能设备与移动端的关系</p><p><img src="http://cdn.yuhanle.com/one-ble-demo-1.png" alt="Paste_Image.png"></p><p>我们的Discovery在最顶层，不会参与与设备的直接交互，所有的收发数据都是经过系统的框架实现。</p><p>2.监护人与孩子的关系</p><p><img src="http://cdn.yuhanle.com/one-ble-demo-2.png" alt="Paste_Image.png"></p><p>图中的连线很多，可能很迷糊，同一种颜色的连线代表数据交互，看helper里关心的设备，可以明显理解，只有关心这个设备才会收到这个设备的信息。</p><p>每一个viewController维护一个helper，通过NSNotificationCenter广播所有操作的结果，并告知每一个关心这个设备的viewController。</p><p>简言之，就是监护人接不接受这个通知，或者老师发不发送这个消息给监护人。有一点需要明白的是，不管监护人想不想收到这个设备的消息，这个设备都是会广播自己的信息的，只是helper会判断这个孩子是不是你的~</p><p>以上就是这个Demo的设计思路，当然Demo中仍有很多不足，之所以不敢称之为kit，是因为它确实没有达到kit的封装能力与效果，毕竟这只是一个Demo，他只是简单体现了一个设计思路，并不能达到通用的效果，因为在智能硬件这一块，每个产品的协议，属性都会有所差异，不可能做到通用的效果。希望和大家有更深入的交流与学习！</p><p>最后回顾一下上篇文章的地址：<a href="https://yuhanle.github.io/2015/06/24/ble-development-continuously-update/" target="_blank" rel="noopener">iOS-BLE蓝牙开发持续更新</a></p><p>以及这个说了很久的Demo地址：<a href="https://github.com/yuhanle/WEBlueToothManager" target="_blank" rel="noopener">一个iOS BLE蓝牙学习的Demo</a></p><p>在这里也顺便介绍一下近期看到的一篇关于BLE开发的kit(<a href="http://macpu.github.io/2015/11/04/MPBluetoothKit-iOS%E8%93%9D%E7%89%99%E6%A1%86%E6%9E%B6/" target="_blank" rel="noopener">MPBluetoothKit iOS蓝牙框架</a>)，作者很详细的将系统的CoreBluetooth的代理都用block实现了，看起来更加清晰与实用，也希望各位能够多多关注，共同学习。</p><p>本站文章如无其他特殊说明，均为原创，转载请注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写这篇详解是因为最近很多人都在问相关问题，但是上篇文章&lt;a href=&quot;https://yuhanle.github.io/2015/06/24/ble-development-continuously-update/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;iOS-BLE蓝牙开发持续更新&lt;/a&gt;已经过去半年，很多东西已经开始遗忘，今天重新拾起，并在Demo中新添了具体功能和详细注释，顺便屡一下当初设计的思路，我想用图片来解释会更好理解。
    
    </summary>
    
      <category term="iOS" scheme="https://blog.yuhanle.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://blog.yuhanle.com/tags/iOS/"/>
    
  </entry>
  
</feed>
