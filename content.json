{"meta":{"title":"煜寒了","subtitle":"关心粮食和蔬菜","description":"前爱奇艺高级会员","author":"煜寒了","url":"https://blog.yuhanle.com"},"pages":[{"title":"","date":"2021-10-21T08:18:48.332Z","updated":"2021-10-21T08:18:48.332Z","comments":false,"path":"/404.html","permalink":"https://blog.yuhanle.com//404.html","excerpt":"","text":""},{"title":"关于我","date":"2018-02-27T04:48:18.000Z","updated":"2021-10-21T08:18:48.340Z","comments":true,"path":"about/index.html","permalink":"https://blog.yuhanle.com/about/index.html","excerpt":"","text":"生命如草芥，有时很脆弱，但比宇宙间的任何东西都高贵的多，因为人有一棵能思想的灵魂 联系我Weibo | Email | Github 感谢投食"},{"title":"友情链接","date":"2018-06-30T02:55:32.000Z","updated":"2021-10-21T08:18:48.341Z","comments":true,"path":"links/index.html","permalink":"https://blog.yuhanle.com/links/index.html","excerpt":"","text":"博客名 作者 介绍 里脊串的开发随笔 里脊串 几乎全栈 Casa Taloyum Casa 架构师 Halfrost’s Field - 冰霜之地 冰霜 逆天高产"},{"title":"标签","date":"2018-02-27T04:49:30.000Z","updated":"2021-10-21T08:18:48.341Z","comments":false,"path":"tags/index.html","permalink":"https://blog.yuhanle.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-02-27T04:48:55.000Z","updated":"2021-10-21T08:18:48.341Z","comments":false,"path":"categories/index.html","permalink":"https://blog.yuhanle.com/categories/index.html","excerpt":"","text":""},{"title":"感谢以下网友投食","date":"2018-07-06T09:13:09.000Z","updated":"2021-10-21T08:18:48.342Z","comments":true,"path":"thanks/index.html","permalink":"https://blog.yuhanle.com/thanks/index.html","excerpt":"","text":"昵称 金额/元 备注 渠道 时间 *丫 2.33 From 煜寒了 的文章 微信 2018-07-06 16:59 Maggie的小蜗居 2.00 iOS-BLE蓝牙开发持续更新 简书 2017-05-24 15:59 叶舞清风 2.00 iOS-BLE蓝牙开发持续更新 简书 2017-01-20 14:46 宋丫头 2.00 iOS-BLE蓝牙开发持续更新 简书 2016-12-01 16:46 CocoaCxx 5.00 iOS-使用AudioServices相关接口的连续震动 简书 2016-07-29 12:03 CocoaCxx 10.00 iOS-BLE蓝牙开发持续更新 简书 2016-07-21 17:33 CocoaCxx 1.00 iOS-BLE蓝牙开发持续更新 简书 2016-07-21 17:14 投食 微信支付 支付宝"}],"posts":[{"title":"使用 fastlane 进行 iOS 打包","slug":"fastlane-say-here","date":"2018-08-06T01:00:00.000Z","updated":"2021-10-21T08:18:48.335Z","comments":true,"path":"2018/08/06/fastlane-say-here/","link":"","permalink":"https://blog.yuhanle.com/2018/08/06/fastlane-say-here/","excerpt":"fastlane 是一个通过简单命令来完成诸如截图、获取证书、编译、导出安装包、提交 iTunesConnect 等一系列操作的工具，它同时支持 iOS 和 Android。","text":"fastlane 是一个通过简单命令来完成诸如截图、获取证书、编译、导出安装包、提交 iTunesConnect 等一系列操作的工具，它同时支持 iOS 和 Android。 fastlane 🚀 Save hours every time you push a new release to the store or beta testing service ✨ Integrates with all your existing tools and services (170 actions currently) 📖 100% open source under the MIT license 🎩 Easy setup assistant to get started in a few minutes ⚒ Runs on your machine, it’s your app and your data 👻 Integrates with all major CI systems 🖥 Supports iOS, Mac, and Android apps 🔧 Extend and customise fastlane to fit your needs, you’re not dependent on anyone 💭 Never remember any commands any more, just fastlane 🚢 Deploy from any computer, including a CI server 你能够通过简单的方式配置流程进行的顺序，并通过非常简单的命令执行其中的一个流程。当然它的简单并不代表功能也简陋，有开源社区的支持，更新迅速且有很多功能能够满足你的需求。 为什么使用它作为公司的 iOS 程序员，少不了在发布应用的时候各种等待。标准的手动发布流程是：编译-&gt;打包上传-&gt;填写应用更新数据-&gt;等待 iTunesConnect 编译-&gt;选择版本发布，整个过程大概需要 30 分钟左右。关键是这个过程就像windows 装系统一样，虽然手动参与的不多，但是要一直守在电脑前等着。 刚开始用 fastlane，发现其使用和配置还算简单，有开源社区支持，更新迅速功能强大。且相比 jenkins 里的插件，fastlane 可以单独使用，也可以被多种CI 接入。 程序员这么懒，一定会想办法让他自动化的。后来发现特别懒的 Felix Krause 写的 Fastlane，Fastlane可以非常快速简单的搭建一个自动化发布服务，并且支持 Android，iOS，MacOS。他可以实现一条命令从编译到选版发布全程不用干预。作为程序员的你只要一条命令，看集美剧，发布就完成了。截止刚刚 Fastlane 官网上宣称已经为程序员节省了13,746,550小时+。 使用场景 提交时执行测试（包括单元测试和集成测试）； 构建并分发内部测试，公开测试版本； 构建生产版本并上传至 ITC（包括更新配置文件，创建新的屏幕截图，上传应用并提交审核）； … 系统要求 会编程 Xcode7+ Mac OS 10.11+ 工具集fastlane 将如下的工具套件有机地结合起来,从管理证书到单元测试,从编译打包到上传发布,都能通过命令行轻松完成.该套件支持与 Jenkins 和 CocoaPods，xctools 等其他第三方工具的集成,并且能够定义多个通道（lanes）以支持不同的部署目标。 测试 scan =&gt; 自动运行测试工具，并且可以生成漂亮的 HTML 报告 证书，配置文件 cert =&gt; 自动创建管理 iOS 代码签名证书 sigh =&gt; 一声叹息啊，这么多年和 Provisioning Profile战斗过无数次。总是有这样那样的问题导致配置文件过期或者失效。sigh 是用来创建、更新、下载、修复 Provisioning Profile 的工具。 pem =&gt; 自动生成、更新推送配置文件 match =&gt; 一个新的证书和配置文件管理工具。我会另写一篇文章专门介绍这个工具。他会所有需要用到的证书传到 git 私有库上，任何需要配置的机器直接用 match 同步回来就不用管证书问题了，小团队福音啊！ 截图 snapshot =&gt; 用 Xcode7 推出的 UI test 功能实现自动化截图 frameit =&gt; 可以把截的图片自动套上一层外边框 发布 produce =&gt; 如果你的产品还没在 iTunes Connect(iTC) 或者 Apple Developer Center(ADC) 建立，produce 可以自动帮你完成这些工作 deliver =&gt; 自动上传截图，APP 的元数据，二进制 (ipa) 文件到 iTunes Connect TestFlight 管理 pilot =&gt; 管理 TestFlight 的测试用户，上传二进制文件 boarding =&gt; 建立一个添加测试用户界面，发给测试者，可自行添加邮件地址，并同步到 iTC 辅助工具 spaceship =&gt; 为 pilot，boarding和 deliver等工具提供和 iTC 和 ADC 的交互 API。spaceship本来是个独立的项目，后来被 Fastlane 收编进来 WatchBuild =&gt; 是一个独立的 iTC 监控工具，开启 WatchBuild 可以监控 iTC 上的文件状态，弹出 MacOS 自带的 Notification Android supply =&gt; 自动上传到 Google Play 工具 screengrab =&gt; Android 的自动截图工具 简例fastlane 命令是一个流程控制的命令行工具(CLI)，通过内部集成 action 和第三方的 action 完成一系列控制流程。运行 fastlane 命令行工具，会读取当前目录或者 ./fastlane 目录下的 Fastfile 配置文件。 在 Fastfile 中： action =&gt; Fastlane 中的每一条命令都是一个扩展(action)，上面提到的 deliver，sigh之类的工具本身是 CLI，但是在 Fastlane 中内嵌了对他们支持的 action lane =&gt; Fastlane 中流程的合集，每一个动作即可以是 action，也可以是其他的 lane。语法和 ruby 中的 rake 非常像 一个简单的发布流程： 123456789101112lane :deploy do # 执行 pod instasll cocoapods # 执行 carthage bootstrap carthage # 增加build版本号 increment_build_number # 编译代码 gym # 发布到Apple Store deliver(force: true)end 安装安装如果 ruby 版本满足要求，可以直接在命令行执行以下命令安装 fastlane 12#安装fastlanesudo gem install -n /usr/local/bin fastlane 使用的环境搭建好了，就可以进行下一步来配置 fastlane 初始化执行默认的初始化 12cd 项目目录fastlane init 如果你的项目只有一个 bundle id 也只有一个开发者账号的话，可以直接遵循官方的步骤配置。否则需要按照官方文档，配置不同参数和环境变量。 1234567891011121314151617Last login: Tue Aug 7 13:19:59 on ttys000yuhanle:360qws-G100 yuhanle$ fastlane init[✔] 🚀 [✔] Looking for iOS and Android projects in current directory...[13:33:35]: Created new folder './fastlane'.[13:33:35]: Detected an iOS/macOS project in the current directory: 'G100.xcworkspace'[13:33:35]: -----------------------------[13:33:35]: --- Welcome to fastlane 🚀 ---[13:33:35]: -----------------------------[13:33:35]: fastlane can help you with all kinds of automation for your mobile app[13:33:35]: We recommend automating one task first, and then gradually automating more over time[13:33:35]: What would you like to use fastlane for?1. 📸 Automate screenshots2. 👩‍✈️ Automate beta distribution to TestFlight3. 🚀 Automate App Store distribution4. 🛠 Manual setup - manually setup your project to automate your tasks? 在提问了你的 Apple ID，Team 的问题之后，fastlane 会自动检测当前目录下项目的 App Name 和 App Identifier。如果检测的不对，选择 n 自行输入。 接下来会问你这个 app 是否需要在 iTC 和 ADC 中创建(上一步中如果选择 y 会自动检测是否需要创建)，fastlane 会调用 produce 进行初始化，如果现在还不想创建，也可以之后再运行 produce init 进行这个流程。如果不执行 produce 的流程，deliver 的流程也会被掠过，当然之后也可以 deliver init 运行完全一样的流程。 在执行 deliver init 的过程中，会同步 iTC 中的所有语言的元数据和截图，并按照目录结构组织好。目录结构应该类似下面： 1234567891011121314151617181920212223242526272829303132fastlane├── Appfile├── Deliverfile├── Fastfile├── metadata│ ├── copyright.txt│ ├── en-US│ │ ├── description.txt│ │ ├── keywords.txt│ │ ├── marketing_url.txt│ │ ├── name.txt│ │ ├── privacy_url.txt│ │ ├── release_notes.txt│ │ └── support_url.txt│ ├── primary_category.txt│ ├── primary_first_sub_category.txt│ ├── primary_second_sub_category.txt│ ├── secondary_category.txt│ ├── secondary_first_sub_category.txt│ ├── secondary_second_sub_category.txt│ └── zh-Hans│ ├── description.txt│ ├── keywords.txt│ ├── marketing_url.txt│ ├── name.txt│ ├── privacy_url.txt│ ├── release_notes.txt│ └── support_url.txt└── screenshots ├── README.txt ├── en-US │ ├── 一堆png图片 这里肯定会被创建的是 Appfile 和 Fastfile。如果 Deliverfile，screenshots 和 metadata 目录没被创建，可以运行 deliver init 来创建。 Fastfile =&gt; 用来定义所有的 lane 任务 Fastfile帮助 Appfile =&gt; 是用来存储一些公共信息的，比如 app_identifier，apple_id，team_id，itc_team_id等。Appfile帮助 Deliverfile =&gt; deliver 的配置文件 Deliverfile帮助 PS: 这里有个小问题，iTC 和 ADC 中的 Team ID 是不一样的，在 fastlane init 中只会自动在 Appfile 里写入 ADC 的 team_id，所以在这个过程中会不停的问你 iTC 的 Team ID，所以在创建完 Appfile 后，手动在里面添加 itc_team_id。 这个问答对不同的项目可能有各种各样的分支。我已经用不同的项目试过很多次了，但是可能还不是全部，所以你还需要见招拆招。 在这里可以安心的输入密码，所有的密码都加密保存在系统的 Keychain 里。 配置 fastlane 可以通过配置 .env 文件、Appfile、Deliverfile、Fastfile 来完成各种工作。 其中 Fastfile 是最核心的用来控制流程走向的配置文件，.env 和 Appfile 可以辅助 Fastfile 来设置一些参数，Deliverfile 可用于配置提交 iTunesConnect 的一些参数。 需要查看，样例配置可直接前往下载样例配置 AppfileAppfile是用来配置一些类似于 AppleID、BundleID 参数(参数是 fastlane 已经定义好的，新增的并没有用，如果想新增变量需要使用 .env 方式)，可以在 Fastfile 中使用，AppleID、BundleID 等其实会被一些 actions 直接调用，并不需要写出来传递。 普通配置方式直接在 Appfile 里填写 app_identifier、apple_id、team_id 等，然后根据 lane 的不同可以设置成不同。 1234567891011# 默认配置app_identifier \"com.xxxxxxxxxx.test\"apple_id \"xxxxxxxxxx@xxxx.com\"team_id \"xxxxxxxxxx\"# 如果lane是ent换成Dev的配置for_lane :ent do app_identifier \"com.xxxxxxxxxx.testDev\" apple_id \"xxxxxxxxxx@xxxx.com\" TEAM_ID \"xxxxxxxxxx\"end 使用 .env 配置方式.env 这个文件的作用是作为环境变量的配置文件，在 fastlane init 进行初始化后并不会自动生成，如果需要可以自己创建。 执行时默认会读取 .env 和 .env.default 文件里的配置。通过执行 fastlane [lane-name] --env [envName] 来指定使用配置文件 .env.[envName]，读取顺序是 .env -&gt; .env.default -&gt; .env.&lt;envName&gt;，相同的变量名会被后面的覆盖。 如我建了文件 .env.myDev，里面写了一些参数，那在执行的时候使用 fastlane [lane-name] --env myDev 即可，想在 Appfile、Deliverfile、Fastfile 等调用，直接使用 ENV[&#39;keyName&#39;] 即可 123456789# .env.myDev文件# bundle idApp_Identifier = \"com.xxxxxxxxxx.testDev\"# 开发者账号Apple_Id = \"xxxxxxxxxx@xxxx.com\"# 开发者TeamIdTeam_Id = \"xxxxxxxxxx\"# project的target scheme名称Scheme = \"xxxxxxxxxx\" 1234# Appfile使用.env方式直接读取变量即可app_identifier ENV['App_Identifier']apple_id ENV['Apple_Id']team_id ENV['Team_Id'] 注意：因为是 .env 文件是.开头文件，默认是在 finder 中隐藏的，需要通过执行一下命令来显示 1234# 设置隐藏文件可见defaults write com.apple.finder AppleShowAllFiles TRUE# 重启finder服务以生效killall Finder 配置方式对比 普通配置方式：简单易懂，但不能自定义变量，且每个 lane 想不一样都要写一个 for_lane .env 配置方式：功能性强，但配置起来稍微麻烦一点 FastfileFastfile 是对流程进行控制的核心文件，需要设定支持的平台和在一些环节里需要做的事情，是我们脚本的入口，所有的事件驱动都是在这个文件来调度的。 Lane有了 Fastfile，就可以添加自己的发布流程了。打开Fastfile文件(这里我用Sublime 设定语法为Ruby)，如果不出意外的话你生成的Fastfile和我应该差不多。这里我就不贴出来了。 最开始定义了 fastlane_version =&gt; 指定fastlane最小版本 default_platform =&gt; 指定当前平台，可选 ios,android,mac 在 platform 中就是需要修改的重点。先忽略 before_all，after_all，error 这些方法，这里的 lane 就是一组任务，上传到 Firim 的任务如下 12345678910111213141516171819202122232425lane :to_firim do # 如果你用 pod install 注意参数 -&gt; 否则会出错 cocoapods(use_bundle_exec: false) # 如果你没有申请adhoc证书，sigh会自动帮你申请，并且添加到Xcode里 sigh(adhoc: true) # 以下两个action来自fastlane-plugin-versioning， # 第一个递增 Build，第二个设定Version。 # 如果你有多个target，就必须指定target的值，否则它会直接找找到的第一个plist修改 # 在这里我建议每一个打的包的Build都要不一样，这样crash了拿到日志，可以对应到ipa上 increment_build_number_in_plist(target: [target_name]) increment_version_number_in_plist( target: [target_name], version_number: '7.1.3' ) # gym用来编译ipa gym( output_directory: './firim', export_options: &#123; method: \"ad-hoc\", # 这可以不指定 thinning: \"&lt;none&gt;\" &#125; ) # 上传ipa到fir.im服务器，在fir.im获取firim_api_token firim(firim_api_token: [firim_api_token])end Sigh如果你不确定证书目前是否可用，可以用 Sigh 自动生成获取证书。Sigh 会自动根据 Appfile 里设置的 app_identifier从 ADC (苹果开发者中心)生成证书，并下载到项目根目录下(不是 fastlane 目录)，下载后自动安装。你可以通过指定 output_path 指定证书下载位置。 PS：建议不要把这个文件夹同步到项目的 git 中( Fastlane 提供了 match 专门管理所有证书)。可以在 .gitignore 中可以忽略这个文件夹。 Sigh 常用的配置项： Name Type Description Default adhoc bool 获取adhoc证书 fasle development bool 更新开发证书，不更新production证书 false force bool 强制更新证书，不管证书是否在ADC中存在 false iOS 里 code 打包证书有 4 种，adhoc，inhouse，appstore，development 证书。 价格 AppStore 证书 In-House 证书 AdHoc 证书 Development 证书 企业帐户 $299 √ √ √ 公司账号 $99 √ √ √ 个人账户 $99 √ √ √ 其中 In-House 的方式打包的ipa安装没有设备的限制。AdHoc 打包的 ipa 必须提前把设备的 UDID 添加到证书中，并且有 100 台设备限制。 所以如果你不指定 adhoc 为 true，Sigh 会识别帐户类型，企业帐户默认生成 In-House 证书，公司账号和个人帐户默认生成 AppStore 证书。 GymGym 常用配置项： Name Type Description Default scheme string 指定需要编译的scheme clean bool 是否在编译前clean false output_directory string 导出目录 ./ output_name string 导出ipa名字 [app_name].ipa export_options hash/string 这里指定Xcode API的外部配置文件地址，或者配置hash，见下文 export_method string 打包方式，可选项app-store ad-hoc`packageenterprisedevelopmentdeveloper-id` 如果在fastlane中使用了sigh，这个值会从上下文获取 include_bitcode bool 是否开启bitcode Xcode API 默认值为true include_symbols bool 是否生成符号表 Xcode API 默认值为true Xcode7 之后，Xcode API 允许我们指定一个 plist 文件作为额外的配置文件。gym 默认会帮你创建这个文件，你可以直接指定配置。更多关于 plist 可配置项，执行 xcodebuild -help 查看 Available keys for -exportOptionsPlist。 export_method， include_symbols，和 include_bitcode 这些参数都是 exportOptionsPlist 的配置，对应 method，uploadSymbols 和 uploadBitcode。 Gym 可以指定配置文件 Gymfile。 初始化： 1gym init Multi-Target如果我们需要配置多个 target 进行打包的话，我们可以使用 环境变量，来进行配置。假如我们现在有两个 target，targetA 和 targetB，则我们需要创建两个 .env 文件，例如 .env.targetA，.env.targetB，放在 Fastfile 文件同级目录下 在 .env 文件里面我们可以配置一些不同的内容（非公共），比如 app_identifier，release_notes 等等。截图如下： 在 Appfile，Deliverfile，Fastfile 等文件，我们都可以直接使用 .env 文件里面的内容。 Appfile 123456789101112# Appfile#The bundle identifier of your appapp_identifier ENV[&apos;APP_IDENTIFIER&apos;]# Your Apple email addressapple_id ENV[&apos;APPLE_ID&apos;] # Developer Portal Team IDteam_id ENV[&apos;TEAM_ID&apos;]复制代码 Deliverfile，请在设置 release_nores、support_url、private_url 等配置的时候，采用 hash 的方式写。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970# app_identifierapp_identifier ENV['APP_IDENTIFIER']# 用户名,Apple ID电子邮件地址username ENV['APPLE_ID']# 团队IDteam_id ENV['TEAM_ID']# 团队nameteam_name ENV['TEAM_NAME']# copyrightcopyright ENV['COPYRIGHT']# 关键字keywords( 'zh-Hans' =&gt; ENV['KEYWORDS'],)# 新版本修改记录release_notes( # 中国 'zh-Hans' =&gt; ENV['RELEASE_NOTES'], # 澳大利亚 'en-au' =&gt; ENV['RELEASE_NOTES_AU'], # 美国 'en-us' =&gt; ENV['RELEASE_NOTES_US'])# 支持网址support_url( # 中国 'zh-Hans' =&gt; ENV['SUPPORT_URL'], # 澳大利亚 'en-au' =&gt; ENV['SUPPORT_URL_AU'], # 美国 'en-us' =&gt; ENV['SUPPORT_URL_US'])# 隐私政策网址 国家代码 https://www.cnblogs.com/Mien/archive/2008/08/22/1273950.htmlprivacy_url( # 中国 'zh-Hans' =&gt; ENV['PRIVACY_URL'], # 澳大利亚 'en-au' =&gt; ENV['PRIVACY_URL_AU'], # 美国 'en-us' =&gt; ENV['PRIVACY_URL_US'])# 上传完成后提交新版本进行审查submit_for_review false# 跳过HTML报告文件验证force true# 启用iTC的分阶段发布功能 灰度发布phased_release true# 应用审核小组的联系信息 app 审核信息app_review_information( first_name: \"xx\", last_name: \"xx\", phone_number: \"+86 18888888888\", email_address: \"xxxx\", demo_user: \"test1@test.com\", demo_password: \"test123\")... DeliverDeliver 可以完全管理与 iTC 的交互。其中包括： 上传和下载多语言截图 上传和下载多语言元数据 上传二进制文件 还记得上面初始化的时候初始化的 metadata，screenshots 目录么？iTC 中的所有的元数据信息都被保存在 metadata 中，所有的截图信息都被保存在 screenshots 中。 metadata： 可以很容易的管理对应目录下的文件和 iTC 后台的表单项，在执行 deliver 时会自动被传到 iTC。 在 metadata 目录下的文件，如 copyright.txt，是没有本地化的，在二层目录中的文件都是需要对应不同语言的表单项。 如果你不想修改某些项的信息，直接把对应的文件删除即可。 所有这些表单项也可以在 Deliverfile 中指定，Deliverfile 中指定的项优先级比文件高 screenshots： 如果不想更改截图，可以把整个截图目录删除 如果不使用 snapshot (自动化截图)，也可以自己截图放到对应目录下，比一张一张上传 iTC 快的多。截图在iTC 中的排列顺序就是本地文件名的「字母表顺序」(在目录中右击，按文件名排序)。deliver会识别图片分辨率，上传到对应设备中。 如果要通过 deliver 修改元数据或截图，你必须提供所有 iTC 中有的语言。比如后台中有「简体中文」和「英文」，你也必须提供对应的 zh-Hans 和 en-US 文件，否则 deliver 会报缺少语言的错误。可以在 iTC 后台提交的版本中删除语言。 Deliver 常用配置项： Name Type Description Default ipa string ipa地址 如果使用gym，可以通过上下文获取 metadata_path string 指定metadata目录地址 如果在fastlane中./fastlane/metadata，如果作为独立的命令行应用./metadata screenshots_path string 指定screenshots目录地址 如果在fastlane中./fastlane/screenshots，如果作为独立的命令行应用./screenshots skip_binary_upload bool 跳过二进制文件上传，适用于只想改metadata false skip_screenshots bool 跳过截图上传，如果截图没有变化，开启这项节约时间 false skip_metadata bool 跳过元数据上传 false force bool deliver会在上传时汇总信息生成HTML也，等待你审核。跳过这项审核此项设为true false submit_for_review bool 上传完成是否自动提交审核 false automatic_release bool 审核通过是否自动释放 false price_tier int App价格级别。注意：这项提交当时就会生效，所以更改价格还是在后天手动操作 submission_information hash 这是在iTC上点击提交之后的问答表格，可选项 app_review_information hash 提供审核时的信息，详情 app_icon string 指定icon图片地址，必须为png格式 submission_information =&gt; 前缀 export_compliance =&gt; 对应「出口合规信息」，没有特殊情况都选 false 就可以。 前缀 content_rights =&gt; 问你是否包含，显示，访问第三方内容(这项我没在我提交过程中找到)，没有特殊情况也都选 false 就可以。 前缀 add_id_info =&gt; 可就关键了，对应「广告标识符」，如果你在 App 中使用了 IDFA。你必须在这给个理由，而不能直接选 false。 下图等价下表，App 中投放了广告。 123456789101112131415161718submission_information(&#123; export_compliance_available_on_french_store: &quot;false&quot;, export_compliance_contains_proprietary_cryptography: &quot;false&quot;, export_compliance_contains_third_party_cryptography: &quot;false&quot;, export_compliance_is_exempt: &quot;false&quot;, export_compliance_uses_encryption: &quot;false&quot;, export_compliance_app_type: nil, export_compliance_encryption_updated: &quot;false&quot;, export_compliance_compliance_required: &quot;false&quot;, export_compliance_platform: &quot;ios&quot;, content_rights_contains_third_party_content: &quot;false&quot;, content_rights_has_rights: &quot;false&quot;, add_id_info_limits_tracking: &quot;true&quot;, add_id_info_serves_ads: &quot;true&quot;, add_id_info_tracks_action: &quot;false&quot;, add_id_info_tracks_install: &quot;false&quot;, add_id_info_uses_idfa: &quot;true&quot;&#125;); deliver 的 CLI 工具： 下载 iTC 上的截图 deliver download_screenshots 下载 iTC 上的元数据 deliver download_metadata 配置完以上的设置，最后只需要一条命令发布 1fastlane ios deploy 系统级 lanefastlane 默认有 lane。 before_all，就是在执行一次脚本之前首先执行的代码，我们可以在这里面执行一些公共的东西，比如git_pull，cocoapods。 123456before_all do # 检出到 Developer 分支 sh 'git checkout Developer' git_pull cocoapods(repo_update: true)end after_all， 成功结束之后，处理共有的后置逻辑。 before_each，每次执行 lane 之前都会执行一次。 after_each，每次执行 lane 之后都会执行一次。 error，在执行上述情况任意环境报错都会中止并执行一次。 执行顺序 执行顺序 方法名 说明 1 before_all 在执行 lane 之前只执行一次。 2 before_each 每次执行 lane 之前都会执行一次。 3 lane 自定义的任务。 4 after_each 每次执行 lane 之后都会执行一次。 5 after_all 在执行 lane 成功结束之后执行一次。 6 error 在执行上述情况任意环境报错都会中止并执行一次。 Error 出现 Command timed out after 10 seconds on try 1 of 4, trying again...，在 fastlane 文件开头加上： 12ENV[\"FASTLANE_XCODEBUILD_SETTINGS_TIMEOUT\"] = \"180\"ENV[\"FASTLANE_XCODE_LIST_TIMEOUT\"] = \"180\" 插件Fastlane 的插件是一个或者一组 action 的打包，单独发布在 fastlane 之外。Fastlane Plugin 指南 自从 16 年 5 月份推出插件系统以来，现在已经有很多第三方的插件可以使用。查看所有插件： 1fastlane search_plugins 这里介绍两个下文会用到的插件： fastlane-plugin-versioning =&gt; 用来修改 build 版本号和 version 版本号。 Fastlane 内嵌的 action increment_build_number使用的是苹果提供的 agvtool，agvtool 在更改 Build 的时候会改变所有target的版本号。这时如果你在一个工程里有多个产品的话，每次编译，所有的Build都要加1，最后就不知道高到哪里去了。 有了 fastlane-plugin-versioning 不仅可以指定 target 增加 Build，而且可以按照「语义化版本」规范增加 Version，当然也可以直接设定 Version。 PS：最开始写 iOS 时不知道怎么定义 Build。现在我一般都直接定义成纯数字，比如 100 起,每次编译的时候让他自动加一。 fastlane-plugin-firim =&gt; 直接把 AdHoc 或者 InHouse 打包的 ipa 上传到 fir.im，供测试下载。 安装上面的插件 123fastlane add_plugin [name] # 安装方法fastlane add_plugin versioningfastlane add_plugin firim 参考链接iOS 持续交付之 Fastlane 和重复劳动说再见-使用fastlane进行iOS打包 小团队的自动化发布－Fastlane带来的全自动化发布","categories":[{"name":"fastlane","slug":"fastlane","permalink":"https://blog.yuhanle.com/categories/fastlane/"}],"tags":[{"name":"fastlane","slug":"fastlane","permalink":"https://blog.yuhanle.com/tags/fastlane/"}]},{"title":"数据序列化框架在 Swift 日常开发中的应用","slug":"json-analysis-in-swift","date":"2018-07-05T01:00:00.000Z","updated":"2021-10-21T08:18:48.337Z","comments":true,"path":"2018/07/05/json-analysis-in-swift/","link":"","permalink":"https://blog.yuhanle.com/2018/07/05/json-analysis-in-swift/","excerpt":"","text":"到了 Swift 年代，第三方库 SwiftyJSON 和 ObjectMapper 都曾经作为 JSON 转换的中流砥柱，只是这两者还是免不了“手动指定字段和JSON字典映射关系”的工作。于是阿里想了个黑科技（HandyJSON），通过分析Swift数据结构在内存中的布局，自动分析出映射关系，进一步降低开发者使用的成本。 如今我们就有多个选择：ObjectMapper、HandyJSON、SwiftyJSON、MJExtension 等 其实我们在日常开发中，对于 JSON 数据的处理有两大需求： json 和 model 互相转换（Android Studio有 Gson format 插件，但Xcode没有类似功能） 服务端返回的 json 里可能有 null，但是 Swift 语言的空是用 nil 表示，需要空值处理(对象 Optional 类型) 框架简介ObjectMapper先看 ObjectMapper ： Model 类必须实现 Mappable 协议，即实现 init 和 mapping 函数；适合跟 Alamofire 配合。但是 mapping 函数实现起来过于臃肿耗时，只能借助插件来快速完成。 123456789101112131415161718192021222324252627282930313233343536373839import ObjectMapperclass PersonOBM: Mappable &#123; var username: String? var age: Int? var weight: Double! var sex: Bool! var location: String? var three_day_forecast: [ForecastOBM]? required init?(map: Map) &#123; &#125; func mapping(map: Map) &#123; username &lt;- map[\"username\"] age &lt;- map[\"age\"] weight &lt;- map[\"weight\"] sex &lt;- map[\"sex\"] location &lt;- map[\"location\"] three_day_forecast &lt;- map [\"three_day_forecast\"] &#125;&#125;class ForecastOBM: Mappable &#123; var conditions: String? var day: String? var temperature: Double! required init?(map: Map) &#123; &#125; func mapping(map: Map) &#123; conditions &lt;- map[\"conditions\"] day &lt;- map[\"day\"] temperature &lt;- map[\"temperature\"] &#125;&#125; j2s 是一个 macOS app 能够将 JSON 对象转成 Swift 结构体 HandyJSON再看 HandyJSON， 写起来比较方便，类和结构体要求继承于 HandyJSON、枚举要继承于 HandyJSONEnum。 123456789101112131415161718192021222324import HandyJSONclass PersonHJ: HandyJSON &#123; var username: String? var age: Int? var weight: Double! var sex: Bool! var locatoin: String? var three_day_forecast: [ForecastHJ]? required init() &#123; &#125;&#125;class ForecastHJ: HandyJSON &#123; var conditions: String? var day: String? var temperature: Double! required init() &#123; &#125;&#125; 比ObjectMapper使用上要简单， 不用写mapping函数那么多代码了。 SwiftyJSON看 SwiftyJSON：取字段值使用比较方便， 但是然并卵？ SwiftyJSON 不支持转 Model，如果你只是想要解析某几个字段，那么 SwiftyJSON 是不二选择， 而且适用于 Alamofire。 123456789let jsonString: String = \"&#123;\\\"username\\\":\\\"yuhanle\\\",\\\"age\\\":18,\\\"weight\\\":65.4,\\\"sex\\\":1,\\\"location\\\":\\\"Toronto, Canada\\\",\\\"three_day_forecast\\\":[&#123;\\\"conditions\\\":\\\"Partly cloudy\\\",\\\"day\\\":\\\"Monday\\\",\\\"temperature\\\":20&#125;,&#123;\\\"conditions\\\":\\\"Showers\\\",\\\"day\\\":\\\"Tuesday\\\",\\\"temperature\\\":22&#125;,&#123;\\\"conditions\\\":\\\"Sunny\\\",\\\"day\\\":\\\"Wednesday\\\",\\\"temperature\\\":28&#125;]&#125;\" let dataFromString = jsonString.data(using: .utf8, allowLossyConversion: false)do &#123; let json = try JSON(data: dataFromString!) print(json[\"username\"], json[\"weight\"], json[\"three_day_forecast\"][0][\"conditions\"])&#125; catch let error as NSError &#123; print (\"Error: \\(error.domain)\")&#125; MJExtension最后看下一下 MJExtension，作为一个从 ObjC 年代就开始流程的转换框架，在如今使用的人仍然很多，但是对于 Swift 的集成却不是特别友好，官方 issue 列表中经常都会有申请支持 swift 的呼声！ 12345678910111213141516import MJExtensionclass PersonMJ: NSObject &#123; @objc var username: String? @objc var age = 0 @objc var weight = 0.0 @objc var sex = false @objc var location: String? @objc var three_day_forecast: [ForecastMJ]?&#125;class ForecastMJ: NSObject &#123; @objc var conditions: String? @objc var day: String? @objc var temperature = 0.0&#125; 尽管在支持上不是特别友好，但是在自定义 Model 的过程中，应该是最轻松的一款，但是在升级 Swift 4 之后，需要在属性前添加 @objc 才可以正常使用，否则转换失败。具体情况可参考：Swift 4 字典转模型失败 另外还有一种情况，就是关于整型属性，需要给定初试值，也就是说，MJExtension 无法序列化/反序列化整型。解决办法很简单， 就是赋个默认值， 即将Optional整型变为整型就可以。 12345class People: NSObject &#123; var name: String? var age: Int? // 请注意：MJExtension不能解析Optional Int类型 var age = 0 // 正确&#125; 运行耗时我们准备了一小段 JSON 数据，循环解析 10000 次，来分析几大框架的运行耗时： 123456789101112131415161718192021222324&#123; \"username\": \"yuhanle\", \"age\": 18, \"weight\": 65.4, \"sex\": 1, \"location\": \"Toronto, Canada\", \"three_day_forecast\": [ &#123; \"conditions\": \"Partly cloudy\", \"day\": \"Monday\", \"temperature\": 20 &#125;, &#123; \"conditions\": \"Showers\", \"day\": \"Tuesday\", \"temperature\": 22 &#125;, &#123; \"conditions\": \"Sunny\", \"day\": \"Wednesday\", \"temperature\": 28 &#125; ]&#125; 以 HandyJSON 为例，在开始处理数据和结束时，记录时间差，时间差的结果每次会有波动 1234567891011121314151617181920212223let maxCount = 10000func testHandyJSON(json: String) -&gt; Void &#123; var start = CFAbsoluteTimeGetCurrent() var people: PersonHJ = PersonHJ() for _ in 0..&lt;maxCount &#123; people = PersonHJ.deserialize(from: json)! &#125; var executionTime = CFAbsoluteTimeGetCurrent() - start print(\"HandyJSON deserialize time totals: \", executionTime) start = CFAbsoluteTimeGetCurrent() var res = \"\" for _ in 0..&lt;maxCount &#123; res = people.toJSONString()! &#125; executionTime = CFAbsoluteTimeGetCurrent() - start print(res) print(\"HandyJSON toJSONString time totals: \", executionTime)&#125; 最终记录得到的结果对比图 测试项 JSON -&gt; MODEL MODEL -&gt; JSON HandyJSON 3.0839329957962 4.97446703910828 ObjeceMapper 1.40153098106384 1.2123589515686 SwiftJSON 不支持 不支持 MJExtension 0.417935013771057 0.418874025344849 结果有点出乎意料，HandyJSON 的黑魔法纵然很强大，这也导致了耗时的问题，相比较而言，不太友好的 MJExtension 速度最快。 总结对于应用开发来说，JSON 数据序列化和反序列号的操作必不可少，上述分析的效率和性能问题，也应该多考虑，选择合适的框架很重要，学习和踩坑也是并存的。 另外，Swift 支持 Codable 协议，对这个需求的处理也有很大的支持！ 参考链接 应该什么时候使用Codable Swift实现JSON转Model - HandyJSON使用讲解 iOS JSON序列化/反序列化哪家强？ Swift 4 Codable 讓序列化變得更簡單","categories":[{"name":"swift","slug":"swift","permalink":"https://blog.yuhanle.com/categories/swift/"}],"tags":[{"name":"swift","slug":"swift","permalink":"https://blog.yuhanle.com/tags/swift/"},{"name":"JSON","slug":"JSON","permalink":"https://blog.yuhanle.com/tags/JSON/"},{"name":"HandyJSON","slug":"HandyJSON","permalink":"https://blog.yuhanle.com/tags/HandyJSON/"}]},{"title":"RAC 在 MVVM 中的常见用法","slug":"rac-in-mvvm","date":"2018-05-13T01:00:00.000Z","updated":"2021-10-21T08:18:48.339Z","comments":true,"path":"2018/05/13/rac-in-mvvm/","link":"","permalink":"https://blog.yuhanle.com/2018/05/13/rac-in-mvvm/","excerpt":"开篇在 iOS 开发中，或多或少都会见过 RAC 的身影，它为提高开发效率而生，在某些特定情况下开发时可以大大简化代码，并且目前来看安全可靠。如果你还没有接触 RAC，建议你工作之余稍作研究，并尝试体验一下。","text":"开篇在 iOS 开发中，或多或少都会见过 RAC 的身影，它为提高开发效率而生，在某些特定情况下开发时可以大大简化代码，并且目前来看安全可靠。如果你还没有接触 RAC，建议你工作之余稍作研究，并尝试体验一下。 关于 RAC 的解释，官方的说，ReactiveCocoa（其简称为RAC）是由 GitHub 开源的一个应用于 iOS 和 OS X 开发的新框架，其具有 函数式编程 和 响应式编程 的特性。 这是摘自花瓣网工程师博客的一幅图，可以直观的看到各个类之间的关系 接下来，我们就结合 RAC 中的类以及实际使用场景，来描述一下他的基本用法： RACSignal RACSubject RACSequence RACMulticastConnection RACCommand RAC 常用宏 RAC-bind RAC-过滤 RAC-映射 RAC-组合 正题基础用法RACSignal信号类，Signal 是 RAC 中的核心概念。当数据改变时，信号内部就会收到数据，然后发出。但是默认一个信号是冷信号，当一个信号没有订阅者（Subscriber）时它什么也不干，就像我们的函数，当一个函数写好之后并没有被调用它也什么都不会干。信号可以通过以下三种方式发送事件给订阅者。 详细介绍参考：从代理到 RACSignal 123456789101112131415161718192021222324252627// 1.创建信号RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; // 3.发送信号 [subscriber sendNext:@\"ws\"]; // 4.取消信号 // 如果信号想要被取消，就必须返回一个RACDisposable // 信号什么时候被取消： // 1.自动取消，当一个信号的订阅者被销毁的时候机会自动取消订阅， // 2.手动取消， // block什么时候调用：一旦一个信号被取消订阅就会调用 // block作用：当信号被取消时用于清空一些资源 return [RACDisposable disposableWithBlock:^&#123; NSLog(@\"取消订阅\"); &#125;];&#125;];// 2. 订阅信号// subscribeNext// 把nextBlock保存到订阅者里面// 只要订阅信号就会返回一个取消订阅信号的类RACDisposable *disposable = [signal subscribeNext:^(id x) &#123; // block的调用时刻：只要信号内部发出数据就会调用这个block NSLog(@\"%@\", x);&#125;];// 取消订阅[disposable dispose]; 总结 信号类的作用： 只要有数据改变就会把数据包装成信号传递出去 只要有数据改变就会有信号发出 数据发出，并不是信号类发出，信号类不能发送数据 实现思路： 当一个信号被订阅，创建订阅者，并把 nextBlock 保存到订阅者里面 创建的时候会返回 [RACDynamicSignal createSignal:didSubscribe]; 调用 RACDynamicSignal 的 didSubscribe 发送信号 [subscriber sendNext:value]; 拿到订阅者的 nextBlock 调用 RACSubjectRACSubject 在使用中我们可以完全代替代理/通知，来简化代码。 (可变的信号）： 可以连接RAC代码与非RAC代码，可以接收和主动发送信号。看了很多介绍都不推荐使用。目前我只把他当作代理使用了一下。 详细介绍参考：『可变』的热信号 RACSubject 123456789101112// 1. 创建信号RACSubject *subject = [RACSubject subject];// 2. 订阅信号[subject subscribeNext:^(id x) &#123; // block:当有数据发出的时候就会调用 // block:处理数据 NSLog(@\"%@\",x);&#125;];// 3. 发送信号[subject sendNext:value]; 注意 RACSubject 和 RACReplaySubject 的区别 RACSubject 必须要先订阅信号之后才能发送信号， 而 RACReplaySubject 可以先发送信号后订阅. RACSubject 代码中体现为：先走TwoViewController的 sendNext，后走 ViewController 的 subscribeNext 订阅 RACReplaySubject 代码中体现为：先走 ViewController 的 subscribeNext 订阅，后走 TwoViewController 的sendNext 可按实际情况各取所需。 RACSequence详细介绍参考：Pull-Driven 的数据流 RACSequence 使用场景： 可以快速高效的遍历数组和字典。 123456789NSString *path = [[NSBundle mainBundle] pathForResource:@\"flags.plist\" ofType:nil];NSArray *dictArr = [NSArray arrayWithContentsOfFile:path]; [dictArr.rac_sequence.signal subscribeNext:^(id x) &#123; NSLog(@\"%@\", x);&#125; error:^(NSError *error) &#123; NSLog(@\"error\");&#125; completed:^&#123; NSLog(@\"完毕\");&#125;]; 也可以使用宏 123456789101112131415NSDictionary *dict = @&#123;@\"key\":@1, @\"key2\":@2&#125;;[dict.rac_sequence.signal subscribeNext:^(id x) &#123; NSLog(@\"%@\", x); NSString *key = x[0]; NSString *value = x[1]; // RACTupleUnpack宏：专门用来解析元组 // RACTupleUnpack 等会右边：需要解析的元组 宏的参数，填解析的什么样数据 // 元组里面有几个值，宏的参数就必须填几个 RACTupleUnpack(NSString *key, NSString *value) = x; NSLog(@\"%@ %@\", key, value);&#125; error:^(NSError *error) &#123; NSLog(@\"error\");&#125; completed:^&#123; NSLog(@\"完毕\");&#125;]; RACMulticastConnection当有多个订阅者，但是我们只想发送一个信号的时候怎么办？这时我们就可以用 RACMulticastConnection，来实现。 详细介绍参考：用于多播的 RACMulticastConnection 123456789101112131415161718// 普通写法, 这样的缺点是：每订阅一次信号就得重新创建并发送请求，很不友好RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; // didSubscribeblock 中的代码都统称为副作用 // 发送请求 NSLog(@\"发送请求啦\"); // 发送信号 [subscriber sendNext:@\"ws\"]; return nil;&#125;];[signal subscribeNext:^(id x) &#123; NSLog(@\"%@\", x);&#125;];[signal subscribeNext:^(id x) &#123; NSLog(@\"%@\", x);&#125;];[signal subscribeNext:^(id x) &#123; NSLog(@\"%@\", x);&#125;]; 12345678910111213141516171819202122// 推荐做法。 使用RACMulticastConnection，无论有多少个订阅者，无论订阅多少次，只发送一个// 1.发送请求，用一个信号内包装，不管有多少个订阅者，只想发一次请求RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; // 发送请求 NSLog(@\"发送请求啦\"); // 发送信号 [subscriber sendNext:@\"ws\"]; return nil;&#125;];//2. 创建连接类RACMulticastConnection *connection = [signal publish];[connection.signal subscribeNext:^(id x) &#123; NSLog(@\"%@\", x);&#125;];[connection.signal subscribeNext:^(id x) &#123; NSLog(@\"%@\", x);&#125;];[connection.signal subscribeNext:^(id x) &#123; NSLog(@\"%@\", x);&#125;];//3. 连接。只有连接了才会把信号源变为热信号[connection connect]; RACCommandRACCommand：RAC 中用于处理事件的类，可以把事件如何处理，事件中的数据如何传递，包装到这个类中，他可以很方便的监控事件的执行过程，比如看事件有没有执行完毕，详细介绍参考：优雅的 RACCommand RACCommand 是一个在 ReactiveCocoa 中比较复杂的类，大多数使用 ReactiveCocoa 的人，尤其是初学者并不会经常使用它。 在很多情况下，虽然使用 RACSignal 和 RACSubject 就能解决绝大部分问题，但是 RACCommand 的使用会为我们带来巨大的便利，尤其是在与副作用相关的操作中。 使用场景：监听按钮点击，异步网络请求 12345678910111213141516171819202122232425// 普通做法// RACCommand: 处理事件// 不能返回空的信号// 1.创建命令RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) &#123; //block调用，执行命令的时候就会调用 NSLog(@\"%@\", input); // input 为执行命令传进来的参数 // 这里的返回值不允许为nil return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@\"执行命令产生的数据\"]; return nil; &#125;];&#125;];// 如何拿到执行命令中产生的数据呢？// 订阅命令内部的信号// ** 方式一：直接订阅执行命令返回的信号// 2.执行命令RACSignal *signal =[command execute:@2]; // 这里其实用到的是replaySubject 可以先发送命令再订阅 // 在这里就可以订阅信号了 [signal subscribeNext:^(id x) &#123; NSLog(@\"%@\", x);&#125;]; 12345678910111213141516171819202122232425// 一般做法// 1.创建命令RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) &#123; //block调用，执行命令的时候就会调用 NSLog(@\"%@\", input); // input 为执行命令传进来的参数 // 这里的返回值不允许为nil return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@\"执行命令产生的数据\"]; return nil; &#125;];&#125;];// 方式二：// 订阅信号// 注意：这里必须是先订阅才能发送命令// executionSignals：信号源，信号中信号，signalofsignals:信号，发送数据就是信号[command.executionSignals subscribeNext:^(RACSignal *x) &#123; [x subscribeNext:^(id x) &#123; NSLog(@\"%@\", x); &#125;]; NSLog(@\"%@\", x);&#125;];// 2.执行命令[command execute:@2]; 12345678910111213141516171819// 高级做法// 1.创建命令RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) &#123; // block调用：执行命令的时候就会调用 NSLog(@\"%@\", input); // 这里的返回值不允许为nil return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@\"发送信号\"]; return nil; &#125;];&#125;];// 方式三// switchToLatest获取最新发送的信号，只能用于信号中信号。[command.executionSignals.switchToLatest subscribeNext:^(id x) &#123; NSLog(@\"%@\", x);&#125;];// 2.执行命令[command execute:@3]; 1234567891011121314151617// switchToLatest--用于信号中信号// 创建信号中信号RACSubject *signalofsignals = [RACSubject subject];RACSubject *signalA = [RACSubject subject];// 订阅信号[signalofsignals subscribeNext:^(RACSignal *x) &#123; [x subscribeNext:^(id x) &#123; NSLog(@\"%@\", x); &#125;];&#125;];// switchToLatest: 获取信号中信号发送的最新信号[signalofsignals.switchToLatest subscribeNext:^(id x) &#123; NSLog(@\"%@\", x);&#125;];// 发送信号[signalofsignals sendNext:signalA];[signalA sendNext:@4]; 1234567891011121314151617181920212223242526272829// 监听事件有没有完成// 注意：当前命令内部发送数据完成，一定要主动发送完成// 1.创建命令RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) &#123; // block调用：执行命令的时候就会调用 NSLog(@\"%@\", input); // 这里的返回值不允许为nil return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; // 发送数据 [subscriber sendNext:@\"执行命令产生的数据\"]; // *** 发送完成 ** [subscriber sendCompleted]; return nil; &#125;];&#125;];// 监听事件有没有完成[command.executing subscribeNext:^(id x) &#123; if ([x boolValue] == YES) &#123; // 正在执行 NSLog(@\"当前正在执行%@\", x); &#125;else &#123; // 执行完成/没有执行 NSLog(@\"执行完成/没有执行\"); &#125;&#125;];// 2.执行命令[command execute:@1]; 进阶用法RAC 常用宏RAC 有许多强大而方便的宏。如下代码所示 12345678// RAC: 把一个对象的某个属性绑定一个信号，只要发出信号，就会把信号的内容给对象的属性赋值// 给 label 的 text 属性绑定了文本框改变的信号RAC(self.label, text) = self.textField.rac_textSignal;// 与上述同样功能[self.textField.rac_textSignal subscribeNext:^(id x) &#123; self.label.text = x;&#125;]; 12345678/*** KVO* RACObserveL: 快速的监听某个对象的某个属性改变* 返回的是一个信号，对象的某个属性改变的信号*/[RACObserve(self.view, center) subscribeNext:^(id x) &#123; NSLog(@\"%@\", x);&#125;]; 12345// 例 textField 输入的值赋值给label，监听 label 文字改变RAC(self.label, text) = self.textField.rac_textSignal;[RACObserve(self.label, text) subscribeNext:^(id x) &#123; NSLog(@\"label的文字变化\");&#125;]; 1234567891011/*** 循环引用问题* 使用 @weakify(self) 和 @strongify(self) 来避免循环引用*/@weakify(self);RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; @strongify(self); NSLog(@\"%@\", self.view); return nil;&#125;];_signal = signal; 123456789101112/*** 元祖* 快速包装一个元组* 把包装的类型放在宏的参数里面，就会自动包装*/RACTuple *tuple = RACTuplePack(@1, @2, @4);// 宏的参数类型要和元祖中元素类型一致，右边为要解析的元祖RACTupleUnpack_(NSNumber *num1, NSNumber *num2, NSNumber * num3) = tuple;// 4.元祖// 快速包装一个元组// 把包装的类型放在宏的参数里面，就会自动包装NSLog(@\"%@ %@ %@\", num1, num2, num3); RAC-bind1234567891011121314151617181920212223// 1.创建信号RACSubject *subject = [RACSubject subject];// 2.绑定信号RACSignal *bindSignal = [subject bind:^RACStreamBindBlock&#123; // block调用时刻：只要绑定信号订阅就会调用。 return ^RACSignal *(id value, BOOL *stop)&#123; // 一般在这个block中做事 ，发数据的时候会来到这个block。 // 只要源信号（subject）发送数据，就会调用block // block作用：处理源信号内容 // value:源信号发送的内容， value = @3; // 如果在这里把 value 的值改了，那么订阅绑定信号的值的 x 就变了 NSLog(@\"接受到源信号的内容：%@\", value); // 返回信号，不能为nil,如果非要返回空---则empty或 alloc init。 return [RACReturnSignal return:value]; // 把返回的值包装成信号 &#125;;&#125;];// 3.订阅绑定信号[bindSignal subscribeNext:^(id x) &#123; NSLog(@\"接收到绑定信号处理完的信号:%@\", x);&#125;];// 4.发送信号[subject sendNext:@\"123\"]; 总结 bind（绑定）的使用思想和 Hook 的一样 —&gt; 都是拦截 API 从而可以对数据进行操作，而影响返回数据 RAC-过滤有时候我们想要过滤一些信号，这时候我们便可以用 RAC 的过滤方法。过滤方法有好多种，如下代码，从不同情况下进行了分析。 123456789// 跳跃 ： 如下，skip传入 2 跳过前面两个值// 实际用处： 在实际开发中比如 后台返回的数据前面几个没用，我们想跳跃过去，便可以用skipRACSubject *subject = [RACSubject subject];[[subject skip:2] subscribeNext:^(id x) &#123; NSLog(@\"%@\", x);&#125;];[subject sendNext:@1];[subject sendNext:@2];[subject sendNext:@3]; 123456789// distinctUntilChanged: -- 如果当前的值跟上一次的值一样，就不会被订阅到RACSubject *subject = [RACSubject subject];[[subject distinctUntilChanged] subscribeNext:^(id x) &#123; NSLog(@\"%@\", x);&#125;];// 发送信号[subject sendNext:@1];[subject sendNext:@2];[subject sendNext:@2]; // 不会订阅到 123456789// take: 可以屏蔽一些值，去掉前面几个值---这里 take 为2 则只拿到前两个值RACSubject *subject = [RACSubject subject];[[subject take:2] subscribeNext:^(id x) &#123; NSLog(@\"%@\", x);&#125;];// 发送信号[subject sendNext:@1];[subject sendNext:@2];[subject sendNext:@3]; // 不会订阅到 1234567891011//takeLast:和take的用法一样，不过他取的是最后的几个值，如下，则取的是最后两个值//注意点:takeLast 一定要调用sendCompleted，告诉他发送完成了，这样才能取到最后的几个值RACSubject *subject = [RACSubject subject];[[subject takeLast:2] subscribeNext:^(id x) &#123; NSLog(@\"%@\", x);&#125;];// 发送信号[subject sendNext:@1]; // 不会订阅到[subject sendNext:@2];[subject sendNext:@3];[subject sendCompleted]; 123456789101112// takeUntil: 给 takeUntil 传的是哪个信号，那么当这个信号发送信号或 sendCompleted，就不能再接受源信号的内容RACSubject *subject = [RACSubject subject];RACSubject *subject2 = [RACSubject subject];[[subject takeUntil:subject2] subscribeNext:^(id x) &#123; NSLog(@\"%@\", x);&#125;];// 发送信号[subject sendNext:@1];[subject sendNext:@2];[subject2 sendNext:@3]; // 1[subject2 sendCompleted]; // 或2[subject sendNext:@4]; 12345678910111213// ignore: 忽略掉一些值// ignore:忽略一些值// ignoreValues:表示忽略所有的值// 1.创建信号RACSubject *subject = [RACSubject subject];// 2.忽略一些值RACSignal *ignoreSignal = [subject ignore:@2]; // ignoreValues:表示忽略所有的值// 3.订阅信号[ignoreSignal subscribeNext:^(id x) &#123; NSLog(@\"%@\", x);&#125;];// 4.发送数据[subject sendNext:@2]; 123456789// 一般和文本框一起用，添加过滤条件// 只有当文本框的内容长度大于 5，才获取文本框里的内容[[self.textField.rac_textSignal filter:^BOOL(id value) &#123; // value 源信号的内容 return [value length] &gt; 5; // 返回值 就是过滤条件。只有满足这个条件才能获取到内容&#125;] subscribeNext:^(id x) &#123; NSLog(@\"%@\", x);&#125;]; RAC-映射RAC的映射在实际开发中有什么用呢？比如我们想要拦截服务器返回的数据，给数据拼接特定的东西或想对数据进行操作从而更改返回值，类似于这样的情况下，我们便可以考虑用 RAC 的映射，实例代码如下 12345678910111213141516- (void)map &#123; // 创建信号 RACSubject *subject = [RACSubject subject]; // 绑定信号 RACSignal *bindSignal = [subject map:^id(id value) &#123; // 返回的类型就是你需要映射的值 // 这里将源信号发送的“123” 前面拼接了 ws： return [NSString stringWithFormat:@\"ws:%@\", value]; &#125;]; // 订阅绑定信号 [bindSignal subscribeNext:^(id x) &#123; NSLog(@\"%@\", x); &#125;]; // 发送信号 [subject sendNext:@\"123\"];&#125; 123456789101112131415161718192021- (void)flatMap &#123; // 创建信号 RACSubject *subject = [RACSubject subject]; // 绑定信号 RACSignal *bindSignal = [subject flattenMap:^RACStream *(id value) &#123; // block：只要源信号发送内容就会调用 // value: 就是源信号发送的内容 // 返回信号用来包装成修改内容的值 return [RACReturnSignal return:value]; &#125;]; // flattenMap 中返回的是什么信号，订阅的就是什么信号 // (那么 x 的值等于 value 的值，如果我们操纵 value 的值那么 x 也会随之而变) // 订阅信号 [bindSignal subscribeNext:^(id x) &#123; NSLog(@\"%@\", x); &#125;]; // 发送数据 [subject sendNext:@\"123\"];&#125; 12345678910111213141516171819202122232425262728293031323334- (void)flattenMap2 &#123; // flattenMap 主要用于信号中的信号 // 创建信号 RACSubject *signalofSignals = [RACSubject subject]; RACSubject *signal = [RACSubject subject]; // 订阅信号 //方式1 [signalofSignals subscribeNext:^(id x) &#123; [x subscribeNext:^(id x) &#123; NSLog(@\"%@\", x); &#125;]; &#125;]; // 方式2 [signalofSignals.switchToLatest]; // 方式3 RACSignal *bignSignal = [signalofSignals flattenMap:^RACStream *(id value) &#123; //value: 就是源信号发送内容 return value; &#125;]; [bignSignal subscribeNext:^(id x) &#123; NSLog(@\"%@\", x); &#125;]; // 方式4 也是开发中常用的 [[signalofSignals flattenMap:^RACStream *(id value) &#123; return value; &#125;] subscribeNext:^(id x) &#123; NSLog(@\"%@\", x); &#125;]; // 发送信号 [signalofSignals sendNext:signal]; [signal sendNext:@\"123\"];&#125; RAC-组合把多个信号聚合成你想要的信号 使用场景：当多个输入框都有值的时候，按钮状态可点击 1234567891011121314151617// 把输入框输入值的信号都聚合成按钮是否能点击的信号- (void)combineLatest &#123; RACSignal *combinSignal = [RACSignal combineLatest:@[self.accountField.rac_textSignal, self.pwdField.rac_textSignal] reduce:^id(NSString *account, NSString *pwd)&#123; //reduce里的参数一定要和combineLatest数组里的一一对应。 // block: 只要源信号发送内容，就会调用，组合成一个新值。 NSLog(@\"%@ %@\", account, pwd); return @(account.length &amp;&amp; pwd.length); &#125;]; // 订阅信号 [combinSignal subscribeNext:^(id x) &#123; self.loginBtn.enabled = [x boolValue]; &#125;]; // 这样写有些麻烦，可以直接用RAC宏 RAC(self.loginBtn, enabled) = combinSignal;&#125; 123456789101112131415161718192021- (void)zipWith &#123; // zipWith:把两个信号压缩成一个信号，只有当两个信号同时发出信号内容时 // 并且把两个信号的内容合并成一个元祖，才会触发压缩流的next事件。 // 创建信号A RACSubject *signalA = [RACSubject subject]; // 创建信号B RACSubject *signalB = [RACSubject subject]; // 压缩成一个信号 // **-zipWith-**: 当一个界面多个请求的时候，要等所有请求完成才更新UI // 等所有信号都发送内容的时候才会调用 RACSignal *zipSignal = [signalA zipWith:signalB]; [zipSignal subscribeNext:^(id x) &#123; //所有的值都被包装成了元组 NSLog(@\"%@\", x); &#125;]; // 发送信号 交互顺序，元组内元素的顺序不会变，跟发送的顺序无关， // 而是跟压缩的顺序有关 [signalA zipWith:signalB] --- 先是 A 后是 B [signalA sendNext:@1]; [signalB sendNext:@2];&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// 任何一个信号请求完成都会被订阅到// merge: 多个信号合并成一个信号，任何一个信号有新值就会调用- (void)merge &#123; // 创建信号A RACSubject *signalA = [RACSubject subject]; // 创建信号B RACSubject *signalB = [RACSubject subject]; // 组合信号 RACSignal *mergeSignal = [signalA merge:signalB]; // 订阅信号 [mergeSignal subscribeNext:^(id x) &#123; NSLog(@\"%@\", x); &#125;]; // 发送信号---交换位置则数据结果顺序也会交换 [signalB sendNext:@\"下部分\"]; [signalA sendNext:@\"上部分\"];&#125;// then 使用需求：有两部分数据：想让上部分先进行网络请求但是过滤掉数据，然后进行下部分的，拿到下部分数据- (void)then &#123; // 创建信号A RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; // 发送请求 [subscriber sendNext:@\"上部分数据\"]; [subscriber sendCompleted]; // 必须要调用sendCompleted方法！ return nil; &#125;]; // 创建信号B RACSignal *signalsB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; // 发送请求 [subscriber sendNext:@\"下部分数据\"]; return nil; &#125;]; // 创建组合信号 // then;忽略掉第一个信号的所有值 RACSignal *thenSignal = [signalA then:^RACSignal *&#123; // 返回的信号就是要组合的信号 return signalsB; &#125;]; // 订阅信号 [thenSignal subscribeNext:^(id x) &#123; NSLog(@\"%@\", x); &#125;];&#125;// concat 使用需求：有两部分数据：想让上部分先执行，完了之后再让下部分执行（都可获取值）- (void)concat &#123; // 创建信号A RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; // 发送请求 [subscriber sendNext:@\"上部分数据\"]; [subscriber sendCompleted]; // 必须要调用sendCompleted方法！ return nil; &#125;]; // 创建信号B RACSignal *signalsB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; // 发送请求 [subscriber sendNext:@\"下部分数据\"]; return nil; &#125;]; // concat: 按顺序去链接 //**-注意-**：concat，第一个信号必须要调用sendCompleted // 创建组合信号 RACSignal *concatSignal = [signalA concat:signalsB]; // 订阅组合信号 [concatSignal subscribeNext:^(id x) &#123; NSLog(@\"%@\",x); &#125;];&#125; 究其本质核心就是各种 signals，也就是bind（绑定），处理相关事物的时候首先想到的就是绑定，基本大多数操作也都是围绕着信号进行的，以上不仅仅是 RAC 的基本用法，在 MVVM 中也是同样适用，只是把业务和逻辑通过 ViewModel 分离解耦，更大程度的利用了 RAC 在开发中的高效优势。 参考链接 函数响应式编程(FRP)从入门到”放弃” iOS使用RAC实现MVVM的正经姿势 『状态』驱动的世界：ReactiveCocoa 系列 ReactiveCocoa学习总结","categories":[{"name":"rac","slug":"rac","permalink":"https://blog.yuhanle.com/categories/rac/"}],"tags":[{"name":"rac","slug":"rac","permalink":"https://blog.yuhanle.com/tags/rac/"}]},{"title":"代码中的缩进线","slug":"line-of-sight-in-code","date":"2018-04-24T01:00:00.000Z","updated":"2021-10-21T08:18:48.338Z","comments":true,"path":"2018/04/24/line-of-sight-in-code/","link":"","permalink":"https://blog.yuhanle.com/2018/04/24/line-of-sight-in-code/","excerpt":"在近期伦敦举行的 Golang 英国会议 上，我在地道的Go 语言窍门 交流（幻灯片）中讲到关于代码中的缩进线， 我想在这里稍微解释一下。","text":"在近期伦敦举行的 Golang 英国会议 上，我在地道的Go 语言窍门 交流（幻灯片）中讲到关于代码中的缩进线， 我想在这里稍微解释一下。 缩进线是“观察者无障碍视线的直线” 良好的代码缩进线不仅对你的功能没有任何影响，还可以帮助其他需要的人阅读你的代码。其他程序员（包括你未来的自己）可以浏览一个专栏并且理解代码的预期流程。如果他们不得不在脑子里分析 if 语句，若没有良好的缩进线，将会使这个任务变得非常艰难。 大多数人关注编写代码的代价（比如“这需要多长时间才能完成？”）但是维护代码的成本要高得多 - 特别是在成熟的项目中。 让功能明显，清晰，简单易懂才是至关重要的。 良好缩进线的建议： 让快乐路径居左侧对齐，这样你就可以快速扫描一列来查看预期的执行流程 不要隐藏缩进大括号中代码逻辑 尽早的退出 function 避免 else return，考虑翻转 if 语句 把 return 声明作为最后一行 提取 function 和 method 以保持结构小巧和可读 如果你需要大缩进的代码，考虑当做一个 function 分解出来 当然，会有很多很好的理由来打破所有这些规则 - 但是采用这种风格作为默认规则，我们发现我们的代码变得更具可读性。 避免 else return编写具有良好视觉效果的代码的关键是保持 else 结构小巧，或者如果可以的话，完全避免它们。 看下这个代码： 123456789101112131415161718if something.OK() &#123; something.Lock() defer something.Unlock() err := something.Do() if err == nil &#123; stop := StartTimer() defer stop() log.Println(&quot;working...&quot;) doWork(something) &lt;-something.Done() // wait for it log.Println(&quot;finished&quot;) return nil &#125; else &#123; return err &#125;&#125; else &#123; return errors.New(&quot;something not ok&quot;)&#125; 这代表了我们最初如何思考我们的功能在做什么（“如果某件事情没问题，那么就做，如果没有错误，那么做这些事情”等等），但是它变得很难遵循。 上面的代码很难遵循’快乐路径’（执行顺利进行的路线）。它在第二行开始缩进并从那里继续。 当我们检查来自 something.Do() 的错误返回时，我们进一步缩进。 事实上，语句“ return nil ”在代码中间完全丢失。 else 结构在 Go 和其他语言中作为单一行返回很常见，因为它们要处理中止或退出函数。 我认为他们不能保证缩进我们的其他代码。 翻转 if 语句如果我们要翻译 if 语句（如果你喜欢 ， 就把它们翻过来） ，你可以看到代码变得更加可读： 123456789101112131415161718if !something.OK() &#123; // flipped return errors.New(&quot;something not ok&quot;)&#125;something.Lock()defer something.Unlock()err := something.Do()if err != nil &#123; // flipped return err&#125;stop := StartTimer()defer stop()log.Println(&quot;working...&quot;)doWork(something)&lt;-something.Done() // wait for itlog.Println(&quot;finished&quot;)return nil 在此代码中，我们正在尽早退出，退出代码与正常代码不同。而且， 快乐路径沿着左侧向下保持， 我们缩进只是为了处理错误和边缘情况， 我们的 retutn 声明“ return nil ”在最后一行，并且， 我们有更少的缩进代码块。 促进大型条件块的功能如果你不能避免一个笨重的 else 结构或臃肿的选择切换的情况（我明白了，有时候你不能），那么就考虑把每个结构分解成它自己的功能： 123456789101112func processValue(v interface&#123;&#125;) error &#123; switch val := v.(type) &#123; case string: return processString(val) case int: return processInt(val) case bool: return processBool(val) default: return fmt.Errorf(&quot;unsupported type %T&quot;, v) &#125;&#125; 这比读取大量的处理代码更容易阅读。 分享你的经验如果你同意我的观点，请考虑分享这篇文章 - 随着越来越多的人注册，更好的（更一致的）Go 代码将会出现。 你有一些难以阅读的代码吗？ 为什么不在 Twitter @matryer 上分享它，可以看看我们是否可以找到一个更清洁，更简单的版本。 致谢…评论家戴夫切尼 ， 大卫埃尔南德斯和威廉肯尼迪 。 via: https://medium.com/@matryer/line-of-sight-in-code-186dd7cdea88 作者：Mat Ryer 译者：yuhanle 校对：polaris1119 本文由 GCTT 原创编译，Go语言中文网 荣誉推出 本文由 GCTT 原创翻译，Go语言中文网 首发。也想加入译者行列，为开源做一些自己的贡献么？欢迎加入 GCTT！翻译工作和译文发表仅用于学习和交流目的，翻译工作遵照 CC-BY-NC-SA 协议规定，如果我们的工作有侵犯到您的权益，请及时联系我们。欢迎遵照 CC-BY-NC-SA 协议规定 转载，敬请在正文中标注并保留原文/译文链接和作者/译者等信息。文章仅代表作者的知识和看法，如有不同观点，请楼下排队吐槽","categories":[{"name":"Translate","slug":"Translate","permalink":"https://blog.yuhanle.com/categories/Translate/"},{"name":"Go","slug":"Translate/Go","permalink":"https://blog.yuhanle.com/categories/Translate/Go/"}],"tags":[{"name":"Translate","slug":"Translate","permalink":"https://blog.yuhanle.com/tags/Translate/"},{"name":"Go","slug":"Go","permalink":"https://blog.yuhanle.com/tags/Go/"}]},{"title":"Go 实现对 HTTP 对象的查找","slug":"seeking-around-in-an-http-object","date":"2018-02-24T01:00:00.000Z","updated":"2021-10-21T08:18:48.340Z","comments":true,"path":"2018/02/24/seeking-around-in-an-http-object/","link":"","permalink":"https://blog.yuhanle.com/2018/02/24/seeking-around-in-an-http-object/","excerpt":"已发布：https://studygolang.com/articles/12638 Go 实现对 HTTP 对象的查找想象一下，在 HTTP 服务器上有一个巨大的 ZIP 文件，你想知道里面的内容。你不知道压缩包内是否有你需要的东西，而且你不想下载整个文件。是否可以像执行 unzip -l https://example.com/giant.zip 的操作来查看压缩包的内容呢？ 这并不是一个为了用 Go 展示某些知识的理论问题。实际上，我也不想写一篇文章，除了我想通过那些压缩文件了解如何从 美国专利和商标局（USPTO） 下载大量专利。或者，我认为，能够从这些 tar 文件中获取 1790 年发布的一些专利图像 有多酷？ 去看看。那里有数百个巨大的 ZIP 和 tarfiles 值得探索！","text":"已发布：https://studygolang.com/articles/12638 Go 实现对 HTTP 对象的查找想象一下，在 HTTP 服务器上有一个巨大的 ZIP 文件，你想知道里面的内容。你不知道压缩包内是否有你需要的东西，而且你不想下载整个文件。是否可以像执行 unzip -l https://example.com/giant.zip 的操作来查看压缩包的内容呢？ 这并不是一个为了用 Go 展示某些知识的理论问题。实际上，我也不想写一篇文章，除了我想通过那些压缩文件了解如何从 美国专利和商标局（USPTO） 下载大量专利。或者，我认为，能够从这些 tar 文件中获取 1790 年发布的一些专利图像 有多酷？ 去看看。那里有数百个巨大的 ZIP 和 tarfiles 值得探索！ 在 ZIP 文件中最后的位置，有一个目录。因此在本地磁盘上，“unzip -l” 就像“寻求最终结果，找到 TOC，解析并打印它”一样简单。事实上，我们可以知道 Go 是如何处理的，因为在 zip.NewReader 函数 需要传入一个文件路径。至于 TAR 文件，它们被设计用于磁带流式传输和内存稀少的时候，因此它们的目录在文件本身之间交错排列。 但我们不在本地，要从 URL 中读取内容对我们来说很有挑战。该怎么办？从哪里开始？ 我们有几件事需要考虑，然后我们可以规划接下来的方向。寻找和读取 HTTP 文件也就是要找到和读取 Range 标头。那么，USPTO 服务器是否支持 Range 头呢？这很容易检查，使用 curl 和 HTTP HEAD 请求： 12345678910$ curl -I https://bulkdata.uspto.gov/data/patent/officialgazette/2017/e-OG20170103_1434-1.zipHTTP/1.1 200 OKDate: Mon, 11 Dec 2017 21:10:26 GMTServer: ApacheLast-Modified: Tue, 03 Jan 2017 11:58:45 GMTETag: \"afb8ac8-5452f63e0a82f\"Accept-Ranges: bytesContent-Length: 184257224X-Frame-Options: DENYContent-Type: application/zip 请注意那里的 “Accept-Ranges” 标头，它表示我们可以向它发送字节范围。Range 头允许您像随机访问读取操作系统的一样操作 HTTP。（例如 io.ReaderAt 接口） 因此理论上可以选择从 Web 服务器下载其中包含元数据（目录）的文件部分来决定下载哪些字节。 现在我们需要写一个处理 ZIP 文件格式的方法，它可以让我们使用具有 Range 头部的 HTTP 的 GET 请求，只读取元数据的方式，实现替换“读取下一个目录头文件”的某个部分。这就是 Go 的 archive/zip 和 archive/tar 包的实现！ 正如我们前面所说，zip.NewReader 正在琢磨什么位置开始查找。然而，当我们看看 TAR 时，我们发现了一个问题。tar.NewReader 方法需要一个 io.Reader。io.Reader 的问题在于，它不会让我们随机访问资源，就像io.ReaderAt 一样。它是这样实现的，因为它使 tar 包更具适应性。特别是，您可以将 Go tar 包直接挂接到 compress/gzip 包并读取 tar.gz 文件 - 只要您按顺序读取它们，而不是像我们希望的那样跳过。 那么该怎么办？使用源码。环顾四周，找找下一个方法。这就是我们期望它能够找到下一个元数据的地方。在几行代码内，对于 skipUnread 函数， 我们发现一个有趣的调用。在那里，我们发现一些非常有趣的东西： 12345678910111213// skipUnread skips any unread bytes in the existing file entry, as well as any alignment padding.func (tr *Reader) skipUnread() &#123; nr := tr.numBytes() + tr.pad // number of bytes to skip tr.curr, tr.pad = nil, 0 if sr, ok := tr.r.(io.Seeker); ok &#123; if _, err := sr.Seek(nr, os.SEEK_CUR); err == nil &#123; return &#125; &#125; _, tr.err = io.CopyN(ioutil.Discard, tr.r, nr)&#125;// Note: This is from Go 1.4, which had a simpler skipUnread than go 1.9 does. 这里表示：”如果 io.Reader 实际上也能够搜索，那么我们不是直接读取和丢弃，而是直接找到正确的地方。“找到了！我们只需要将 tar 文件传给 io.Reader。NewReader 也满足 io.Seeker的功能（因此，它是一个io.ReadSeeker）。 所以，现在请查看包 github.com/jeffallen/seekinghttp，就像它的名字所暗示的那样，它是一个用于在 HTTP 对象（Github 上的源代码 中查找的软件包。 这个软件包不仅实现了 io.ReadSeeker，还实现了 io.ReaderAt。 为什么？因为，正如我上面提到的，读取 ZIP 文件需要一个 io.ReaderAt。它还需要传递给它的文件的长度，以便它可以查看目录文件的末尾。HTTP HEAD 方法可以很好地获取 HTTP 对象的 Content-Length，而不需要下载整个文件。 用于远程获取 tar 和 zip 文件目录的命令行工具位于 remote-archive-ls 中。打开 “-debug” 选项用来查看日志。将 Go 的标准库作为 TAR 或 ZIP 阅读器“回调”到我们的代码中，并在这里请求几个字节，这里有几个字节是很有趣的。 在我第一次运行这个程序后不久，我发现了一个严重的缺陷。这是一个示例运行结果： 123456789101112131415161718192021222324252627282930313233343536373839404142$ ./remote-archive-ls -debug 'https://bulkdata.uspto.gov/data/patent/grant/multipagepdf/1790_1999/grant_pdf_17900731_18641101.tar'2017/12/12 00:07:38 got read len 5122017/12/12 00:07:38 ReadAt len 512 off 02017/12/12 00:07:38 Start HTTP GET with Range: bytes=0-5112017/12/12 00:07:39 HTTP ok.File: 00000001-X009741H/2017/12/12 00:07:39 got read len 5122017/12/12 00:07:39 ReadAt len 512 off 5122017/12/12 00:07:39 Start HTTP GET with Range: bytes=512-10232017/12/12 00:07:39 HTTP ok.File: 00000001-X009741H/00/2017/12/12 00:07:39 got read len 5122017/12/12 00:07:39 ReadAt len 512 off 10242017/12/12 00:07:39 Start HTTP GET with Range: bytes=1024-15352017/12/12 00:07:39 HTTP ok.File: 00000001-X009741H/00/000/2017/12/12 00:07:39 got read len 5122017/12/12 00:07:39 ReadAt len 512 off 15362017/12/12 00:07:39 Start HTTP GET with Range: bytes=1536-20472017/12/12 00:07:39 HTTP ok.File: 00000001-X009741H/00/000/001/2017/12/12 00:07:39 got read len 5122017/12/12 00:07:39 ReadAt len 512 off 20482017/12/12 00:07:39 Start HTTP GET with Range: bytes=2048-25592017/12/12 00:07:39 HTTP ok.File: 00000001-X009741H/00/000/001/us-patent-image.xml2017/12/12 00:07:39 got seek 0 12017/12/12 00:07:39 got seek 982 12017/12/12 00:07:39 got read len 422017/12/12 00:07:39 ReadAt len 42 off 35422017/12/12 00:07:39 Start HTTP GET with Range: bytes=3542-35832017/12/12 00:07:39 HTTP ok.2017/12/12 00:07:39 got read len 5122017/12/12 00:07:39 ReadAt len 512 off 35842017/12/12 00:07:39 Start HTTP GET with Range: bytes=3584-40952017/12/12 00:07:39 HTTP ok.File: 00000001-X009741H/00/000/001/00000001.pdf2017/12/12 00:07:39 got seek 0 12017/12/12 00:07:39 got seek 320840 12017/12/12 00:07:39 got read len 1842017/12/12 00:07:39 ReadAt len 184 off 324936...etc... 你能看到问题吗？这是很多 HTTP 事务！ TAR reader 正在一次一点点地完成 TAR 流，发出一小串 bit。所有这些短的 HTTP 事务在服务器上都很难实现，并且对于吞吐量来说很糟糕，因为每个 HTTP 事务都需要多次往返服务器。 当然，解决方案是缓存。读取TAR读取器要求的前 512 个字节，而不是读取其中的 10 倍，以便接下来的几个读取将直接从缓存中获取。如果读取超出了缓存的范围，我们假设其他读取也将进入该区域，并删除整个当前缓存，以便用当前偏移量的 10 倍填充它。 TAR 阅读器发送大量小读数的事实指出了有关缓冲的一些非常重要的事情。将 os.Open 的结果直接发送给 tar。NewReader 不是很聪明，尤其是如果你打算跳过文件寻找元数据。尽管 * os.File 实现了 io.ReadSeeker，我们现在知道 TAR 将会向内核发出大量的小系统调用。该解决方案与上面的解决方案非常相似，可能是使用 bufio 包来缓冲 * os.File，以便 TAR 发出的小数据将从 RAM 中取出，而不是转到操作系统。但请注意：它真的是解决方案吗？bufio.Reader 是否真的实现了 io？ReadSeeker 和 io.ReadAt 就像我们需要的一样？ （破坏者：它没有;也许你们有读者想告诉我们如何使用下一个的替代品 bufio 加速 Go 的 tar？ 我希望你喜欢通过标准库和 HTTP，看看如何与标准库一起工作，以帮助它实现更多的功能，以便它可以帮助你完成你的工作这个小小的旅程。当你实现 io.Reader 和朋友时，你有机会走到你所调用的库的幕后，并从他们的作者从未期望的地方给他们提供数据！ via：https://blog.gopheracademy.com/advent-2017/seekable-http/ 作者：Jeff R. Allen译者：yuhanle校对：Unknwon 本文由 GCTT 原创编译，Go中文网 荣誉推出","categories":[{"name":"Translate","slug":"Translate","permalink":"https://blog.yuhanle.com/categories/Translate/"},{"name":"Go","slug":"Translate/Go","permalink":"https://blog.yuhanle.com/categories/Translate/Go/"}],"tags":[{"name":"Translate","slug":"Translate","permalink":"https://blog.yuhanle.com/tags/Translate/"},{"name":"Go","slug":"Go","permalink":"https://blog.yuhanle.com/tags/Go/"}]},{"title":"iOS 真机调试如何安装 WebDriverAgent","slug":"how-to-install-web-driver-agent-on-device","date":"2018-01-03T10:30:47.000Z","updated":"2021-10-21T08:18:48.337Z","comments":true,"path":"2018/01/03/how-to-install-web-driver-agent-on-device/","link":"","permalink":"https://blog.yuhanle.com/2018/01/03/how-to-install-web-driver-agent-on-device/","excerpt":"近期，微信跳一跳外挂火了，看了作者的思路和教程，感觉挺简单，不过在实现（照葫芦画瓢）的过程中，遭遇到不少问题。 其中之一便是，真机调试 WDA，参考 iOS 真机如何安装 WebDriverAgent · TesterHome，下面就按照这篇教程，各个击破真机调试WDA 的问题： 开始首先按照教程，尽量更新下Xcode 的版本，从github 上下载WDA 的最新版本，直接克隆到本地","text":"近期，微信跳一跳外挂火了，看了作者的思路和教程，感觉挺简单，不过在实现（照葫芦画瓢）的过程中，遭遇到不少问题。 其中之一便是，真机调试 WDA，参考 iOS 真机如何安装 WebDriverAgent · TesterHome，下面就按照这篇教程，各个击破真机调试WDA 的问题： 开始首先按照教程，尽量更新下Xcode 的版本，从github 上下载WDA 的最新版本，直接克隆到本地 1git clone https://github.com/facebook/WebDriverAgent.git 切换到WDA 根目录，运行初始化脚本 12cd WebDriverAgent./Scripts/bootstrap.sh 以上脚本是安装依赖库，同时使用npm 打包响应的js 文件。感兴趣的同学可以浏览脚本文件，同级目录下还有一个build.sh，也可以直接执行该脚本来编译安装WDA。当然，初次接触，希望一步步操作的话会好一些。 如果中途出现错误，需要先解决，否则接下来的操作都无法进行。 编译运行接下来，通过Xcode 打开WebDriverAgent.xcodeproj 这个文件。 可以先尝试编译一下，方便定位目前存在的问题，使用组合键或者通过鼠标操作 1command + b 这个时候，肯定会有提示配置证书的问题，真机调试证书是必须设置的。可以设置个人开发者免费证书，或者其他付费证书。 然后选择WebDriverAgentRunner 这个Target 和 真机设备，执行测试。组合键command+u，或从菜单栏Product 中通过鼠标操作 一切正常的话，手机上会出现一个无图标的WebDriverAgent应用，启动之后，马上又返回到桌面。这是很正常的不要奇怪。 应用教程中的原话，上述现象正常，但是也有可能会在控制台报错，从而无法打印出ip 地址。 当把所有的流程重新捋一遍，你会发现，根本发现不了哪一步做错了，我遇到的情况就是，一直停留在控制台的那里，不会出现奇迹。经过一番搜索，发现有个帖子里的警告提示，我决定放手一搏！ 你们以为这样就能运行吗？ 并不是！最关键一步来了： 你要用数据线连着电脑重启你的手机！！！！ 你要用数据线连着电脑重启你的手机！！！！ 你要用数据线连着电脑重启你的手机！！！！ 重要的话要说三遍！ 反正是在保证数据线连接的情况下，重启一下手机，然后重新build 就成功看到ip 地址！而且在以后操作中，这种情况还会复现，所以重启手机吧，不用浪费无辜的时间研究~ 通过上面给出的IP和端口，加上/status合成一个url地址。例如http://10.0.0.1:8100/status，然后浏览器打开。如果出现一串JSON输出，说明WDA安装成功了。 端口转发有些国产的iPhone机器通过手机的IP和端口还不能访问，此时需要将手机的端口转发到Mac上。关于这个问题，我是通过端口转发才看到效果，所以你也应该会遇到同样的问题。 12$ brew install imobiledevice$ iproxy 8100 8100 [4c47766e78f9d84e1da55b07d69f2747e9fb4f71] 使用iproxy –help 可以查到更具体的用法。 这时通过访问http://localhost:8100/status 确认WDA是否运行成功。 而inspector的地址是http://localhost:8100/inspector， inspector是用来查看UI的图层，方便写测试脚本用。 注：端口转发后，域名不再是IP 地址，而是你的本机IP或者使用localhost+ 端口号 最终效果完成上述操作以后，可以随意开启应用内的某个应用，就能看到如下效果。 这里结合 Appium Desktop 一起食用，效果更佳~ Good luck!!! 实战相信你会对这个感兴趣，通过WDA 做自动化测试，恩！ 接下来演示一下怎么用ATX打开iPhone自带的计时器，开始然后退出 1234567891011#! /usr/local/bin/python3# -*- coding: utf-8 -*-import atxd = atx.connect(\"http://localhost:8100\")d.start_app(\"com.apple.mobiletimer\")d(text=u'计时器').click()d(text=u'开始计时').click()d(text=u'取消').click()d.stop_app() 执行以上代码即可体验 结尾最后墙裂推荐基于Python自动化框架地址 https://github.com/NetEaseGame/ATX Xcode问题多多，愿WDA与你同在。 参考链接ATX 文档 - iOS 真机如何安装 WebDriverAgent Macaca App Inspector 2.0 发布 Appium Desktop 简单介绍 —— xcodebuild failed with code 65 解决 WebDriverAgent 天坑记 启动 WebDriverAgent 后再启动 appium，运行脚本一直卡在 Waiting for WebDriverAgent to start on device ATX 支持 iOS10 手机测试 方法说明","categories":[{"name":"UI Auto Test","slug":"UI-Auto-Test","permalink":"https://blog.yuhanle.com/categories/UI-Auto-Test/"}],"tags":[{"name":"WDA","slug":"WDA","permalink":"https://blog.yuhanle.com/tags/WDA/"},{"name":"UI Test","slug":"UI-Test","permalink":"https://blog.yuhanle.com/tags/UI-Test/"}]},{"title":"Xcode9.2 编译在iOS8.1 系统上图片显示异常","slug":"xocde9-2-and-iOS-8-1-image-unnormal","date":"2017-12-09T01:52:47.000Z","updated":"2021-10-21T08:18:48.340Z","comments":true,"path":"2017/12/09/xocde9-2-and-iOS-8-1-image-unnormal/","link":"","permalink":"https://blog.yuhanle.com/2017/12/09/xocde9-2-and-iOS-8-1-image-unnormal/","excerpt":"最新消息 目前 xcode 9.3 已经解决了该问题","text":"最新消息 目前 xcode 9.3 已经解决了该问题 Asset CatalogKnown IssuesWhen using Xcode 9.2 to create apps that deploy to iOS 8 and later, images in the asset catalog may be corrupted when viewed on devices running iOS 8.3 and earlier. (35379713)Workaround: Build the app using Xcode 9.1, or use Xcode 9.2 and set the deployment target to iOS 8.4 or later. 趁着下载 Xcode 9.1 的空隙，在周末的早晨记录一下这个坑，希望能解决相同遭遇同行的困惑。 始因昨天刚发布了适配 iPhone X 的最新版本，之所以使用 Xcode 9.2 打包，是因为早期的适配，通过 Xcode 8.2 打包，安装到 iPhone X 上显示的效果是没有适配。 这个也是无法解释的，我们开发使用的 Xcode 9，在适配过程中没有遇到该问题，总是升级就对了。 刚好最近苹果爹发布了 Xcode 9.2，就索性升级到最新版本。 持续化集成就是方便，代码提交以后，喝杯咖啡的工具，就上传成功，等待审核。 也就是在昨天中午，收到审核通过的提醒，很奇怪，这个时候应该是他们休息的时间。 然后，就非常肯定，因为在适配的过程中，特意找了两个 iPhone X 的用户帮助测试体验。随着审核通过，就很快发布出去。 问题大概下午3点钟，距离发布版本只过了 3 个小时左右。收到客服妹子的一个大写的问号。 这一瞬间，整个人都是懵的，慌忙让用户重启 APP，重启系统，升级系统，最后被用户拒绝掉。 既然是必现的问题，不能将问题推到升级系统上，该解决还是要尽快解决的。 接着就开始着手另外一个项目，晚上回到家开始思考，问题存在的版本近期究竟改了什么内容。同时也下载了 iOS8.1 的模拟器，使用最新版本的 Xcode 运行看了下效果，确实如此是复现的。 所以，要马上改变态度，和客服同志搞好关系，早点认错才能走得更远。 回忆1. 删掉LaunchScreen.sb 文件为了适配 iPhone X 的启动图，同时在启动后使用启动图做了简单的效果，决定使用 LaunchImage 的方式设置启动图。 在更改代码后，尝试了一下修改结果，依然是非正常的。 效果如下，丝毫没有改变： 2. Xcode 版本升级这次的改动比较小，所以在排除上述的改动后，直接想到的就是可能就是这个问题，但是很少会怀疑苹果爹会挖这么大的坑，让开发者跳进去。 不管如何，降级版本试试就知道是不是这个原因。 Xcode9.2 Xcode9.1 通过上述对比，确定问题就处在 Xcode 版本上。 解决方案1. 等苹果爹更新如果苹果爹一直没注意到这个问题，或者没有人提，谁知道还要等多久？关于此问题，我已经向苹果爹提交了 bug，期待后续修复： ProblemID=35948702 2. 先降级 Xcode确切的说，这是目前最快捷的一个方式，保证没有问题 3. 改变图片资源存储图片不要放在 asset 里面，方法放在bundle 里面就没问题。不知道是 Xcode9.2 bug 还是没设置相关属性 4. 资源问题优化换成9.1，不过我发现 @2x, @3x 这三个图标都填满的就没这 BUG，只放一个才有 参考链接 Xcode9.2 运行iOS8.1图片异常","categories":[{"name":"tools","slug":"tools","permalink":"https://blog.yuhanle.com/categories/tools/"}],"tags":[{"name":"tips","slug":"tips","permalink":"https://blog.yuhanle.com/tags/tips/"}]},{"title":"升级 macOS High Sierra 后与 Cocoapods 的兼容问题","slug":"macos-high-sierra-with-cocoapods","date":"2017-12-06T03:42:36.000Z","updated":"2021-10-21T08:18:48.338Z","comments":true,"path":"2017/12/06/macos-high-sierra-with-cocoapods/","link":"","permalink":"https://blog.yuhanle.com/2017/12/06/macos-high-sierra-with-cocoapods/","excerpt":"当你发觉自己没有问题的时候，那就尝试着重启一下，万一问题解决了呢？ 最近实在厌烦苹果推送了 macOS High Sierra 更新，于是一下班前打开电脑更新系统。过程还算顺利，网络很快，大概 10左右就下载完毕，升级过程中卡死，随后就行下班回家，让其升级了一个夜晚 不过在使用 Cocoapods 的时候还是遇到了问题：","text":"当你发觉自己没有问题的时候，那就尝试着重启一下，万一问题解决了呢？ 最近实在厌烦苹果推送了 macOS High Sierra 更新，于是一下班前打开电脑更新系统。过程还算顺利，网络很快，大概 10左右就下载完毕，升级过程中卡死，随后就行下班回家，让其升级了一个夜晚 不过在使用 Cocoapods 的时候还是遇到了问题： 123406-Dec-2017 09:28:38 /Users/tianyi/bamboo-agent-home/temp/IOS-PB-JOB1-382-ScriptBuildTask-1550561307052749322.sh: /usr/local/bin/pod: /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/bin/ruby: bad interpreter: No such file or directory06-Dec-2017 11:24:58 env: ruby_executable_hooks: No such file or directory06-Dec-2017 11:30:11 /Users/tianyi/bamboo-agent-home/temp/IOS-PB-JOB1-382-ScriptBuildTask-5355633338674781643.sh: line 7: pod: command not found06-Dec-2017 11:31:27 env: ruby_executable_hooks: No such file or directory 看起来是 Cocoapods 依赖的 Ruby 版本问题，Google 一下，发现已经有人在 Cocoapods 的 repo 下提了这个 issue，下面也有开发者给出了解决方案：重新安装 Cocoapods. Pod 命令需要用到 2.0 版本的 Ruby 解释器 /System/Library/Frameworks/Ruby.framework/Versions/2.0，而 macOS High Sierra 将系统的 Ruby 解释器升级到了 2.3 /System/Library/Frameworks/Ruby.framework/Versions/2.3，因此执行 pod 命令的时候由于找不到 Ruby 解释器而报错。 于是按照提示重装 Cocoapods： 1$ sudo gem install cocoapods 安装完成后继续执行 pod install，又报了同样的错误。我决定继续重装一次 Cocoapods，不过这次加上 –verbose 参数，看看安装过程中做了哪些操作。log 太长我就不贴了，不过注意到最后输出的 pod 命令位置似乎跟上面执行 which pod 输出有点不一样，它是 /usr/bin/pod，而 which pod 的输出是 /usr/local/bin/pod，再看一下我的 $PATH 路径： 12$ echo $PATH/Users/tianyi/.rvm/gems/ruby-2.4.1/bin:/Users/tianyi/.rvm/gems/ruby-2.4.1@global/bin:/Users/tianyi/.rvm/rubies/ruby-2.4.1/bin:/Users/tianyi/.rvm/bin:/Library/Java/JavaVirtualMachines/jdk1.8.0_91.jdk/Contents/Home/bin:/Users/tianyi/.jenv/shims:/Users/tianyi/.jenv/bin:/opt/subversion/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Applications/Server.app/Contents/ServerRoot/usr/bin:/Applications/Server.app/Contents/ServerRoot/usr/sbin:/usr/local/go/bin:/Users/tianyi/bin:/Users/tianyi/goProject/bin:/usr/local/go/bin:/usr/local/Cellar/nginx/1.12.0/bin:/usr/local/mysql/bin 可以看到在我的 $PATH 环境变量里，/usr/local/bin 的优先级是高于 /usr/bin 的，因此当这两个地方都存在一个名叫 pod 的命令时，系统优先执行 /usr/local/bin/pod，于是错误就这么产生了。因此我直接删除 /usr/local/bin/pod 文件，再执行 pod install –verbose，这一次果然安装成功了。 这个问题应该是由于 Cocoapods 改变了安装路径导致的，记得 macOS 启用 System Integrity Protection 之后 Cocoapods 的安装路径也修改过，这次应该也是类似的问题吧，由于 $PATH 这个环境变量的问题，导致老版本的 pod 命令优先被执行。 事情至此还未结局 本地执行pod 指令已经没问题了，但是我们通过Bamboo 集成，使用脚本打包，却一直重复前面的错误无法自拔。 重启bamboo 服务，依然不能解决问题 尝试着使用重启治百病的手段，电脑关机重启试试看！ 祈祷中…🙏 2017年12月6日午时三刻更 说了你可能不相信，重启电脑后，一切问题都好了~ 更新 解决macOS Sierra下注册机无法运行的问题 很多软件都不兼容了「安全性与隐私」设置中「任何来源」选项消失几乎所有注册机都用不了 恢复任何来源选项ps：如果系统升级前就已经选择了任何来源，升级后还会正常显示 打开终端(Terminal.app)执行sudo spctl --master-disable “任何来源”恢复~","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.yuhanle.com/categories/iOS/"}],"tags":[{"name":"tips","slug":"tips","permalink":"https://blog.yuhanle.com/tags/tips/"}]},{"title":"伙计们，Go 并没有那么简单","slug":"go-is-not-very-simple-folks","date":"2017-12-04T01:00:00.000Z","updated":"2021-10-21T08:18:48.336Z","comments":true,"path":"2017/12/04/go-is-not-very-simple-folks/","link":"","permalink":"https://blog.yuhanle.com/2017/12/04/go-is-not-very-simple-folks/","excerpt":"已发布：https://studygolang.com/articles/12330 伙计们，Go 并没有那么简单出于好奇，我最近开始接触一些 Go 的代码。我之前对它有一些了解，但是从来没有尝试去写（没有需求）。但是现在我们团队选择使用 Go 来开发一个项目，所以我觉得这是一个获得实际经验的好机会。 到目前为止，关于这门语言我已经学习了很长时间。在这个博文的末尾，我会写更多关于 Go 的干货。","text":"已发布：https://studygolang.com/articles/12330 伙计们，Go 并没有那么简单出于好奇，我最近开始接触一些 Go 的代码。我之前对它有一些了解，但是从来没有尝试去写（没有需求）。但是现在我们团队选择使用 Go 来开发一个项目，所以我觉得这是一个获得实际经验的好机会。 到目前为止，关于这门语言我已经学习了很长时间。在这个博文的末尾，我会写更多关于 Go 的干货。 社区实际上并不那么令人愉快，特别是那些因为它的简单性而主张使用 Go 的人。似乎简单已经成为 Go 社区中的一个流行语，许多人反复重复提到这点，却没有给出太多实际的想法。 这对我来说似乎很不幸，因为在我看来，Go 是一个“极其简单的语言”： 不应该作为考虑使用 Go 的主要原因 从他们的关注点中找到其他更有利的推荐理由 甚至不是真的（不是真的简单） 在这篇文章中，我想围绕 Go 来分析一些简单观点。 在深入之前，我想强调一件事情：这篇文章并不是对 Go 的批评，而是一种对 Go 的宣传和倡导的方式。有时候，我可能会批评这个语言的某个方面，但这不是我们关注的重点，我只会试图用一种非正式的、事实的，每种语言都会涉及的方式来讲述。 我来自哪里出于工作和业余爱好，我同时使用多种编程语言。我不赞成有“最喜欢的语言”的概念。过去我曾经有过一些最喜欢的语言，但这种认识往往是一时的情感，随着时间推移，会发生变化。 在我的工作中，我使用 C++ 和 Python 写大型服务的后端代码。过去我曾经在一个你可能知道的操作系统上工作，而且我也做了嵌入式工作。在业余项目中，我做了其他各种事情。 我并不是夸耀什么（我不是一个专家），我只是想表明，我在编程的许多领域至少有一些见解，而且我一直努力保持开放的心态。 所以，不要着急，让我们开始讨论正题，看看几个观点。 1. “与主流语言相比，Go 的关键字非常少”我从一个最常见的例子开始。当推广 Go 时，这会是大家的口头禅。 首先，即使它是真实的，我不知道为什么关键字数量会是判断一个语言的学习曲线或复杂性的重要依据。当然，如果有成千上万的关键字，这可能是一个问题。但是大多数语言最多只有几十个关键字，这种规模下，关键字的多少是无关紧要的。 我还没有听到有人因为关键字的数量而抱怨某门语言 其次，Go 所谓的“很少”的关键字实际上只不过是一个聪明律师的伎俩（也许，我甚至会认为这是 Go 的虚假广告）。Go 规范 列出了 25 个关键字，这的确比大多数语言要少些。但在我看来，Go 并没有比其他语言关键字表示更少的概念，Go 虽然没有这些关键字，但相应的概念依然是语言的一部分（即实际的复杂性保持不变）。 为了说明我的意思，请考虑一个 while 循环。 Go 没有这个关键字，这是真的，但它仍然有一个 while 循环，文档甚至是这样说的，它的目的只是重用其他关键字。 另一个这样的例子是 private 和 public。 Go 没有这些关键字，但它仍然有 private 和 public，它只是使用字母大小写而不是关键字。 用来删减关键字的另一个技巧叫 预定义标识符（Predeclared identifiers），在技术上它不是关键字，但是在实践中仍然需要它们，创建一个和它同名的变量仍然不是一个好主意，因此，最后看来…它们基本上是关键字。此外，其中一些预定义标识符是其他语言的关键字，因此仅将它们与 Go 的关键字列表进行比较是非常不公平的。就像苹果和桔子。 2. 接收者参数接受者参数对我来说有些古怪。看起来 Go 似乎并不建议使用 this 和 self，但是仍然需要方法，所以就存在 “接收者参数”，除了方法签名看上去很奇怪之外，它们基本上是一样的。 接收者参数有一个问题，当访问一个方法时，我需要知道接收者参数（这是任意的）的名称，以明确这个方法的作用。因为缺少关键字（译注：如 this），语法高亮成为一个问题。（看吧？这是如何减少关键字实际上使事情变得更加复杂的例子。）这有点像 C++ 中的隐式 this。 这里有一个新人容易混淆的例子。 恕我直言，最简单、最直接的方式来表达一个接收器是 UFCS，而不是 C++ 或 Go 的方式。但就像我说的，我不是在抱怨 Go，我真的不介意接受者参数的观点（如果我忍受不了 C++ 的怪异，我可以忍受 Go 的）。 3. 函数返回值如果接收参数不够，函数甚至能够通过各种形式的返回值来声明。通常语言允许你通过 return 语句返回函数中的一个值。而在 Go 语言中，你可以返回多个值（我认为可以用更优雅的方式通过元组来解决，但是就这样吧）。除此之外，还有命名返回值。在我看来，并不是一个好主意，因为它允许我们在那些很难找到返回值的地方写上晕头转向的代码。结合接收方参数，您可以创建这样的函数签名： 123func (f Foobar) Something(a int, b int, c int) (foo int, bar int) &#123; // ...&#125; 这是有效的 Go 代码。如您所见，有三个参数。我真的不希望任何人试图选择这个“简单”，因为这个语法除了简单，什么也不是。 4. “没有继承”Go（或许只是社区）似乎很反对“传统的 OOP”（不管这是指哪个，可能是 Java 或者 C++），我记得有人说 Go 没有继承是一件好事。 除此之外，Go 有一个功能叫做嵌入，这个文档以及一些博客文章声称 Go 没有继承。我试着用各种方式使用它，我没法认为 Go 反对继承。上面链接的文档说： 还有种区分内嵌与子类的重要手段。当内嵌一个类型时，该类型的方法会成为外部类型的方法，但当它们被调用时，该方法的接收者是内部类型，而非外部的。 有差别吗？继承通常以相同的方式工作，继承的方法也对内部类型起作用。 在我看来，在 Go 中，真正唯一不同的是，多态性从结构中解耦。你需要使用接口来使用多态性。但一旦你做了，做的事情和传统的 OOP 非常相似，包括方法覆盖 - 这里是个演示。 关于 Go，有件事令我很惊讶 —— 这门所谓简单的语言 —— 你甚至可以实现多重继承。确实很糟糕。 golang-nut 的邮件列表中，有人提到，Go 并不能很好的处理继承的歧义。我已经调整了其中提及的代码，以便它展示了著名的“可怕的钻石问题”（Dreaded diamond problem）： 123456789101112131415161718192021222324252627282930313233package mainimport \"fmt\"type T1 struct &#123; T2 T3&#125;type T2 struct &#123; T4 foo int&#125;type T3 struct &#123; T4&#125;type T4 struct &#123; foo int&#125;func main() &#123; t2 := T2&#123; T4&#123; 9000 &#125;, 2 &#125; t3 := T3&#123; T4&#123; 3 &#125; &#125; fmt.Printf(\"foo=%d\\n\", t2.foo) fmt.Printf(\"foo=%d\\n\", t3.foo) t1 := T1&#123; t2, t3, &#125; fmt.Printf(\"foo=%d\\n\", t1.foo)&#125; 在线运行以上代码 上面的代码没有任何编译时警告或者错误。这是 C++ 的类似的代码，你可以看到，它编译不通过，因为存在歧义。 结果会如何？首先，我认为具有多重继承功能，几乎不能在描述该编程语言时使用“简单”一词。在我看到上面的代码后，没有人能说服我，Go 是最简单的语言之一，甚至连简单语言都不算。甚至没有其他一些你可以用嵌入来做的事情，比如通过指针嵌入或者通过指针嵌入接口。 （我甚至不确定这些功能的真正含义。） 其次，我想做一个简短、对 Go 语言本身的批评。不处理这样的歧义似乎是一个设计或者实现错误。甚至连 C++ 都没有如此疯狂，让这种代码编译通过。这足以告诉你一些事情。 5. 错误处理各种错误处理通常会导致一个巨大的口水战。我不想谈那件事。我曾经在不同的语言中使用过所有常见的错误处理风格（我认为），我也不喜欢所有这些语言。我认为，错误处理无论什么一直是一个 PITA（译注：应该是国外的一种比喻）。把一种风格换成另一种风格，你只需把一套问题换成另一套。没有好的方法。 回到简单的话题：Go 让我选择不使用异常，这使事情更简单了。多个返回值的特征不能使事情变得简单，这意味着不能返回一个错误或成功的结果，你可以返回所有值或者都不返回（CS 术语，你可以说这个问题是一个产品类型而不是总和式的用法）。事实上，我看过的许多对于新人的代码审查。 如果 Go 不允许多个返回值，而有一些合适的或者喜欢的类型，在我看来，这会使事情变得更简单。出于同样的原因，在 Go 中忽略错误或者不向向调用者或其他适当目的地报告错误是相当容易的。 另一不简单的是 panic。不要误解我的意思，我理解它在 Go 中存在的原因以及它的用处，事实上，其他语言也有类似的处理。我只是提出来作为反对简单性的一个论据。恕我直言，对于一个新人，很可能会混淆 error 和 panic 之间的区别，以及什么时候适合用什么。 6. 泛型这个主题和错误处理比起来，可能是一个更大的蠕虫。 和 errors 一样，我只想考虑一下这里的复杂性或者简单性。Go 社区的许多人似乎认为，泛型的本质上是复杂的（=坏，嗯嗯嗯咳），有这样或那样的巨大开销。这在某种程度上是事实，但我不认为它像有些人描述的那么糟糕。似乎那些人已经经历了 C++ 模板的痛苦，从那以后，无论何时提及泛型，都会遭受 PTSD（创伤后应激障碍） 的攻击。 看到这里的人，泛型不是一个怪物。它们当然绝对不应该像 C++ 那样复杂（或者其他一些奇怪的语言）。我的意思是，甚至前端的人都用泛型工作了一段时间（TypeScript, Flow, …），如果他们不害怕泛型，其他程序员应该是没有理由害怕：）（对不起，前端开发者，只是开个玩笑。） 人们还没有意识到，如果正确地使用泛型，它可以使许多类型和函数的使用更加简单。例如，考虑 Go 中的堆接口。这就是从一个堆中声明这个接口的方式： 12popped := heap.Pop(&amp;someheap)myfoo := popped.(*Foo) // ZOMG what just happened here? 对新人解释这些，包括 panic 的问题。也许可以考虑一下，如果他们没有真正把整个 interface{} 搞对，那么会发生什么。相比之下： 1myfoo := heap.Pop(&amp;someheap) // myfoo has the correct type 这更容易阅读、更容易解释（你解释它，就像你将解释 map 类型已经存在于 Go！）。而且在编写代码时也更难弄乱。 缺乏泛型是造成额外复杂性的原因，它在 Go 的其他部分也会造成相当多的复杂性，主要是需要存在各种“神奇”的函数/类型。map，slice 和 channel 类型的魔法，以及伴随的 make() 功能，这是它们三个的构造函数。slice 类型既可以作为数组的引用，也可以作为动态数组。（不管发生什么事，“做一件事，并做好它”？） （只是为了提醒大家，我并不介意这些，只是为了不简单的争论而提及它。） 7. 其他我想我已经把主要的简单违反者排除在外了。我的单子上只剩下几个简单的： &lt;- 和 -&gt; 操作符。这些可能只是 channel 类型的方法。 iota - 基本一样，但奇怪的枚举。 内置的复数。 if 支持短语句（有时可能有用，但 if 语法比其他语言中更复杂） 我想就是这样。可能忘记了什么，但我想已经足够了。 那么，我觉得如果不是简单的话，Go 实际上会带来什么呢？ 任务 - “goroutines”这可能看起来有点显而易见，因为 goroutines 是一个经常被提及的特性，就像“简单”一样，所以我觉得需要区分下：我认为这不是通常意义上的并发性，它不能认为是 Go 的优势。不要误解我的意思，Go 的并发性是没问题的。只是说这没有什么特别的。你有 channel，这肯定是好的，但基本上，它们只是像我在别处常用的并发队列。然后你有常规的并发原语，像 mutex，读写锁，条件变量等。你可以同步你的代码，你可能会遇到像许多其他语言一样的竞争条件和死锁。 我喜欢 goroutines（除了明显的事实，它们是轻量级的用户空间线程）是它们可以使用 I/O 的方式 - 调度连接到主机操作系统的低级 I/O API 的方式（如 epoll、kqueue、IOCP…）。这对于程序员来说通常很难做出令人愉快和有用的东西，特别是在编译本地语言的时候。我仍然在这里了解细节，但在我看来，这是一个很好的做法，也是为什么我认为 Go 是未来工程的一个亮点。 正如已经暗示的，我也喜欢 Go 这种编译为本地代码的语言。看到新的语言使用垃圾收集来保持这种不可思议的效果真是太好了。（或其他形式的自动内存管理 - Swift 中有提及） 结论所以，读者们，为什么所有这些都离开了你呢？是 Go 复杂还是其他什么原因？ 当然不是，绝对不像 C++ 或 Haskell 那样复杂。相比之下，Go 的确很简单。另一方面，比较 Go 和其他常见语言（如Java ，JavaScript ，Python 等）的复杂性时，情况就不太清楚了，正如我希望的那样。 （此外，这是一个很难，没有明确定义的任务。） 我可以提供类似的例子。在某些方面，Go 可能比这些语言更简单，有些则不是…大致上我会说它和其他常用语言的平均差不多。我也不认为简单，无论是感觉上还是实际使用中，最终的体验很重要。 最后，这篇文章从哪里来，作者是谁？我不肯定。我还不知道 Go 是否会在我的日常工作中被选为一个（子）项目，或者我是否可能将它用于兴趣爱好项目。我想避免像本文提到的那种教条的社区推广的一份子。有没有意识形态导向的地方呢？ 大家可以随意就此提出建议。 我和 Rust 社区有同样的问题，请不要介意，我也知道离开那些更狂热的支持者会更好。 （Q：“你能否在 Rust 重写你的项目？”A：“迷失了”）也许这就是这些新语言的性质，以及他们为激励人们如此激励阳光的争斗。 via: https://medium.com/@bob.clark_34506/go-is-not-very-simple-folks-3e84220e73c7 作者：The Other Bob译者：yuhanle校对：polaris1119 本文由 GCTT 原创编译，Go 中文网 荣誉推出","categories":[{"name":"Translate","slug":"Translate","permalink":"https://blog.yuhanle.com/categories/Translate/"},{"name":"Go","slug":"Translate/Go","permalink":"https://blog.yuhanle.com/categories/Translate/Go/"}],"tags":[{"name":"Translate","slug":"Translate","permalink":"https://blog.yuhanle.com/tags/Translate/"},{"name":"Go","slug":"Go","permalink":"https://blog.yuhanle.com/tags/Go/"}]},{"title":"GCD 同步异步以及串并行详解","slug":"gcd-sync-parallel","date":"2017-05-02T00:00:00.000Z","updated":"2021-10-21T08:18:48.336Z","comments":true,"path":"2017/05/02/gcd-sync-parallel/","link":"","permalink":"https://blog.yuhanle.com/2017/05/02/gcd-sync-parallel/","excerpt":"GCD是iOS开发多线程中经常使用的技术，先看一下GCD中的常见的术语","text":"GCD是iOS开发多线程中经常使用的技术，先看一下GCD中的常见的术语 描述多个任务之间同一时刻的运行关系： serial（串行） 某一时刻，只执行一个任务 concurrent（并行） 可以同时执行多个任务 侧重描述一个函数的执行完成，对其他任务的影响 (既 是否任务在等待某个函数完成，然后才可以运行)： synchronous（同步） 任务执行完成后reture，（阻塞） asynchronous（异步） 不等待任务执行完成，立即reture，（不阻塞当前） 在GCD中，我们用串行并行描述队列。这就是在描述，该队列里面的所有任务，相互之间在同一时刻，是怎样的运行关系。是指队列内本身的任务运行顺序。 我们还用同步异步，描述某一个任务。比如说任务A是同步执行的。这就是在说，A任务，会阻塞当前任务，直到A结束。这是指不同任务之间的关系，与队列无关，可以是不同队列，也可以是相同队列。 接下来，我们先来看下，GCD里面的不同队列。 Serial Queues在串行队列里，同一时间只能执行一个任务。任务按照被添加进入队列的顺序依次执行。每一个任务只有在前面的任务完成后，才可以开始执行。 系统为我们提供的串行队列 main queue ( dispatch_get_main_queue ) main queue是一个串行队列，有串行队列的一切特性。比较特殊的一点是加入这个队列的任务，都是在主线程执行的。 Concurrent Queues加入并行队列的任务，执行的顺序也是按照任务被加入队列的顺序执行，这是我们唯一可以保证的。每个任务都不用等待之前的任务完成，同一时刻可以多个任务同时执行。 系统同样有一个全局的并发队列 global dispatch queue ( dispatch_get_global_queue ) 这是另一个我们熟悉的并发队列，很多时候我们直接使用这个队列，可以简单处理一些我们需要并发执行的任务。 Custom Queue除了系统提供的全局队列之外，我们还可以自定义串行或者并行的队列。 12dispatch_queue_t mySerialQueue = dispatch_queue_create(&quot;com.mySerialQueue&quot;, DISPATCH_QUEUE_SERIAL);dispatch_queue_t myConcurrentQueue = dispatch_queue_create(&quot;com.myConcurrentQueue&quot;, DISPATCH_QUEUE_CONCURRENT); 上面是几种我们用GCD时，需要使用到的队列。 另外，使用GCD，除了选择正确的队列外，还要关注：我们要执行的任务是同步还是异步执行。 dispatch_async 异步执行dispatch_async 用来用异步的方式执行串行或者并行队列里面的任务，我们来看一下使用 dispatch_async 的几种常见情况： custom Serial Queue：当我们需要执行几个应该串行执行的任务，又不阻塞当前的时候。 12345678910111213// task1 task2 顺序依次执行，同时不阻塞othersdispatch_queue_t mySerialQueue = dispatch_queue_create(&quot;com.mySerialQueue&quot;, NULL);dispatch_async(mySerialQueue, ^&#123; ...task1&#125;);dispatch_async(mySerialQueue, ^&#123; ...task2&#125;);...others main Queue：当我们执行并完成了一段异步的任务，需要回到主线程更新UI的时候，很常见的选择就是使用GCD的 main queue。 custom or global concurrent Queue：这个是我们执行非UI任务的常见选择。要注意的是，加入队列的多个任务之间并发执行，我们无法知道那个任务先完成。 123456789dispatch_queue_t myConcurrentQueue = dispatch_queue_create(&quot;com.myConcurrentQueue&quot;, DISPATCH_QUEUE_CONCURRENT);dispatch_async(myConcurrentQueue, ^&#123; ...task1 dispatch_async(dispatch_get_main_queue(), ^&#123; Update UI &#125;);&#125;); dispatch_sync 同步执行大部分时候我们执行dispatch_sync操作，都要格外小心些。 custom or main Serial Queue： 同步执行串行队列时，要注意防止发生死锁，比如下面的代码: 123456789101112/串行队列中，task2 等待 task1完成，所以不会开始。而task1又完成不了，因为task2还没有执行完(甚至都没有开始)。死锁。 dispatch_queue_t mySerialQueue = dispatch_queue_create(&quot;com.mySerialQueue&quot;, DISPATCH_QUEUE_SERIAL); dispatch_sync(mySerialQueue, ^&#123; ...task1 dispatch_sync(mySerialQueue, ^&#123; ...task2 &#125;);&#125;); concurrent Queue：合理使用可以解决一些并发读写问题。例如 123456789101112//task1 执行结束后，task2才会开始执行。dispatch_queue_t myConcurrentQueue = dispatch_queue_create(&quot;com.myConcurrentQueue&quot;, DISPATCH_QUEUE_CONCURRENT);dispatch_sync(myConcurrentQueue, ^&#123; ...task1 读&#125;); dispatch_async(myConcurrentQueue, ^&#123; ...task2 写&#125;); dispatch_after异步延迟操作。实际上 dispatch_after 就像一个延迟执行的 dispatch_async。 12345double delayInSeconds = 1.0;dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * NSEC_PER_SEC)); dispatch_after(popTime, dispatch_get_main_queue(), ^(void)&#123;&#125;);","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.yuhanle.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.yuhanle.com/tags/iOS/"},{"name":"GCD","slug":"GCD","permalink":"https://blog.yuhanle.com/tags/GCD/"}]},{"title":"GCD 同步操作之 Resource Competition","slug":"gcd-sync-barriers-groups-semaphore","date":"2017-04-28T00:00:00.000Z","updated":"2021-10-21T08:18:48.335Z","comments":true,"path":"2017/04/28/gcd-sync-barriers-groups-semaphore/","link":"","permalink":"https://blog.yuhanle.com/2017/04/28/gcd-sync-barriers-groups-semaphore/","excerpt":"在学会简单的使用GCD处理多线程之后，我们来再深入了解下GCD对多线程的一些同步控制。","text":"在学会简单的使用GCD处理多线程之后，我们来再深入了解下GCD对多线程的一些同步控制。 dispatch barriers在使用 Concurrent Queue 的时候，有时候我们希望队列中的某项任务，能够被串行执行，来避免资源竞争等多线程问题。比如遇到读写问题，这时候我们就需要使用 dispatch barriers。来保证即使在并行队列中，对某个对象的读和写操作，在同一时刻，只有一个可以被执行。这时候就可以用到 dispatch barriers了。下面我们来讨论一下，不同的队列中barriers的使用： Custom Serial Queue: 在串行队列中，队列都是顺序串行执行，使用barriers没有任何好处。一般来讲我们不需要这么做。 Global Concurrent Queue: 这里虽然是并行队列，但这个队列是全局的，我们不能保证别人没有使用这个队列。对这个队列加barriers，可能会影响到其他模块的功能。所以不建议在这个队列中使用。 Custom Concurrent Queue: 在自定义的并行队列中使用barriers，是比较合适的方式。 所以当我们要做的并行操作，可能存在线程安全问题的时候。我们最好考虑新建自定义并行队列，而不是简单地使用系统提供的 Global Queue。 举一个例子，假设某一个类要管理MyClass这个类型的读写，下面列举这个类的一些相关方法: 123456789101112131415161718192021222324252627282930313233343536373839//初始化自定义并发队列 - (instancetype)init&#123; if(self = [super init])&#123; customConcurrentQueue = dispatch_queue_create(&quot;com.customConcurrentQueue&quot;, DISPATCH_QUEUE_CONCURRENT); &#125; &#125; //写方法 - (void)write:(MyClass *)myClass &#123; if( myClass )&#123; //使用barrier，保证写方法，可以串行执行 dispatch_barrier_async(self.customConcurrentQueue, ^&#123; //写操作 ... &#125;); &#125; &#125; //读方法 - (MyClass *)read&#123; //要保证，读和写方法不能同时执行， //首先，他们要在同一个队列中 ：self.customConcurrentQueue //其次，读方法要等待读出数据后返回，所以应该是同步操作 ：dispatch_sync __block MyClass *myClass = [[MyClass alloc] init]; dispatch_sync(self.customConcurrentQueue, ^&#123; //读操作 myClass = ... &#125;); return myClass; &#125; dispatch groups有时候，我们需要在多个并行任务全部完成后，做一些操作，这时候就需要用到 group来管理了。 举一个简单的例子。我有4个任务要使用并发处理，任务4要等待，任务1、2、3完成后执行。同时，任务4不阻塞当前的线程： 12345678910111213141516171819202122232425262728293031- (void)testDispatchGroup&#123; dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;com.test.testConcurrent&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_group_t group = dispatch_group_create(); //异步操作 dispatch_group_async(group, concurrentQueue, ^&#123; 任务1 &#125;); dispatch_group_async(group, concurrentQueue, ^&#123; 任务2 &#125;); dispatch_group_async(group, concurrentQueue, ^&#123; 任务3 &#125;); //dispatch_group_notify 中的block执行的是我们最后要做的任务。同时，这里是异步操作，不会阻塞后面其他代码的执行。 dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; //前面3个任务，都执行完成后，执行里面的block 任务4 &#125;); ...&#125; 再看另一个需求，还是之前的4个任务。唯一的区别是，任务4除了要等待其他任务完成，还要阻塞当前线程： 12345678910111213141516171819202122232425262728- (void)testDispatchGroup&#123; dispatch_group_t group = dispatch_group_create(); //异步操作 dispatch_group_async(group, concurrentQueue, ^&#123; 任务1 &#125;); dispatch_group_async(group, concurrentQueue, ^&#123; 任务2 &#125;); dispatch_group_async(group, concurrentQueue, ^&#123; 任务3 &#125;); //dispatch_group_wait 等待上面任务全部完成，阻塞当前线程，直到超过设置的时间 //使用时，要注意避免阻塞主线程等问题 dispatch_group_wait(group, DISPATCH_TIME_FOREVER); 任务4 ...&#125; 另外，除了使用dispatch_group_async管理要做的任务。还可以使用dispatch_group_enter、 dispatch_group_leave 组合的方式，手动通知任务完成。如果使用手动管理的话，我们要注意：enter和leave方法，应该是成对出现的。 dispatch_group_enter(customGroup) : 手动告知customGroup，表示一个任务已经开始执行。 dispatch_group_leave(customGroup) : 手动告知customGroup，表示一个任务已经完成。当所有enter对应的leave方法都执行过后。我们的dispatch_group_notify()或者dispatch_group_wait()，就可以接到任务完成的通知。 dispatch semaphore 信号量当有多个消费者，访问有限的资源的时候，信号量) 可以让我们更好的控制。简单来说，我们通过对信号个数的控制，来达到线程间的同步操作。当信号个数为0的时候，当前线程被阻塞，等待信号量增加，当信号量个数大于0的时候，则线程继续执行。 注意，同步的操作都要小心使用，避免死锁等问题。 另外，根据dispatch_semaphore_wait的返回值，可以用于判断某任务是否超时操作。 123456789101112131415161718192021222324252627- (void)testSemaphore&#123; //创建 信号量 参数代表初始个数 dispatch_semaphore_t semaphore = dispatch_semaphore_create(0); dispatch_async(concurrentQueue, ^&#123; sleep(2); //发送一个信号，信号量个数 +1 dispatch_semaphore_signal(semaphore); &#125;); dispatch_async(concurrentQueue, ^&#123; dispatch_time_t timeoutTime = dispatch_time(DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC); //线程等待，当信号量大于0时 任务继续执行，信号量 -1 //线程等待，超过预定的超时时间 任务继续执行 信号量不变 //关于返回值：当返回值 不为0 的时候，说明超时 if( dispatch_semaphore_wait(semaphore, timeoutTime) )&#123; NSLog(@&quot;time out&quot;); &#125; &#125;);&#125;","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.yuhanle.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.yuhanle.com/tags/iOS/"},{"name":"GCD","slug":"GCD","permalink":"https://blog.yuhanle.com/tags/GCD/"}]},{"title":"离开象牙塔以后","slug":"say-hello-work","date":"2017-04-18T00:00:00.000Z","updated":"2021-10-21T08:18:48.339Z","comments":true,"path":"2017/04/18/say-hello-work/","link":"","permalink":"https://blog.yuhanle.com/2017/04/18/say-hello-work/","excerpt":"学校出来有很多区别，其中有一点是最无聊的。","text":"学校出来有很多区别，其中有一点是最无聊的。 由过去的三点一线，转变成两点一线，没了教室，没了食堂，变成了公司和宿舍。 没有认真数过，平均每天，在同一条路上来回，将近三年，磨平了几双鞋子，擦碰过多少次路边的槐树。 出了地铁站，有一个红绿灯路口，八点半钟是高峰期，人正多，很多人迫不及待，趁着车来车往，迅速的窜到对面，急匆匆地消失在视线里。 习惯过了马路，穿过停车场，因为路边的小路很窄，如果对面同时走过来一个人，就需要相互侧身，就像那篇雨巷，也经常的不小心踩到石坑，污泥溅到另一双鞋子。 停车场里走着，很危险，可能正在玩手机，我没注意。有一次，有位女士，低着头走着走着，穿过停车杆，没想到停车杆当时正在下落，我能听到敲击头部的声音，很脆，接着就是歇斯底里的嗷叫。 路边有个快客，我一直以为他是假的快客，在我印象中，这个名字不应该是感冒药吗？很少去光顾这家便利店，因为东西少，不合口味，还特别的贵，除了早餐，还有午饭，零食，如果时间来得及，我会去那家罗森买杯永和豆浆，虽然喝起来没有大豆的味道，但还蛮合口味，特别是冬天，路上顺便暖暖手。 办公楼里的电梯，工作日上班时间，我没有乘过。就在五楼，闭着眼我都摸上去了，平日里吹嘘着锻炼身体，要减肥，这也是唯一能够坚持下去，锻炼的方式了。 很想念，两年前每天来回骑行20公里的日子，身体是好了些，腿越来越粗，越有力，凌晨两点的路上，迎着风，骑在快车道上，肚子饿的话就在路边吃点路边摊。摊主们出来的很晚，以至于我的很多朋友都说没见过路边摊，也许是上海整治的很严格吧！ 不管这一天，如何如何，也不会影响新的一天。 或许，只有清华北大才能称之为象牙塔吧？ 题图：aobahorse 不要求署名","categories":[{"name":"suibi","slug":"suibi","permalink":"https://blog.yuhanle.com/categories/suibi/"}],"tags":[{"name":"motion","slug":"motion","permalink":"https://blog.yuhanle.com/tags/motion/"}]},{"title":"通过Sonar 初步构建代码持续审查","slug":"continuous-code-quality-sonarqube-install","date":"2017-02-15T00:00:00.000Z","updated":"2021-10-21T08:18:48.334Z","comments":true,"path":"2017/02/15/continuous-code-quality-sonarqube-install/","link":"","permalink":"https://blog.yuhanle.com/2017/02/15/continuous-code-quality-sonarqube-install/","excerpt":"介绍篇SonarQube 介绍SonarQube 是一款领先的持续代码质量监控平台，开源在github 上，现在已更新到6.2 版本，star 数量超过 1400+，可以轻松配置在内网服务器，实时监控代码，帮助了解提升提升团队项目代码质量。通过插件机制，SonarQube可以继承不同的测试工具，代码分析工具，以及持续集成工具。","text":"介绍篇SonarQube 介绍SonarQube 是一款领先的持续代码质量监控平台，开源在github 上，现在已更新到6.2 版本，star 数量超过 1400+，可以轻松配置在内网服务器，实时监控代码，帮助了解提升提升团队项目代码质量。通过插件机制，SonarQube可以继承不同的测试工具，代码分析工具，以及持续集成工具。 与持续集成工具（例如 Hudson/Jenkins 等）不同，SonarQube 并不是简单地把不同的代码检查工具结果（例如 FindBugs，PMD 等）直接显示在 Web 页面上，而是通过不同的插件对这些结果进行再加工处理，通过量化的方式度量代码质量的变化，从而可以方便地对不同规模和种类的工程进行代码质量管理。 在对其他工具的支持方面，Sonar 不仅提供了对 IDE 的支持，可以在 Eclipse 和 IntelliJ IDEA 这些工具里联机查看结果；同时 SonarQube 还对大量的持续集成工具提供了接口支持，可以很方便地在持续集成中使用 SonarQube。 此外，SonarQube 的插件还可以对 Java 以外的其他编程语言提供支持，对国际化以及报告文档化也有良好的支持。 行业内提到”代码质量管理, 自动化质量管理”, 一般指的都是通过Sonar来实现。本文的目标是实现在Sonar上显示出iOS项目, 先看张最终的效果图: 用Sonar能够实现什么? 技术债务(sonar根据”规则”扫描出不符合规则的代码) 覆盖率(单元测试覆盖率) 重复(重复的代码, 有利于提醒封装) 结构 问题1: “规则”指的是什么? 在Sonar工具中配置检测工具(规则), 然后sonar根据规则检测&quot;质量报告文件&quot;, 得出问题数目。 比如本文配置的规则是OCLint 问题2: 技术债务的天数怎么得出? 每个规则都有对应的处理时间, 最后:问题类型1数目 * 对应时间 + 问题类型2数目 * 对应时间 +... 得到时间。 SonarQube 工作流程SonarQube 并不是简单地将各种质量检测工具的结果（例如 FindBugs，PMD 等）直接展现给客户，而是通过不同的插件算法来对这些结果进行再加工，最终以量化的方式来衡量代码质量，从而方便地对不同规模和种类的工程进行相应的代码质量管理。 SonarQube 在进行代码质量管理时，会从图 1 所示的七个纬度来分析项目的质量。 SonarQube 不是那种安装即可用的工具，他需要数据库的支持，用于存储检测项目后的分析数据，同时为了实现可持续监测，还需要项目持续集成工具（如Jenkins）的支持，在构建版本前，通过Jenkins+Sonar 插件执行项目分析指令，最终的结果会通过SonarQube 服务器的Web 页面展示。 下面我们就通过mysql+Jenkins+SonarQube 实现项目代码质量的可持续监测 安装篇SonarQube 的安装涉及到的知识点 XCTool工具 OClint工具 Gcovr工具 Git, SVN命令 Linux 命令 mysql 操作 Jenkins工具 Sonar工具 Shell语法 Sonar-runner工具 软件及硬件的要求SonarQube 的安装通常需要满足一定的软硬件条件，具体要求如下所示： Server 要求 Web server 最少需要 500MB 的内存空间，推荐内存空间大小 2GB。Sonar 在进行代码质量分析时，通常大约每 1 KLOC 需要存储 350KB 左右的数据，所以要尽量为 SonarQube 的 web server 提供大的内存。 Database 要求 尽管 SonarQube 本身自带嵌入的 Derby 数据库，但是由于 Derby 比较简单，所以在生产环境中强烈推荐安装相应的企业版数据库，SonarQube 支持的数据库包括： MySQL 5.x+、Oracle10g+、PostgreSQL 9.x 和 MS SQLServer 2005 and 2008，推荐使用 MySQL。 Browser 要求 SonarQube 支持大多数的浏览器，包括 Firefox、Internet Explorer 7.x and 8.x and chromed 等，推荐使用 chromed。 目前官方最新的版本是6.2，但是对于部分插件会存在不兼容的问题，导致Sonar 服务启动失败，所以为了使用和演示，我采用了旧版本4.5.7，因为此版本兼容 sonar-objective-c-plugin-0.3.1 插件。 更新： 关于XCode8的兼容方案, 请看这篇文章 安装步骤 数据库配置 进入数据库命令模式或者直接使用GUI 工具，创建Sonar-Qube 服务所需的数据库 123456mysql -u root -pmysql&gt; CREATE DATABASE sonar CHARACTER SET utf8 COLLATE utf8_general_ci; mysql&gt; CREATE USER &apos;sonar&apos; IDENTIFIED BY &apos;sonar&apos;;mysql&gt; GRANT ALL ON sonar.* TO &apos;sonar&apos;@&apos;%&apos; IDENTIFIED BY &apos;sonar&apos;;mysql&gt; GRANT ALL ON sonar.* TO &apos;sonar&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;sonar&apos;;mysql&gt; FLUSH PRIVILEGES; 完成以后测试一下连接是否正确 安装SonarQube 与SonarQube-Runner SonarQube Runner 2.4 下载地址 从官网下载 SonarQube 的最新版本并解压到/usr/local/文件夹 添加SONAR_HOME、SONAR_RUNNER_HOME 环境变量，并将SONAR_RUNNER_HOME 加入PATH 修改Sonar-Qube 配置文件 配置文件路径在 ./conf/sonar.properties 12345678910111213# 设置数据库的账户密码sonar.jdbc.username=uasonar.jdbc.password=pwdsonar.jdbc.url=jdbc:mysql://localhost:3306/sonar?useUnicode=true&amp;characterEncoding=utf8&amp;rewriteBatchedStatements=true&amp;useConfigs=maxPerformance# By default, ports will be used on all IP addresses associated with the server.sonar.web.host=0.0.0.0# The default value is root context (empty value).sonar.web.context=/# TCP port for incoming HTTP connections. Default value is 9000.sonar.web.port=9003 运行如下命令启动 Sonar-Qube，根据操作系统选择 123456Last login: Wed Feb 15 18:15:05 on ttys000localhost:~ tianyi$ /usr/local/sonarqube-6.2/bin/macosx-universal-64/sonar.sh startlocalhost:~ tianyi$ /usr/local/sonarqube-6.2/bin/macosx-universal-64/sonar.sh startStarting SonarQube...Started SonarQube. 创建一个简单的工程 默认密码是admin：admin，登陆管理员账号以后，配置系统参数 创建一个Demo 工程 Demo 工程简介 因为还没有进行过分析，所以Demo 暂时只能配置，在使用篇我们会详细介绍如果通过指令或自动化执行分析审查。 安装一些必备插件，都可以从官网或者github 上搜索到 Sonar支持多种插件，插件的下载地址为：http://docs.codehaus.org/display/SONAR/Plugin+Library 将下载后的插件上传到${SONAR_HOME}extensions\\plugins目录下，重新启动sonar。 常用插件（注意版本号兼容性问题） SonarQube 汉化包：https://github.com/SonarQubeCommunity/sonar-l10n-zh Objective-C 代码检查：https://github.com/octo-technology/sonar-objective-c JavaScript 代码检查：http://docs.codehaus.org/display/SONAR/JavaScript+Plugin python 代码检查：http://docs.codehaus.org/display/SONAR/Python+Plugin Web页面检查（HTML、JSP、JSF、Ruby、PHP等）：http://docs.codehaus.org/display/SONAR/Web+Plugin xml文件检查：http://docs.codehaus.org/display/SONAR/XML+Plugin scm源码库统计分析：http://docs.codehaus.org/display/SONAR/SCM+Stats+Plugin 文件度量：http://docs.codehaus.org/display/SONAR/Tab+Metrics+Plugin 中文语言包：http://docs.codehaus.org/display/SONAR/Chinese+Pack 时间表显示度量结果：http://docs.codehaus.org/display/SONAR/Timeline+Plugin 度量结果演进图：http://docs.codehaus.org/display/SONAR/Motion+Chart+Plugin 我的资源 使用篇使用SonarQube Runner分析源码预置条件已安装SonarQube Runner且环境变量已配置，即sonar-runner命令可在任意目录下执行 如何配置环境变量，参考这篇文章 如何分析1. 在项目源码的根目录下创建sonar-project.properties配置文件 以iOS 项目为例 12345678910111213# Required metadatasonar.projectKey=iOS::Demosonar.projectName=iOS::Demosonar.projectVersion=1.0# Comma-separated paths to directories with sources (required)sonar.sources=Demo# Languagesonar.language=objectivec# Encoding of the source filessonar.sourceEncoding=UTF-8 注意：sonar.language 和安装的代码审查插件有关，需要安装 sonar-objective-c 插件，否则运行时会提示无法找到这个语言 2. 执行分析 在项目的根目录执行分析指令 1/usr/local/sonar-runner-2.4/bin/sonar-runner 查看Sonar 分析的结果 以上是创建Demo 工程后，通过手动执行分析指令完成代码审查分析。 与Jenkins 持续集成构建前操作在jenkins的插件管理中选择安装SonarQube-Scanner，该插件可以使项目每次构建都调用sonar进行代码度量。 进入配置页面对sonar插件进行配置，如下图： 以上配置可以使项目在构建前，自动执行代码审查和分析，结果会自动保存并上传到数据库，通过Sonar 服务器展示给开发者。 设置触发器每5分钟检查一次仓库，若有上库，则自动执行代码检测 至此，通过Sonar 初步构建代码持续审查的工作完成。 问题篇安装中的问题 资源找寻的问题 文中提到的资源文件，网上谷歌百度都用上，也找了很久，包括一些插件的问题，必须安装的就是 Sonar-Qube，Runner 其实不必要安装，因为Jenkins 里有插件，可以直接使用。 环境配置问题 如果不常用指令的话，可以不配置，直接通过绝对路径做操作，环境配置的方法参考这篇文章 初始化时遇到Sorry 的问题 遇到这种问题可以去根目录 /log/xx.log 中查看日志，具体问题具体解决 汉化包的问题 如果你不习惯英文的使用，想做一做汉化的事情时，汉化包一定要对，如果有问题会导致服务启动失败。 附上：汉化包下载地址 SonarQube 实际使用中遇到的问题及解决方案在使用 SonarQube6.2 分析代码质量时，可能会遇到的问题： Xcode 8 兼容性问题 原有的xctool已不支持XCode8, 改用xcodebuild + xcpretty 来替代xctool环节生成对应的产出物。 关于XCode8的兼容方案, 请看这篇文章 结束语代码质量管理对提高项目质量意义重大。本文介绍了 SonarQube 的工作原理，并从项目实战的角度讲解了使用 SonarQube 进行项目代码质量管理的流程和注意事项。 代码规范贵在坚持与执行力，自动审查只是做了提醒的作用，当然根据语言的规则，很多规范在使用者来讲看似不合理或者不好用，有了这个工具，参与者们可以切身感受到团队的成长。 参考文章[实践]iOS Sonar集成流程详解 [实践]Sonar Xcode8兼容 SonarQube代码质量管理平台安装与使用 配置sonar、jenkins进行持续审查","categories":[{"name":"continue","slug":"continue","permalink":"https://blog.yuhanle.com/categories/continue/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.yuhanle.com/tags/iOS/"},{"name":"Sonar","slug":"Sonar","permalink":"https://blog.yuhanle.com/tags/Sonar/"},{"name":"Quality","slug":"Quality","permalink":"https://blog.yuhanle.com/tags/Quality/"}]},{"title":"见字如面的过去一年","slug":"see-words-as-face","date":"2017-01-22T04:29:59.000Z","updated":"2021-10-21T08:18:48.339Z","comments":true,"path":"2017/01/22/see-words-as-face/","link":"","permalink":"https://blog.yuhanle.com/2017/01/22/see-words-as-face/","excerpt":"见字如面，甚是想念。","text":"见字如面，甚是想念。 2016，时间总是如此，过的很快。工作后对于时间的概念只有在白天了，总觉得不够用，上班下班，吃饭睡觉，一如既往的重复重复，就像花钱一样，每一笔微小的开支，累积起来都让人不敢相信。 跟你在一起的这一年，庸庸碌碌，本该在元旦就跟你告别，没想到一拖就是一个月，从未想过你会走的如此之快，可能是我没太在意，因为你带给我的这是疲惫和不堪，甚至是我至今都不愿接受的未曾改变。 这个365天，我得到了这些： 这一年的生活在2015 年11月底，女朋友来到了这个我们都很陌生的大都市，接着到了2016 年4月，她开始了正式的工作，小俩口挣得不多，部分房租，部分吃喝，余下的就更少了。 4月底，我们摆脱了不到20平米的单身公寓，摆脱了隔三差五停电，还得去灌天然气，走很远去买菜的生活，搬到了某小区50+ 平米的一室一厅。没错，房租很贵，足足翻了一倍多，距离我们上班的地方也很远，但这些都不重要，我们都很开心，附近有些朋友，周末可以聚聚，楼下就有菜市场，最总要的是主卧朝南，再也不用宅在冷冰冰的小房间里玩手机了。 紧接着，5月份最重要的是大学舍友从新疆过来玩，那一天，我们去了七宝，田子坊，在港汇广场吃过饭，夜晚还去了外滩看夜景，回想起来，这是来这个城市以后最好玩的一天。时间比较敢，大家一路上几乎都是跑起来的，为了外滩的夜景，也值。 接下来的几个月，天气很热，除了周末爬爬山，也就在家待着啃西瓜。 中秋节假期，我和女友约好去了趟南京，古都南京是个很适合游玩的地方，不仅有很多著名景点，还有很多各色小吃，两天一夜的时间，刚刚好，只是累了些，前同事作为地道的南京人，带我们吃了一遍大排档里的招牌菜，真是流连忘返，因为回去就得马上上班。 到了10 月，国庆节的假期很长，提前回了趟家，刚好家里的房子装修好，准备搬家呢。前前后后忙活了三四天，接着就一家人带着彩礼，去和女友的家人见面了。说起来也认识近7 年，阻力还好，日久见人心嘛！现在的父母都很开明，我们之间还是比较顺利的，至少彼此还算满意，不会让家里瞎操心。 国庆节结束后，在郑州见了几个朋友，临走前一直在锅大侠二七店吃了顿火锅，之所以选在这个地方，是因为马上就要坐上火车拜拜了。这顿饭吃起来，大家完全没有好久不见的样子，都在聊着工作，聊着房价，这一年，房价没有骗人，一直在涨。回到上海以后，我就开始着急了，按照我们的家庭条件来讲，首付的问题很大，也是最主要的问题。后来我们还是决定，在房价趋于稳定的11 月份，多次往返两个城市，将此事定了下来。当然还有一件好事，我们领了结婚证，这个意义很大。 很快，这一年就结束了，17 年元旦，带着女朋友去了趟巴黎春天，买了她向往已久的钻戒，对此毫无概念，30+ 分，虽然没有鹅卵石那么大，但是低调一些，我们都还是很高兴的。在此之前，也订好了17 年3 月份去三亚旅行的事情，顺便拍拍结婚照，准备好了，就该步入婚姻的殿堂了。 这一年的工作原本一个人的项目，15 年底新增了个小伙伴，91 年的研究僧，大家相互学习，工作起来配合也很默契，很满意。 原有的1.0 版本新增功能，维护了一整年。蓝牙的项目在15 年底就搁置了，三四月份的时候，领导说，可能要继续启动蓝牙的项目，于是我们有加了一个小伙伴，于是3 个男人的小团队就开启了。 接着就是一个月的蓝牙项目，1.0 版本的更新迭代，内部销售系统的更新迭代，没有深入的学习机会，但是事情多而杂，有做不完的东西。 很快到了6 月份，1.0 的更新变慢了，更多的时间，我们开始了2.0 的软件研发，相比较而言，2.0 的软件更适合用户，体验提升了不少，但也增大了研发的难度，对技术的要求也高了很多。但是原本计划八九月份发布，没想到到了今天还只是在公测阶段，中间遇到的那些坑，还有需求的变更，简直让人生不如死。 接着8 月份，一位同事因为个人原因离职了，共事了一年，真的是挺舍不得，公司就像市集，来来往往很多人，谁也不知道回去买谁家的东西。项目仍然如此，同事离职以后，2.0 版本又迎来了大改版，不知道是该高兴还是怎么地，总之，继续改，继续同时维护几个版本，看起来总是那么遥遥无期。 到了11月份，项目又多了两个，不得不再找一个小伙伴，还好这个行业，资源很多，只是面试起来，找到合适的也挺难，最后要了一个内推的小姑娘，总算是调和了一下我们部门的男女比例，不过年龄惊人，瞬间拉低了公司的平均年龄。 截止到17 年1 月中旬，2.0 版本终于公测，新增的两个项目也可以拿出来展示，作为研发，不在意评价，有人尊重劳动成果就心满意足。 以上是这一年的工作，代码没少些，只是多了很多管理经验上的学习和历练。 这一年的学习这块东西很少，因为大部分时间都是在工作嘛~ 中间有一天时间参加了饿了么移动技术分享，在此之前也认识了卓同学，还有冰霜和冬瓜，只见了一次面，本人不善言语，只是听他们聊得多了一些，技术圈的微信群和QQ 群加了不少，每天都能看到有人问有人答，偶尔也会参与讨论。 具体的项目中，逐渐剥离了各个模块之间的联系，数据库方面也尝试了Realm 和CoreData，做了一些比较和分析，最后选择了后者。 工作之余也搭建了持续集成平台和远程持续代码审核平台，这些都比较简单，网上的教程看的细致都不会存在什么问题。 总之，学习的很欠缺。 下一年的小目标健林先生的目标我很欣赏，比如先挣他一个亿。 Swift 一定要玩转，至少要在一个项目中使用Swift 开发 终身大事要尽早解决 见更多的朋友 情商 2016 年，也并不是毫无收获，应当保持激情，做好每一件事，善待每一个人。","categories":[{"name":"word","slug":"word","permalink":"https://blog.yuhanle.com/categories/word/"}],"tags":[{"name":"see a word","slug":"see-a-word","permalink":"https://blog.yuhanle.com/tags/see-a-word/"}]},{"title":"如何设计扫一扫功能才能更优雅","slug":"design-scan-function","date":"2016-12-04T00:00:00.000Z","updated":"2021-10-21T08:18:48.335Z","comments":true,"path":"2016/12/04/design-scan-function/","link":"","permalink":"https://blog.yuhanle.com/2016/12/04/design-scan-function/","excerpt":"当前二维码在生活中随处可见，他的功能无需多言，彻底的改变了消费者的使用习惯，提升了用户的操作体验，同时也拉近了人与人，人与物乃至物与物之间的距离","text":"当前二维码在生活中随处可见，他的功能无需多言，彻底的改变了消费者的使用习惯，提升了用户的操作体验，同时也拉近了人与人，人与物乃至物与物之间的距离。 写在前面正如题图，当前二维码在生活中随处可见，他的功能无需多言，彻底的改变了消费者的使用习惯，提升了用户的操作体验，同时也拉近了人与人，人与物乃至物与物之间的距离。 二维码的使用场景很多，比如添加好友，关注公众号，移动支付，还有很多的某某活动入口，用户无需记住太多信息，拿出手机，轻轻的扫一扫对方的资料就能完成操作；移动支付时代，也是因为这个功能的便捷，才能发展的更普遍，剁起手来也就一瞬间；在商家举办的很多活动中，只需要提供一个二维码图片，再通过朋友圈等社交媒体的疯狂转发，亿万用户都能与商家零距离参与活动，接着二次分享，从而给商家带来蹭蹭蹭的流量。 然而，以上的种种便捷，都离不开扫一扫这个功能。下面，本人就站在一个刚刚接触此行业的基础上，跟大家聊一聊我脑袋里的扫一扫是如何设计的（如有非议，请艾特我）。 正正正文市场上主导应用是如何做的想必接触这个行业的产品和开发人员都了解，无论什么应用，这块的功能应该都是大差不差，条条大路通罗马，但其中的规则，应该都是统一的。 那我在这里就班门弄斧，顺便体验一下微信的扫一扫功能。 该二维码图片由微信APP提供 1. 先看一下微信扫描结果 该图片由微信APP提供 这里因为是本人的二维码，所以下面显示的操作是发消息，如果是陌生人的二维码，就是添加到通讯录。这里可以知道，扫描这个二维码的操作，就是查看该用户的个人资料。那这个二维码里究竟藏有什么信息？我们可以通过其他工具扫描一下结果。 2. 看一下草料扫描结果 该图片由草料二维码提供 很显然，这是一个http 的url 链接 1http://weixin.qq.com/r/35zcxLnE_uSFrf2n98nN 我们先分析一下这url 的大概参数，下面用一个表格来说明： 参数 类型 说明 http://weixin.qq.com String 域名 r String 看起来是路由 表示要查看资料 35zcxLnE_uSFrf2n98nN String 看起来是加密后的能标识用户唯一属性 值得一提的是，这个url 是真实可以访问的，通过电脑打开会直接跳转到官方网站。可能会有很多人（包括我们的QA人员）提出疑问，如此简单的一个扫码查看资料的功能，为什么要做成一个复杂逻辑的url 超链接呢？ 3. UC 扫码结果 该图片由UC提供 以上是UC 浏览器扫码的结果，同样是跳转到微信官网，但是与之不同的是，紧接着直接打开微信APP（如果安装微信的话），否则就跳到应用市场告知用户下载微信APP。那这里就可以很好的解释一下，为什么二维码的扫描结果使用url 超链接，因为这样可以更好体验的引导用户，从而提升自身产品的流量，也就是说不管你通过何种方式，什么应用扫码，对于用户来讲，你可以很快速很直观的了解到你扫描的东西是什么，不再是二维码实际意义上的一段字符，从产品的角度来说，也能够保证这块的用户流量流失减少，操作体验上也有很大的提升。 我们的应用该如何设计那这个，跟产品本身的需求有很大关系，但是开发的思路和逻辑都是统一的，类似微信这种超级APP，有各种牛人集思广益，项目中应该是会各种组件化，模块化的设计，拿一个简单的扫一扫功能来说，作为一个模块，在他的功能以及和其他模块之间的耦合性来说，肯定是值得我们借鉴和学些的，当然我没有找到任何相关资料，下面只能按照近期的项目来聊聊我是如何处理的。 1. 二维码扫描的结果必定是一个可以访问的超链接 这个应该是没人反驳的。 之所以这么定义，有两点优势。第一，用户体验和导流上，可以做到更好，具体上面的分析中也提到，就不再赘述；第二，在研发上，通过超链接，可以很方便的将功能集成到我们的路由模块，当然这里也有其他的方法，不过也同样是为了处理扫码结果来定义的。 路由模块的耦合设计 上图中，扫一扫功能通过超链接的形式，可以直接整合到路由模块中，通过scheme 的方式，先将域名 替换成 自定义的scheme，如果路由模块可以处理就丢过去处理，不能处理的情况下，就通过APP 内部的浏览器打开该链接，其他逻辑的操作就丢给web 页面处理，比如引导用户到官网，提醒用户下载应用，等一些错误的处理。 2.为了更好地兼容扫码功能，做一些优化 路由模块的扫码功能优化 这里，我们把一些通用的处理操作，通过类别或者代理协议的方法，按功能分别添加到路由模块中，这种优化不仅优化了扫一扫的功能，也同时优化了其他各模块使用路由模块的逻辑。 那我们可以开始着手研发了适用环境Web或其他应用调用XXX应用特定功能，也可以用于应用内部功能跳转 支持系统iOS，Android，H5 如有因系统特性导致的不一致，在协议中详细列出 调用方式Web端http://appwebv2.xxx.cn//?parms (开发测试环境为appwebv2test.xxx.cn) App端xxxapp:///?params Web 调用端需要先判断XXX应用是否已经安装如已安装，则通过xxxapp://调用如未安装，视实际定义及功能，通过web调用或者提示用户下载应用 App 端需要先通过xxxapp:// 路由 如果本地已经注册，继续执行 没有注册，直接通过应用内浏览器打开 Web 页面（需要匹配模板填充必要参数） 示例http://appwebv2.xxx.cn/action/bind/bike/{bikeid}/?appversion={version}&amp;platform={platform}&amp;xxxkey={xxxkey} 链接前半部分，由服务器生成，后面红色部分参数需要客户端在不能正常通过路由打开该功能，调用浏览器时拼接在 url 里。 后面红色部分参数，根据服务器的模板链接匹配填充，然后生成二维码展示。 必要参数 参数 类型 说明 action/ Router 此路由是action 表示该链接是要实现某功能 bind String 表示绑定的操作 bike String 表示要绑定的是车 bikeid String 需要处理的参数 功能已经实现按照上面的定义和逻辑，扫一扫的功能已经可以据此定义砌砖实现。对于路由的功能，可以本地实现，也可以像蘑菇街那样，通过后台的配置可以随时更改处理操作。 于是，web 端准备了一个页面，超链接是 1http://appwebv2.xxx.cn/action/bind/bike 生成二维码之前，服务端给了你一个字符串，内容是 1http://appwebv2.xxx.cn/action/bind/bike/11234/?appversion=&#123;version&#125;&amp;platform=&#123;platform&#125;&amp;xxxkey=&#123;xxxkey&#125; 客户端根据字符串，通过匹配和填充，生成一个二维码 生成二维码 二维码的实际结果就是 1http://appwebv2.xxx.cn/action/bind/bike/11234/?appversion=V1.0&amp;platform=iOS&amp;xxxkey=3a10362d077cd27b5f2c537e1ff2fc48 至此，通过XXX 应用扫码，就会调用添加车辆的功能。通过第三方APP 扫码的话，会先打开浏览器，web 页面会再通过系统方法先尝试调用XXX 应用，如果不能调起，就提醒用户去商店下载，如果能调起应用，XXX 应用在启动以后，通过路由模块处理，首先跳转到扫一扫界面，然后调用添加车辆的功能，如果路由无法处理这个http 超链接，就会调用浏览器再加载这个web 页面。 到这里，我脑海里能想到的基本分析完了，如果有更好的想法或建议，请艾特我~ 新浪微博：煜寒了","categories":[{"name":"mobile","slug":"mobile","permalink":"https://blog.yuhanle.com/categories/mobile/"}],"tags":[{"name":"scan","slug":"scan","permalink":"https://blog.yuhanle.com/tags/scan/"}]},{"title":"ObjC&JavaScript 交互，在恰当的时机注入对象","slug":"oc-js-inpourjs-in-goodtime","date":"2016-11-30T00:00:00.000Z","updated":"2021-10-21T08:18:48.338Z","comments":true,"path":"2016/11/30/oc-js-inpourjs-in-goodtime/","link":"","permalink":"https://blog.yuhanle.com/2016/11/30/oc-js-inpourjs-in-goodtime/","excerpt":"警告：文章中提到的 1- (void)webView:(id)unuse didCreateJavaScriptContext:(JSContext *)ctx forFrame:(id)frame; 方法涉及私有API，有网友反馈说审核会被拒绝，希望看到的朋友们慎用 移动端项目开发中，免不了出现 Native App （以下简称Native）和 H5 页面（以下简称H5）的交互，网络上有很多第三方框架，比如WebViewJavascriptBridge，对于一些小的项目需求来说，其实不用那么麻烦，我们还是先从基础着手。","text":"警告：文章中提到的 1- (void)webView:(id)unuse didCreateJavaScriptContext:(JSContext *)ctx forFrame:(id)frame; 方法涉及私有API，有网友反馈说审核会被拒绝，希望看到的朋友们慎用 移动端项目开发中，免不了出现 Native App （以下简称Native）和 H5 页面（以下简称H5）的交互，网络上有很多第三方框架，比如WebViewJavascriptBridge，对于一些小的项目需求来说，其实不用那么麻烦，我们还是先从基础着手。 先了解几个基础方法 网页即将加载（最先执行的代理方法），在每次load 页面的时候都会先走这个回调，可以在此做一些自己的操作，经常会在这儿拦截协议 12345- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType &#123; // do something... return YES;&#125; 网页已经加载完成（最后执行的代理方法），执行到这个地方，web 页面已经加载完成，相关代码也都执行完毕 1234- (void)webViewDidFinishLoad:(UIWebView *)webView &#123; // 加载完成 隐藏HUD &#125; 根据不同的场景，找一个最合适的方法场景1 （H5 通信 Native，告知Native 要做的事儿） 1H5 页面在某个标签点击后，要关闭当前加载网页的控制器VC 需求分析： 这应该不是最简单的一个需求，最简单的是Native 通过url 给H5 页面传参数，告知H5 要做的事儿。 这个需求中，H5 页面已经加载完毕，此时可以说H5 页面相关的Bug 和UI 缺陷都与Native 无关，我每次都是这么跟测试人员讲，类似问题直接assign 给他们。 功能实现： 对于这类比较简单的需求，最常用的做法就是，通过拦截协议的方法，在点击标签的时候，可以调用自定义协议的超链接，比如定义一个 yuhanle://action/close的链接，在页面即将load 的时候，判断url 的协议，如果协议是 yuhanle，就拦截掉这个请求，做自己的处理。 图解： 场景2 （H5 调用 Native App 的JS 方法，包括同步和异步操作） 123H5 页面在加载过程中，需要从Native 中取得部分数据，或调用某个功能，均包含同步操作或异步操作，比如只是简单的获取token，则直接同步返回，如果需要Native 异步拿到结果，Native 则需要考虑 JSExport 中的线程问题 需求分析： 这个需求中肯定需要Native 注入JS 方法，H5 通过调用JS 和Native 通信，其中包括同步和异步两种情况下的处理，需要注意的就是异步操作时，H5 需要在调用 App 时传入一个 JS 方法名，App 在拿到数据后可以回调 H5 的JS 方法，在调用这个回调的时候，需要使用webView 的currentThread，不然就会出现页面卡死。 功能实现： 1- 定义一个类，用于注入这个对象 12345678// 此模型用于注入JS的模型，这样就可以通过模型来调用方法。@interface QWSJsObjCModel : NSObject &lt;JavaScriptObjectiveCDelegate&gt;@property (nonatomic, weak) JSContext *jsContext;@property (nonatomic, weak) UIWebView *webView;@property (nonatomic, weak) G100WebViewController * webVc;@end 2- 声明协议，实现和JS 对应的方法 12345678910111213141516171819202122232425262728#import &lt;JavaScriptCore/JavaScriptCore.h&gt;@protocol JavaScriptObjectiveCDelegate &lt;JSExport&gt;/** * 获取客户端的token * * @param qwsKey 客户端生成的密码key * * @return 返回值token */- (NSString *)getToken:(NSString *)qwsKey;/** * H5 传递key 获取newToken 在调用其 callback 方法 * * @param key qwskey * @param callback 回调方法名 * @param property 方法参数 */- (void)getNewToken:(NSString *)key callback:(NSString *)callback property:(NSString *)property;/** * H5 在加载完成后 告诉客户端在返回的时候调用该方法 * * @param callback js 方法名 */- (void)getExitMsgCallback:(NSString *)callback; 3- 我们需要在打开webView 的时候，找到一个好的时机注入 JS 12345678910111213141516// 首先拿到JSContextself.jsContext = [_jsWebView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;]; // 通过模型调用方法，这种方式更好些。 QWSJsObjCModel *model = [[QWSJsObjCModel alloc] init]; self.jsContext[@&quot;nativeObj&quot;] = model; model.jsContext = self.jsContext; model.webView = _jsWebView; self.jsContext[@&quot;getUserinfo&quot;] = ^()&#123; return @&quot;1234&quot;; &#125;; self.jsContext.exceptionHandler = ^(JSContext *context, JSValue *exceptionValue) &#123; context.exception = exceptionValue; NSLog(@&quot;异常信息：%@&quot;, exceptionValue); &#125;; 4- 对应H5 页面的JS 定义及调用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;测试IOS与JS之前的互调&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; * &#123; font-size: 40px; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; var jsFunc = function() &#123; alert(&apos;Objective-C call js to show alert&apos;); &#125; var jsParamFunc = function(argument) &#123; document.getElementById(&apos;jsParamFuncSpan&apos;).innerHTML = argument[&apos;name&apos;]; &#125; &lt;/script&gt; &lt;/head&gt;&lt;body&gt; &lt;div style=&quot;margin-top: 100px&quot;&gt; &lt;h1&gt;Test how to use objective-c call js&lt;/h1&gt; &lt;input type=&quot;button&quot; value=&quot;getToken&quot; onclick=&quot;alert(nativeObj.getToken())&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;Call ObjC system alert&quot; onclick=&quot;nativeObj.showAlertMsg(&apos;js title&apos;, &apos;js message&apos;)&quot;&gt;&lt;/div&gt;&lt;div&gt; &lt;input type=&quot;button&quot; value=&quot;Call ObjC func with JSON &quot; onclick=&quot;nativeObj.callWithDict(&#123;&apos;name&apos;: &apos;testname&apos;, &apos;age&apos;: 10, &apos;height&apos;: 170&#125;)&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;Call ObjC func with JSON and ObjC call js func to pass args.&quot; onclick=&quot;nativeObj.jsCallObjcAndObjcCallJsWithDict(&#123;&apos;name&apos;: &apos;testname&apos;, &apos;age&apos;: 10, &apos;height&apos;: 170&#125;)&quot;&gt;&lt;/div&gt;&lt;div&gt; &lt;a href=&quot;test1.html&quot;&gt;Click to next page&lt;/a&gt;&lt;/div&gt;&lt;div&gt; &lt;span id=&quot;jsParamFuncSpan&quot; style=&quot;color: red; font-size: 50px;&quot;&gt;&lt;/span&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 按照以上的做法，就能达到Native 和H5 之间的相互通信，现在的问题是，在什么时候注入JS 对象，才能满足H5 页面的需求，因为实际情况中，H5 页面可能会随时调用你的JS。 需要注意的几个问题1- 场景2 中我们提到的，异步调用时的线程问题 首先看下下面的代码 1234567891011121314151617181920212223- (void)getNewToken:(NSString *)key callback:(NSString *)callback property:(NSString *)property &#123; if (_webVc) &#123; if ([_webVc.qwsKey isEqualToString:key]) &#123; __block NSString * newToken = @&quot;&quot;; __block NSInteger result = 0; [[UserManager shareManager] autoLoginWithComplete:^(NSInteger statusCode, ApiResponse *response, BOOL requestSuccess) &#123; if (requestSuccess) &#123; newToken = [[G100InfoHelper shareInstance] token]; &#125;else&#123; newToken = @&quot;error&quot;; &#125; result = requestSuccess ? response.errCode : statusCode; JSValue * function = self.jsContext[callback]; NSArray * params = @[@(result), newToken, property]; [function callWithArguments:params]; &#125;]; &#125; &#125;&#125; 这段代码，就是想在H5 页面调用的时候，App 这边自动登陆，重新获取到最新的token，拿到结果以后并回调H5，整个过程上是异步的，看起来是没问题的，但是一旦实际操作起来，会在这里卡死。具体原因，我也不好解释，解决办法是有的，只能通过webView 的currentThread 来执行perform 操作。 示例如下： 1234567891011121314151617181920212223242526272829303132- (void)getNewToken:(NSString *)key callback:(NSString *)callback property:(NSString *)property &#123; if (_webVc) &#123; if ([_webVc.qwsKey isEqualToString:key]) &#123; __block NSString * newToken = @&quot;&quot;; __block NSInteger result = 0; NSThread * webThread = [NSThread currentThread]; [[UserManager shareManager] autoLoginWithComplete:^(NSInteger statusCode, ApiResponse *response, BOOL requestSuccess) &#123; if (requestSuccess) &#123; newToken = [[G100InfoHelper shareInstance] token]; &#125;else&#123; newToken = @&quot;error&quot;; &#125; result = requestSuccess ? response.errCode : statusCode; // 这里通过此方法 在当前线程操作才不会造成卡死的现象 [self performSelector:@selector(callQWSJSWithArgument:) onThread:webThread withObject:@[callback, @(result), newToken, property] waitUntilDone:NO]; &#125;]; &#125; &#125;&#125;- (void)callQWSJSWithArgument:(NSArray *)argument &#123; NSString * callback = argument[0]; JSValue * function = self.jsContext[callback]; NSMutableArray * params = [NSMutableArray arrayWithArray:argument]; // 移除第一个 方法名 [params removeObjectAtIndex:0]; [function callWithArguments:params];&#125; 2- 同样是场景2 中的一个问题，什么时候注入对象 需求总是虚无缥缈的，对于H5 结合 Native 的开发结构中，Native 始终扮演着服务和入口的角色，H5 可能随时都会主动和Native 通信，但是Native 应该在什么时候准备好这些服务呢？ 看了很多网上的资料，几乎全部都是在页面加载完成 webViewDidFinishLoad 这个回调中注入方法，但实际开发中，很多页面在加载的时候就需要和Native 通信，比如说拿到token，如果在这个时候才注入，肯定是来不及的，只能无功而返。 相信大多数人都没太在意这个问题，当然，如果强制让H5 的开发人员修改逻辑，将所有的通信都放在页面加载完成以后在做，也没问题，只不过对于用户的体验会变得糟糕。 深入研究官方文档，就会发现，webView 在加载过程中，会执行这么一个方法，他的作用是 123_:didCreateJavaScriptContext:for:Notifies the delegate that a new JavaScript context has been created created. 具体参见官方文档说明 didCreateJavaScriptContext 看到这里，我们就能在收到这个消息的时候，拿到JSContext，然后注入我们的Model。 首先，新建一个NSObject 的Catagory，在这个代理方法中发送一个通知 1234567@implementation NSObject (JSTest)- (void)webView:(id)unuse didCreateJavaScriptContext:(JSContext *)ctx forFrame:(id)frame &#123; [[NSNotificationCenter defaultCenter] postNotificationName:@&quot;DidCreateContextNotification&quot; object:ctx];&#125;@end 然后，在webView 的控制器中监听这个消息 12345- (void)viewDidLoad &#123; [super viewDidLoad]; // 监听可以注入js 方法的通知 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(didCreateJSContext:) name:@&quot;DidCreateContextNotification&quot; object:nil];&#125; 实现@selector 方法 1234567891011121314151617181920212223#pragma mark - 可以注入js 的监听- (void)didCreateJSContext:(NSNotification *)notification &#123; NSString *indentifier = [NSString stringWithFormat:@&quot;indentifier%lud&quot;, (unsigned long)self.webView.hash]; NSString *indentifierJS = [NSString stringWithFormat:@&quot;var %@ = &apos;%@&apos;&quot;, indentifier, indentifier]; [self.webView stringByEvaluatingJavaScriptFromString:indentifierJS]; JSContext *context = notification.object; if (![context[indentifier].toString isEqualToString:indentifier]) return; self.jsContext = context; // 通过模型调用方法，这种方式更好些。 QWSJsObjCModel *model = [[QWSJsObjCModel alloc] init]; self.jsContext[@&quot;nativeObj&quot;] = model; model.jsContext = self.jsContext; model.webView = self.webView; model.webVc = self; self.jsContext.exceptionHandler = ^(JSContext *context, JSValue *exceptionValue) &#123; context.exception = exceptionValue; DLog(@&quot;异常信息：%@&quot;, exceptionValue); &#125;;&#125; 如此，应该是一次比较完美的注入了~","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.yuhanle.com/categories/iOS/"}],"tags":[{"name":"tips","slug":"tips","permalink":"https://blog.yuhanle.com/tags/tips/"}]},{"title":"无言逝水 回忆无声","slug":"passing-silent-silent-memories","date":"2016-08-21T05:23:00.000Z","updated":"2021-10-21T08:18:48.338Z","comments":true,"path":"2016/08/21/passing-silent-silent-memories/","link":"","permalink":"https://blog.yuhanle.com/2016/08/21/passing-silent-silent-memories/","excerpt":"水的存在，延续了人的生命，却难以洗涤人的回忆。 在我们山里，每一个小的村落，某棵树荫下，就会有一口井，那是山泉。村西头的山脚下，那里地势稍高，有一条田间小路，来来往往的人们挑着木桶，路上湿漉漉的，仿佛刚下过雨，记忆全都小心翼翼的在这条路上穿梭，生怕碰到路人。","text":"水的存在，延续了人的生命，却难以洗涤人的回忆。 在我们山里，每一个小的村落，某棵树荫下，就会有一口井，那是山泉。村西头的山脚下，那里地势稍高，有一条田间小路，来来往往的人们挑着木桶，路上湿漉漉的，仿佛刚下过雨，记忆全都小心翼翼的在这条路上穿梭，生怕碰到路人。 哑巴今天已经是第三趟了，这担水挑完，他就能带小伙伴儿们去山上摘茶果，每年清明前后，山里的吃货很多，但由于村里的老人渐渐离去，年轻人都很少去打柴，上山的路也没了踪迹，据说山上有野兽，所有家里人都不允许我们上山玩。 哑巴是我们对他的称呼，虽然大我们二十多岁，但是家里人从来没有教过我如何称呼他，他天生不会讲话，身体特别瘦小，也许正因如此，人们才不愿意去记住这个人吧！ 从我记事儿开始，每天早上六点多钟，他都要从我家门前路过，挑着两个木桶，虽然不会说话，但是嘴里还哼唧哼唧着，晃晃悠悠的踏上那条去往水井的小路，不一会儿就带着满满两桶水回来了，母亲有时候正在做早饭，看见哑巴路过，就拿着水瓢去了。哑巴会生气，因为这种情况已经不是第一次了，村里人都喜欢这样欺负他，也许他这样生气，被村里人觉得不满，告诉了他的母亲。 印象最深的一次，我被他打了一顿。 我和他的小侄儿一块玩，小孩子间疯疯闹闹的，不小心把他侄儿推到了，刚好被哑巴看见了，上来一巴掌就把我扇到地上，从来没有这样害怕过，这还是我认识的哑巴吗？他虽然很瘦，但力气很大，村里不少年轻人都和他打过，当然大多数是咋欺负他，这次我被打了，家里人肯定不愿意，还好没什么情况，又是乡里乡亲的，就没有下文了。 从那以后，我每次见他都要绕道走，因为害怕，我不知道这样自闭的爆发起来会是什么样的结果，村里的小孩儿，除了那特别爱护的那个小侄儿，都不再跟着哑巴玩。 过了几年，村里人开始厌倦挑水吃，就开始挨家挨户凑点儿钱，买了些水管，一头插进井里，贯穿村里十几户人家，这样大家就都能喝到自来水了。当水经过地下，从龙头里出来的时候，很清很甜，老人们都在感叹，几十年挑水吃的日子终于熬到头，同时那些旧的场景，都不会再出现。 哑巴的日子轻松了，不用再那么早起挑水来养一家人，但是他还是很早就起来了，村东头儿到村西头儿的瞎晃悠，嘴里哼着我们听不懂的调调，偶尔停留在我家门前的石板上，也很乐意跟村里早起的老人聊聊天，当然他不会说话，就是嘴里哼哼唧唧，手不停的在打手势，奇怪的是大家还能看懂大部分，不得不说哑巴很聪明，在与人交流上。 他喜欢抽烟，也喜欢喝酒，当然这些都是在帮别人家干活人家付给他的“工钱”，不过干活的时候，大家可不敢让他喝酒，因为他一喝就停不下来，喝多了就一直笑，眼里还流着很多水，时不时的还哼些调调，然后活肯定是干不了了，所以一般都是在干完活，才把过节剩下的瓶底儿给他喝，他不嫌弃，而且还很高兴，很感激，烟给多了他也不要，一般小事情的话他只会接一根烟，忙了一天才会拿一盒两块钱的散花。 正因如此，大家家里有什么活都喜欢找他做，但是很多人都是偷偷的把他叫过来干活儿，不给工钱，仅仅是一些烟和酒，有时候他的母亲在村里找他都找不见，因为是被隔壁庄上的人叫去和水泥了，按照一般人的工钱一天至少也得有60块钱，但是对于他，如果雇主没有告知他的母亲的话，他自己都不清楚是在给谁干，也不要钱，就算告诉了他的母亲，一天顶多才有20几块钱的收入，当然对于他自己来说，这些钱足够他生活了，但是他还是个孝顺的孩子，钱都是父母收着，自己的衣服大多都是旧的，吃住都在家里。在老家，除了会有人欺负他，看起来他还是很满足的，可能他觉得这是一种与人沟通的方式吧，就是一直这么吃亏，才会有人找你做活儿。 往后好些年，我一直在外上学，就很少见到这位无言者了。直到有一天，家里打电话，让我在外面注意安全，别被骗了，我当时听了还很纳闷，作为一个在外生活多年的人而言，我还是见过些世面的，对于诈骗，不管不问不理会，就不会有危险。我继续追问才知道，原来是有位老乡，说是要给这位无言者讨个老婆，此时他已经四十多岁了，这么多年他父母也帮他攒了一两万块钱，父母听说是有人帮儿子讨老婆很高兴，又是熟人当中间人介绍，所以就毫无防备的被人骗了，从这以后，回家看到他感觉老了很多，没再见他笑过，仿佛对外界充满了敌意。 这么多年来，村子里的人慢慢都搬走了，村里的地也开始荒废了，有钱的在北京买了房，差不多的都在市里县里买的，最差的也都搬到镇上了，外面花花世界，交通方便，收入也多了，总之都算过上了小康生活。 这位无言者至今还村里，听说近几年有人给他介绍了一个新的工作，帮别人喂养扁嘴（学名鸭子），包吃包住，每年还有6000块钱的收入，年底结算，日子也算不错！ 至今我也有三四年没有见到他了，不知道为什么，总觉得对于他有一些亏欠。我的童年是跟着他长大的，他带着我们掏鸟蛋，摘茶果，春茶季节还能带着我们去采茶卖钱，然后买一毛钱一根的棒冰，夏季太热，还会带着我们去河里网鱼，捉虾，放牛的时候还会把我们抱到牛背上，吹着树笛（乡下的玩意儿：就是柳树枝儿，地上搓一搓，把皮和干分离开），在和其他庄上的孩子冲突的时候，还能挺身而出为我们强出头。 这些细节，都很感激。 再说说如今，一线城市，工作近三年，每年回两次家，还都特别匆忙，朋友都没敢见，服么都来不及道别，就麻溜儿的滚回来上班了，说起工作，对于一个没有伟大志向的人来说，还算稳定，收入也能养活自己，但我们俩人每天发愁的都还是钱，什么时候买房，什么时候结婚，什么时候要孩子，每每聊到这儿，都是一声哀叹，然后就开始失眠，每逢周末如此。 无言逝水，朋友间的关怀，一定要珍惜，如今的朋友圈，看起来很高大上，不是在炫耀就是发一些鸡汤，看多了人的智商会下降，身边处处都是低头族，方寸之间，世间万物，逝去的其实不是水，是光阴。 多年以后，你所能想起的会是某个好朋友曾经发过的一个状态？还是他曾经对你的帮助，对你的鼓励和关怀。而你呢？你给朋友留下的又是什么，是令你发愤图强的鸡汤？也许别人看着并没有任何感觉，却又不得不帮你点个赞，不点赞不是朋友等等，还是你刚买的肾6肾7呢？点赞的不是朋友，骂你傻X的才是真心的。 我也曾关闭过朋友圈，如今又打开了，因为我的智商负数，我只想让朋友知道我还活着。 愿世间多一些真诚，少一些套路，莫在浪费光阴，以致回忆无声。","categories":[{"name":"prose","slug":"prose","permalink":"https://blog.yuhanle.com/categories/prose/"}],"tags":[{"name":"prose","slug":"prose","permalink":"https://blog.yuhanle.com/tags/prose/"}]},{"title":"我知道的太多","slug":"i-know-more-more","date":"2016-05-20T01:00:00.000Z","updated":"2021-10-21T08:18:48.337Z","comments":true,"path":"2016/05/20/i-know-more-more/","link":"","permalink":"https://blog.yuhanle.com/2016/05/20/i-know-more-more/","excerpt":"正因为我们知道的太多，所以才会觉得压抑 许久没有写东西，有时候在想，思维会不会已经枯竭，除了简单的因为所以，完全忘了押韵。","text":"正因为我们知道的太多，所以才会觉得压抑 许久没有写东西，有时候在想，思维会不会已经枯竭，除了简单的因为所以，完全忘了押韵。 记得开始想着写这篇是在去年了，原本打算写成年终总结，后来发现这一年过去了，除了胡须在长，体重在增加，别的没有什么变化。 有时候走在路上，想起以前经常背的那些宋词来，全都成了零星的句子，上下阙混在一起，甚至混合了不同的词牌，不同的作者，结果却出乎意料的押韵。 我知道，是工作和生活扰乱了我。 我很害怕身边的事情太多，因为我是一个很小心的人，而且很不会同时处理多个任务，会不知所措，当然处理的结果也是一团糟。 很多时候，总是会在用到某些的时候拼命去查找，找到了仅仅是用了一下，没有归类，如此往复，明明知道没有效率，却依然已经习惯了。 这是个不好的习惯。甚至我都决定过要去改掉它，我试着开始做笔记，开始收藏一些比较感兴趣的东西，后来慢慢发现，吸引我的东西太多太多，整理的笔记已经不知道该属于哪一类了，又出现了很多很多模棱两可的东西，彼此包含，实在是很难把它在我的记忆里分离开来。 我也试着在工作和生活中，尽量独立开来，不把工作带到生活中，不带回家，于是就有了加班，不想回家，直到感觉视力欠佳，原来不知不觉中，身边的一切都在改变，都在静静的影响着你的心情，你的身体，甚至你今后的路。 说到今后的路，一定会越来越艰难，但结局总会是越来越美好。 过了早婚的年龄就真的应该婚了，家庭才是绝大部分人努力的动力。这一刻，有感觉日子好长，日复一日，什么时候可以过上一家人想过的生活。 我到底还是没学会如何关心别人。 所以不拒绝迎来的人，不挽留离去的人。 看似顺其自然，实则懦弱逃避。 当时被谁说不珍惜自己的朋友时，还委屈的不行。 然而任何朋友到最后，都只会是失去和被失去。","categories":[{"name":"suibi","slug":"suibi","permalink":"https://blog.yuhanle.com/categories/suibi/"}],"tags":[{"name":"outu","slug":"outu","permalink":"https://blog.yuhanle.com/tags/outu/"}]},{"title":"iOS工程中网络请求管理的想法","slug":"about-ios-net-manager-idea","date":"2016-02-25T02:00:00.000Z","updated":"2021-10-21T08:18:48.333Z","comments":true,"path":"2016/02/25/about-ios-net-manager-idea/","link":"","permalink":"https://blog.yuhanle.com/2016/02/25/about-ios-net-manager-idea/","excerpt":"最近一直在想一些烧脑的逻辑问题。 在此之前，我们抛出了一个网络请求框架，在这个框架中，能够很清晰的管理每一个请求，每一个回应，以及统一处理，特殊处理等，但对于开发人员来讲，这只是一个easy的文件目录而已。","text":"最近一直在想一些烧脑的逻辑问题。 在此之前，我们抛出了一个网络请求框架，在这个框架中，能够很清晰的管理每一个请求，每一个回应，以及统一处理，特殊处理等，但对于开发人员来讲，这只是一个easy的文件目录而已。 目前这个框架仍然存在很多问题，例如请求重发机制有待优化，不支持冻结网络请求，还有在页面销毁时，不支持取消未完成的请求(ps:一次性取消所有请求，但这不是我希望的效果) 先说说从新手以来对于网络请求管理这块的理解过程：说一下，我们讨论的前提是，希望无关请求都会正常cancel。 1. 统一单例类，管理所有请求该方法，提供一个单例类，还有几个请求API接口，然后在工程中任何需要网络请求的地方使用，加上url，相关参数以及callback，而且内部的核心代码也是直接与AFNetworking处理，方便快速，但是对于成百上千（这个数字可能会越来越大）的服务端接口来说，不易管理。 而且在取消全部请求的时候会出现一些意想不到的问题 举个栗子 123456A页面push B页面B页面发出了请求1请求1完成之后需要A页面发送请求2假设这个时候网络不佳而B刚好销毁了这样A的请求2还没回来就被取消所以A的数据不能及时更新 request:直接调用response：统一处理cancel:取消全部请求 如下图 2.统一非单例类，分管请求这种方法，创建一个类，每次调用请求的时候都new一个新的实例，然后由vc持有，这样做便于在页面dealloc时，直接取消当前页面发出的所有请求。请求管理类似于，谁请求，谁负责cancel。 很明显，这种方法大大增加了系统的开销，而且不符合设计思想，虽然可以方便的取消自己管理的请求，但是不支持取消全部请求。如果要支持取消全部请求的话，还需要一个管理类来管理管理请求的管理类，这样的话整个目录看起来横七竖八。 由于对回调的统一处理也是独立的，所以也会存在部分需求不满足的问题 举个栗子 123456需求中存在token过期的问题此时队列中存在很多请求请求1收到了token过期的回应（一般token过期只会保留一次，因为旧token服务器不会帮你保存太多）需要立马做出处理，比如重新登录而此时请求2、请求3可能都已发出，或者已经收到回应由于这里的处理是独立的，难免会产生各种问题 request:创建新的实例，直接调用response：单独统一处理cancel:持有者取消独自管理的全部请求 3.统一单例类，分管请求分管请求有很多种，例如可以根据功能、接口、或者页面属性来独自管理有共同特点的请求。 这里的独自管理，其实无非就是给请求加了一个标签，便于管理请求的时候，可以按照某一共同特征来管理。相比较第一种形式，他的优势在于可以按需求取消部分请求，比如在某个页面dealloc的时候，按照页面名称，取消请求队列中有关当前页面所有未完成的请求。 举个栗子 12首先支持按照标签取消请求其次统一处理可以在遇到突发情况（token过期）的时候，cancel所有请求 request:直接调用response：统一处理cancel:取消全部请求同时支持按照tag取消 开源框架结构简析1、YTKNetwork 上面的截图来自YTKNetwork的设计框架，将服务端每个api也做简单的封装处理（例如图中的RegisterApi），使用起来很舒服，但是这样写下去，需要些成百上千个.h.m，想想都觉得不可思议，当然这只是一种设计模式，方便开拓使用者更广泛的思路。 我在工程中的做法都是根据功能，将服务端的api做了分类，接口中保留了服务端需要的info，由调用者填充即可。如下图 有兴趣的朋友可以下载我的Demo捋一捋。 2、MGJRequestManager 虽然这个框架仅有两个文件，但是功能很强大，而且支持缓存，用起来如图，我们可以简单的把他当做一个请求类来使用，最好还是配合YTK的模式，封装好请求和回应，接口统一管理，这样用起来才不失效率。 截图来自：JZNetworkSingleton开源框架参考:YTKNetworkMGJRequestManager 看完YTK的框架设计，框架越复杂，功能越强大，用起来越方便 欢迎大家与我交流！！！ 本站文章如无其他特殊说明，均为原创，转载请注明出处。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.yuhanle.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.yuhanle.com/tags/iOS/"}]},{"title":"一个关于蓝牙4.0的智能硬件Demo 详解","slug":"about-ble-intelligent-hd-demo-detailed","date":"2016-01-10T09:00:00.000Z","updated":"2021-10-21T08:18:48.333Z","comments":true,"path":"2016/01/10/about-ble-intelligent-hd-demo-detailed/","link":"","permalink":"https://blog.yuhanle.com/2016/01/10/about-ble-intelligent-hd-demo-detailed/","excerpt":"写这篇详解是因为最近很多人都在问相关问题，但是上篇文章iOS-BLE蓝牙开发持续更新已经过去半年，很多东西已经开始遗忘，今天重新拾起，并在Demo中新添了具体功能和详细注释，顺便屡一下当初设计的思路，我想用图片来解释会更好理解。","text":"写这篇详解是因为最近很多人都在问相关问题，但是上篇文章iOS-BLE蓝牙开发持续更新已经过去半年，很多东西已经开始遗忘，今天重新拾起，并在Demo中新添了具体功能和详细注释，顺便屡一下当初设计的思路，我想用图片来解释会更好理解。 首先看一下几个文件的大概功能，后面在用图来分析其中的设计理念。 文件目录整个文件主要包含四大块，每一块的功能都是独立开的，不过当中却又设计不足的地方，希望各位能够积极fork，贡献代码！ QWSDiscovery 这个文件是功能的核心，主要负责和系统的CoreBluetooth沟通，比如扫描设备，连接，断开等操作。其中维护了一个设备列表，使用设备的uuid来唯一识别。在这个文件中，同时也定义了通知和错误类型，方便处理与设备之间的信息交流。 QWSBleHelper 用心的读者一定发现，在我们的每一个viewController中，只要与蓝牙功能相关，那他一定维护了一个helper。在这里我称这个页面为监护人，智能设备就像是一个孩子，很多孩子在幼儿园里，我只关心我的孩子，而这个helper就像幼儿园老师，他负责告知我们孩子在校的情况，也可以让我和孩子直接沟通。 helper中会维护两个集合，一个是我关心的设备集合，一个是即将断开的设备集合。并不是连接成功的设备就会加入到这个集合中，只有监护人发出了与这个设备相关的请求（比如说，连接，获取信息等），这个时候，hepler可以判定这个设备是被监护人关心的，从而这个设备有信息更新的时候，他会告知所有监护这个设备的监护人。 在这里之所以即将断开的设备集合是为了，在监护人发出断开请求之后，仍然能够清晰的告知监护人该设备的状态信息，等到真正断开连接之后通知到每一个监护人。 QWSBleHandler 这个文件顾名思义，就是一些代理方法。设计中是将他加入到helper中，当helper收到设备发来的信息时，通过代理将信息拆解并封装模型通知到所有监护人，写在这里纯粹只是为了看起来更加清晰，分担一下各个文件的代码压力。 QWSDevControlService 继承NSObject，封装的智能硬件设备的模型。对于智能硬件设备来讲，单单一个CBPeripheral（CoreBluetooth里的对象）是远远不够的。我们可能需要为他丰富更多的扩展信息，比如这个设备是否自动重连，是否需要断开后连接，是否认证，重连次数，版本号等，当然也可以继承CBPeripheral，但这里我觉得将CBPeripheral作为其一个属性会比较清晰。 这个对象会维护自己所有的读写操作，不管外界发来什么指令信息，他都能根据自己当前的状态，该报错报错，该执行执行，并将结果反馈给每一个监护人。 图解说明1.智能设备与移动端的关系 我们的Discovery在最顶层，不会参与与设备的直接交互，所有的收发数据都是经过系统的框架实现。 2.监护人与孩子的关系 图中的连线很多，可能很迷糊，同一种颜色的连线代表数据交互，看helper里关心的设备，可以明显理解，只有关心这个设备才会收到这个设备的信息。 每一个viewController维护一个helper，通过NSNotificationCenter广播所有操作的结果，并告知每一个关心这个设备的viewController。 简言之，就是监护人接不接受这个通知，或者老师发不发送这个消息给监护人。有一点需要明白的是，不管监护人想不想收到这个设备的消息，这个设备都是会广播自己的信息的，只是helper会判断这个孩子是不是你的~ 以上就是这个Demo的设计思路，当然Demo中仍有很多不足，之所以不敢称之为kit，是因为它确实没有达到kit的封装能力与效果，毕竟这只是一个Demo，他只是简单体现了一个设计思路，并不能达到通用的效果，因为在智能硬件这一块，每个产品的协议，属性都会有所差异，不可能做到通用的效果。希望和大家有更深入的交流与学习！ 最后回顾一下上篇文章的地址：iOS-BLE蓝牙开发持续更新 以及这个说了很久的Demo地址：一个iOS BLE蓝牙学习的Demo 在这里也顺便介绍一下近期看到的一篇关于BLE开发的kit(MPBluetoothKit iOS蓝牙框架)，作者很详细的将系统的CoreBluetooth的代理都用block实现了，看起来更加清晰与实用，也希望各位能够多多关注，共同学习。 本站文章如无其他特殊说明，均为原创，转载请注明出处。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.yuhanle.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.yuhanle.com/tags/iOS/"}]},{"title":"Cornerstone Merge操作详解","slug":"cornerstone-merge-operation-explain","date":"2015-09-27T01:00:00.000Z","updated":"2021-10-21T08:18:48.334Z","comments":true,"path":"2015/09/27/cornerstone-merge-operation-explain/","link":"","permalink":"https://blog.yuhanle.com/2015/09/27/cornerstone-merge-operation-explain/","excerpt":"Cornerstone是最好用的Mac端版本控制工具，没有之一。尾部附下载链接，类似其他指令就不说了。","text":"Cornerstone是最好用的Mac端版本控制工具，没有之一。尾部附下载链接，类似其他指令就不说了。 一步一步来1、在服务器上建立新文件并上传代码（文件操作需要谨慎） 2、文件拖放到本地，点击提交 3、如要生成新的分支 4、如果两个分支需要合并到主干，Checkout到本地，点击需要合并到的项目-&gt;Merge-&gt;Sychronize Branch选择需要从被合并的项目（merge from）合并到这里，然后提交就可以了（如果同时有两个分支，最需仍需要在分支上修改的话，先合并一个分支到主干，然后主干在合并到另一个分支，修改冲突后提交，前提是，刚开始主干和两个分支的代码一样，参考上边的步骤生成） 详解12341.在workcopying中选择目标copying，然后点击Merge，如图所示2.选择Mergefrom的copying3.Merge之前cornerstone会进行dry run，进行merge分析和预览4.确认无误后Merge Changes （该操作是本地操作，注意解决冲突后在commit） 下载 Cornerstone 2.7.10 破解版（支持正版）链接：http://pan.baidu.com/s/1o6VRtcI 密码: p523 本站文章如无其他特殊说明，均为原创，转载请注明出处。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.yuhanle.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.yuhanle.com/tags/iOS/"}]},{"title":"总觉得日子过得并不那么潇洒","slug":"always-feel-that-life-not-so-chic","date":"2015-09-20T03:00:00.000Z","updated":"2021-10-21T08:18:48.333Z","comments":true,"path":"2015/09/20/always-feel-that-life-not-so-chic/","link":"","permalink":"https://blog.yuhanle.com/2015/09/20/always-feel-that-life-not-so-chic/","excerpt":"生活，一种是别人看的，一种只为心安。 初到上海，总觉得这个城市并没有那么令人向往，处处都是钢筋混凝土，风一吹过，弥漫着各种气息，五味杂呈。每天的工作，日复一日，好像没怎么变着，而生活早已被工作掩埋，对家竟然没有一丝挂念。","text":"生活，一种是别人看的，一种只为心安。 初到上海，总觉得这个城市并没有那么令人向往，处处都是钢筋混凝土，风一吹过，弥漫着各种气息，五味杂呈。每天的工作，日复一日，好像没怎么变着，而生活早已被工作掩埋，对家竟然没有一丝挂念。 慢慢的回家越来越晚，睡得也是越来越晚，即使很困，睡前也要翻翻网易新闻，看一看今天的事情，刷一刷有趣的微博，而朋友就在这一分一秒种，似乎大家都在忙，没有谁会主动联系。 有时候，会很想去百度（一个神奇的网站）。总是莫名其妙的搜索一个问题，一个困扰我很久很难的问题，如何让自己在互联网消失？明明知道，这就像做了错事奢求后悔药一样，可是每当孤独的时候，这确实我唯一能想到的，也是我所不能办到的。 生活很奇特，我们一边在了解着自己，又一边改变着自己，直到最后，永远无法真正的认识自己，可随着时间的流逝，对朋友，对亲人慢慢变得麻木，放佛身边只有自己的背影，总是不那么潇洒！ 每当安静的时候，却不能真正静下来，脑海里思绪乱飞，游离在恐惧孤独之中，我觉得我已经被抹去了，不管想到的是什么，似乎也都与我无关了。 生活，一种是给别人看的。 对于我，我不在乎别人是怎么看我，当然这只是表象，我会在乎你不怎么看我。我会尽心尽力做好自己，我所认为的，对我来说是经过深思的，有时候也容易冲动，而且也不会圆场，最终其实对我的伤害最大，即使因为某些原因，我会妥协，而且经常妥协，但我从不认为我是错的，有些东西就是抓的太紧，不妥协会失去，但都只是暂时的。 可能，从来没有人会羡慕我。 记得以前在学校，我的成绩很好，当然只是小地方，那个时候，对于社会还并没有什么概念，总之就是自我感觉良好，也喜欢玩，但不喜欢闹。身边也总会有或多或少的朋友，每当一个阶段结束，好似换了一个地方，再也没有联系，经常有段时间，会觉得那些朋友过去了太可惜，现在想想也不过如此，谁会需要哪么多得朋友呢？好人的形象，让我觉得虚伪。像是伪装，还不知道自己能坚持多久，总好像这些都是做给别人看的。吃饭是为了活着，挣钱是为了活的更好，可始终不明白活着是为了干嘛，做一个好人？ 总想让自己心安。 让自己心安理得，继续装下去。今天多做点，明天就能多歇息，可日子这么长，时间又很短，总有一些理由，让自己心安。反正，就是不潇洒，即使很心安，也很明确的感觉 这些都是假的。做完一件事，这个阶段就结束了。即使压力再大，也能如释重负，谁让这都是过程呢。 能坚持到最后，却不一定是第一。这是绝望，让你背负着压力前行","categories":[{"name":"suibi","slug":"suibi","permalink":"https://blog.yuhanle.com/categories/suibi/"}],"tags":[{"name":"outu","slug":"outu","permalink":"https://blog.yuhanle.com/tags/outu/"}]},{"title":"像极了一个愤青","slug":"it-seems-like-a-cynical","date":"2015-08-20T06:00:00.000Z","updated":"2021-10-21T08:18:48.337Z","comments":true,"path":"2015/08/20/it-seems-like-a-cynical/","link":"","permalink":"https://blog.yuhanle.com/2015/08/20/it-seems-like-a-cynical/","excerpt":"节前一晚，感觉工作有告一段落，就开始安静地想些事情，在工作的时候，人与人的相处，关系一直很微妙。 从第一次见面的拘谨，到后来工作中的接触，一个人的性格，决定了接下来的命运。","text":"节前一晚，感觉工作有告一段落，就开始安静地想些事情，在工作的时候，人与人的相处，关系一直很微妙。 从第一次见面的拘谨，到后来工作中的接触，一个人的性格，决定了接下来的命运。 不管是在学校，还是毕业后，游荡在各个城市之间，对自己的感觉都是内向，好朋友面前，始终尽力保持着老实人，作风严谨的形象，可更多的时候不愿意去承认这个事实，以至于在他们的面前毫无遮掩，但面对陌生人或是崇拜的人，内向，自卑就显露无遗。 这种性格很怪，也很恼。 当在安静的时候，我羡慕那些能坐下来，认认真真的读完一本书的人。身边的同事，有的能待在办公室一整天，除了中午花费半个小时的时间外出吃饭，然后慢悠悠的回到座位，继续剩下的工作，能完完整整写一遍代码，安安静静处理手上的问题，虽然与人沟通很少，但是却从不影响工作的进度。 很多时候，本人也是一个安静的人，只是不想说话，简简单单的看看书，玩玩手机，或者找个地方坐坐，看看周围来来往往的人。特别喜欢看小孩子，淘气的到处乱跑，然后被牵着鼻子打一顿，这也许是我觉得最开心的事，从未觉得夜晚会如此和谐。 当朋友们聚的开心，心里很想与大家打成一片，可是总觉得哪里不对，我的形象，我是一个安静的人，这样闹会不会不正常，但其实心里很羡慕他们的吵吵闹闹，痛痛快快的high一场。内向的人，最受不了委屈，可能也只是某些人吧，对于我肯定就是这样的，想说话，说出来的可能都是抱怨。 对于抱怨，其实我是很不愿意承认的事实。 甚至，我都觉得我的所作所为所抱怨，都不是为了自己，像极了一个愤青，看不惯的东西太多，不停的在给自己施加无形的负担，直到压倒自己喘不过气，才又感叹一番，跟别人讲起了大道理，说什么要做一个快乐的人，做一个对社会有用的人 。 没有谁会承认自己抱怨，也没有谁愿意去听一个人抱怨。 愤青对我来说，可能是一种理想状态吧。总觉得愤青比抱怨更胜一筹，抱怨像极了贬义词，像小人，像怨妇，像那些没人愿意接触的人与物。总会觉得这个不合理，那个应该改改，有好也有坏，却很难做起来，习惯了去教导别人，甚至去教别人怎么做。 说实话，如果我是我，我不愿意和这样的人做朋友，他很孤独。","categories":[{"name":"suibi","slug":"suibi","permalink":"https://blog.yuhanle.com/categories/suibi/"}],"tags":[{"name":"think","slug":"think","permalink":"https://blog.yuhanle.com/tags/think/"}]},{"title":"我离成功又近了一步","slug":"i-am-closer-away-from-success","date":"2015-08-20T04:00:00.000Z","updated":"2021-10-21T08:18:48.337Z","comments":true,"path":"2015/08/20/i-am-closer-away-from-success/","link":"","permalink":"https://blog.yuhanle.com/2015/08/20/i-am-closer-away-from-success/","excerpt":"手机升级出了问题，工作也就没法继续。 上次，听到了同事的这句话，我思考了很久，短短的九个字，概括了在上海这个城市奋斗五六年的无奈，同时又对未来充满了希望。","text":"手机升级出了问题，工作也就没法继续。 上次，听到了同事的这句话，我思考了很久，短短的九个字，概括了在上海这个城市奋斗五六年的无奈，同时又对未来充满了希望。 语文不好，不知道怎么才能更好地解释这几个字，汉字很有吸引力，特别是这些让人思绪乱飞的，如果不是本人，根本不可能了解到某人说这时的真实感受，每个人的经历不同，见解不同。 话太多，总感觉说不完，得先起一个头儿。 其实那天，在车上，想到这个话题的时候，我就觉得凭借手机余下的电量，根本不够我用，过了几天回到公司，差点忘了这件事，怪不得古话说的及时行乐，还是很有道理。 说这九个字，应该是高兴的。 几年甚至几十年的努力，才有一次令自己满意的结果。想起了过去，从大学开始，才考虑成功的问题，但都因为自认为平凡人居多，却一直想着做一个平凡的人，没什么追求。虽然如此，但也会因为一些小的成就而深深自喜，作为一名理工男，暗地里也会找一些动手性较强的事情来找找成就感，刷机拆本都是家常便饭，时间久了，慢慢从兴趣变成了无聊打发时间。 有段时间，都会有一段喜欢干的事，但是没有坚持多久，总会给自己找这样那样的理由，让偶尔的兴趣都淡出在自己的世界。有很多人说，专业是工作，兴趣是生活。如果能把兴趣做成工作，应该是最好的工作吧！ 说这九个字，应该是无奈的。 学生时代，人人都向往着第一名。位居千年老二太久的话，整个人都会不好了，工作没有激情，生活没有尽头。离成功又近了一步，不过距离是未知的，结局是待定的，能不能继续走下去也得看心情。久了，都麻木了，淡却了。面对着周围越来越多的人，我们开始茫然不知所措，或者妄自菲薄，主动的把自己“安排”到一个较低的位置上。这也许是前进的路上，许多人都要走的一条路。 有多少人和我一样，坐在不足10平米的空间里，看着书里九万五千公里的绚丽。又或是和我一样，拥有一颗比九万五千公里还辽阔的心，却坐在不足一平米的椅子上。","categories":[{"name":"suibi","slug":"suibi","permalink":"https://blog.yuhanle.com/categories/suibi/"}],"tags":[{"name":"think","slug":"think","permalink":"https://blog.yuhanle.com/tags/think/"}]},{"title":"你还能做技术多久","slug":"how-long-can-you-do-it","date":"2015-07-20T05:00:00.000Z","updated":"2021-10-21T08:18:48.336Z","comments":true,"path":"2015/07/20/how-long-can-you-do-it/","link":"","permalink":"https://blog.yuhanle.com/2015/07/20/how-long-can-you-do-it/","excerpt":"这时候，我在车上。 距离那次面试已经有五个月零十五天，","text":"这时候，我在车上。 距离那次面试已经有五个月零十五天，后来就遇到了现在的老大，现在这个公司。 以性格而言，做技术再好不过，直到前两天头问了我，你觉得你做技术能做多久？ 这个问题并不陌生，毕业后一个人来到上海，走之前女朋友也问过类似的问题，隐约记得当时并没有想在上海呆太久，做个三五年吧，然后回郑州与自己想做的事业，至于什么事业，有可能仍然是技术。 我把这个回答给了头儿，他听完之后笑了笑，说当时你来面试的时候，我问过你这个问题，你不是这样回答的。不知道我为什么心虚了，我突然不知道该说什么，该怎么回答这个问题，就把话题转移到公司一位做了十几年技术的同事身上，当然我们头儿经历更多更丰富。我承认，对于这个问题，我一直在回避，以至于每一次的回答都会不同，而且我没有重视过它，因此也就毫无印象当初是怎么回答的。 对于我来说，技术性的工作对我很有挑战，也很有吸引力，如果可以，我愿意在这条路上走得更远。三五年后，我在做什么，很难预测，特别是互联网这个方向，没有什么是一成不变的，现在说什么都太早，不过这肯定不是头儿要的答案。我觉得，应该有一个支撑你直走这条路的勇气，我很希望我的答复是一直做下去，但是现实是不允许勇气来任性的。 我倒是很珍惜这几年的经历和经验，三五年后我在做什么跟这些息息相关。 讲到这儿，想起了刚来公司那年，年会上有位同事拿了一个大奖，但是不是最佳的，这位同事是做安卓开发的，平时话不多，我们也只是在工作问题上有过交流，他的获奖感言就一句话，我离成功又近了一步。 这将是下一个话题，暂不讨论。 回到正题上，不管是做什么，技术也好，销售也好，或者是什么大老板，不满足现状，就肯定会通过改变自己来适应它，当然绝大部分是为了去改善。所以，对于这个话题，能做技术多久，并不是我能决定的，我只是说出了我所想的，That is enough!","categories":[{"name":"suibi","slug":"suibi","permalink":"https://blog.yuhanle.com/categories/suibi/"}],"tags":[{"name":"think","slug":"think","permalink":"https://blog.yuhanle.com/tags/think/"}]},{"title":"iOS-BLE蓝牙开发持续更新","slug":"ble-development-continuously-update","date":"2015-06-24T09:00:00.000Z","updated":"2021-10-21T08:18:48.334Z","comments":true,"path":"2015/06/24/ble-development-continuously-update/","link":"","permalink":"https://blog.yuhanle.com/2015/06/24/ble-development-continuously-update/","excerpt":"在写这个博客之前，空余时间抽看了近一个月的文档和Demo，系统给的解释很详细，接口也比较实用，唯独有一点，对于设备的唯一标示，网上众说纷纭，在这里我目前也还没有自己的见解，只是在不断的测试各种情况，亲测同一设备的UUID对于每台iPhone设备都不一样，只能尽量保证设备的唯一性，特别是自动重连的过程，让用户没有感知。","text":"在写这个博客之前，空余时间抽看了近一个月的文档和Demo，系统给的解释很详细，接口也比较实用，唯独有一点，对于设备的唯一标示，网上众说纷纭，在这里我目前也还没有自己的见解，只是在不断的测试各种情况，亲测同一设备的UUID对于每台iPhone设备都不一样，只能尽量保证设备的唯一性，特别是自动重连的过程，让用户没有感知。我之前也找了很久，发现CBCentralManager和CBPeripheral里边都找不到和Mac地址有关的东西，后来发现一般是外设在Device Information服务中的某个特征返回的。经过与硬件工程师的协商，决定APP端将从这个服务中获取到蓝牙设备以及我的iPhone手机的蓝牙Mac地址，为自动连接的唯一性做准备。 这里经过和硬件工程师的测试，发现设备端在获取手机蓝牙MAC地址的时候，当用户手机重启之后，这个地址也是会随机变化的，也就是说，作为开发者，只有设备的MAC地址能够保持唯一性不变化。 如有疑问的朋友可以先去这里瞅一瞅：一个关于蓝牙4.0的智能硬件Demo详解 下面是两台iPhone6连接同一台蓝牙设备的结果： 1234**成功连接**** peripheral: &lt;CBPeripheral: 0x1700f4500, identifier = 50084F69-BA5A-34AC-8A6E-6F0CEADB21CD, name = 555555555588, state = connected&gt; with UUID: &lt;__NSConcreteUUID 0x17003d980&gt; 50084F69-BA5A-34AC-8A6E-6F0CEADB21CD************成功连接**** peripheral: &lt;CBPeripheral: 0x1742e3000, identifier = 55B7D759-0F1E-6271-EA14-BC5A9C9EEEEC, name = 555555555588, state = connected&gt; with UUID: &lt;__NSConcreteUUID 0x174036c00&gt; 55B7D759-0F1E-6271-EA14-BC5A9C9EEEEC** 进入正题iOS的蓝牙开发很简单，只要包含一个库，创建CBCentralManager实例，实现代理方法，然后就可以直接和设备进行通信。 1#import &lt;CoreBluetooth/CoreBluetooth.h&gt; 首先可以定义一些即将使用到的UUID的宏 123#define kPeripheralName @&quot;360qws Electric Bike Service&quot; //外围设备名称#define kServiceUUID @&quot;7CACEB8B-DFC4-4A40-A942-AAD653D174DC&quot; //服务的UUID#define kCharacteristicUUID @&quot;282A67B2-8DAB-4577-A42F-C4871A3EEC4F&quot; //特征的UUID 如果不是把手机作为中心设备的话，这些没有必要设置。这里我也没有用到，仅仅是提了一下，具体操作后续添加。 对于生成UUID，大家可以谷歌一下，直接通过mac终端生成32位UUID。 声明属性 12345678910111213@property (weak, nonatomic) IBOutlet UITableView *bluetoothTable;@property (weak, nonatomic) IBOutlet UITextView *resultTextView;@property BOOL cbReady;@property(nonatomic) float batteryValue;@property (nonatomic, strong) CBCentralManager *manager;@property (nonatomic, strong) CBPeripheral *peripheral;@property (strong ,nonatomic) CBCharacteristic *writeCharacteristic;@property (strong,nonatomic) NSMutableArray *nDevices;@property (strong,nonatomic) NSMutableArray *nServices;@property (strong,nonatomic) NSMutableArray *nCharacteristics; 遵守协议(这里我用到了table) 1@interface ViewController () &lt;CBCentralManagerDelegate, CBPeripheralDelegate, UITableViewDataSource, UITableViewDelegate&gt; 初始化数据 123456789101112131415- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. self.manager = [[CBCentralManager alloc] initWithDelegate:self queue:nil]; _cbReady = false; _nDevices = [[NSMutableArray alloc]init]; _nServices = [[NSMutableArray alloc]init]; _nCharacteristics = [[NSMutableArray alloc]init]; _bluetoothTable.delegate = self; _bluetoothTable.dataSource = self; count = 0;&#125; 实现蓝牙的协议方法 （1）检测蓝牙状态 123456789101112131415161718//开始查看服务，蓝牙开启-(void)centralManagerDidUpdateState:(CBCentralManager *)central&#123; switch (central.state) &#123; case CBCentralManagerStatePoweredOn: &#123; [self updateLog:@&quot;蓝牙已打开,请扫描外设&quot;]; [_activity startAnimating]; [_manager scanForPeripheralsWithServices:@[[CBUUID UUIDWithString:@&quot;FF15&quot;]] options:@&#123;CBCentralManagerScanOptionAllowDuplicatesKey : @YES &#125;]; &#125; break; case CBCentralManagerStatePoweredOff: [self updateLog:@&quot;蓝牙没有打开,请先打开蓝牙&quot;]; break; default: break; &#125;&#125; 注： 12// @[[CBUUID UUIDWithString:@&quot;FF15&quot;]] 是为了过滤掉其他设备，可以搜索特定标示的设备。[_manager scanForPeripheralsWithServices:@[[CBUUID UUIDWithString:@&quot;FF15&quot;]] options:@&#123;CBCentralManagerScanOptionAllowDuplicatesKey : @YES &#125;]; （2）检测到外设后，停止扫描，连接设备 12345678910111213141516171819202122232425//查到外设后，停止扫描，连接设备-(void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary *)advertisementData RSSI:(NSNumber *)RSSI&#123; [self updateLog:[NSString stringWithFormat:@&quot;已发现 peripheral: %@ rssi: %@, UUID: %@ advertisementData: %@ &quot;, peripheral, RSSI, peripheral.identifier, advertisementData]]; _peripheral = peripheral; [_manager connectPeripheral:_peripheral options:nil]; [self.manager stopScan]; [_activity stopAnimating]; BOOL replace = NO; // Match if we have this device from before for (int i=0; i &lt; _nDevices.count; i++) &#123; CBPeripheral *p = [_nDevices objectAtIndex:i]; if ([p isEqual:peripheral]) &#123; [_nDevices replaceObjectAtIndex:i withObject:peripheral]; replace = YES; &#125; &#125; if (!replace) &#123; [_nDevices addObject:peripheral]; [_bluetoothTable reloadData]; &#125;&#125; （3）连接外设后的处理 123456789101112131415161718192021222324//连接外设成功，开始发现服务- (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral &#123; NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;成功连接 peripheral: %@ with UUID: %@&quot;,peripheral,peripheral.identifier]); [self updateLog:[NSString stringWithFormat:@&quot;成功连接 peripheral: %@ with UUID: %@&quot;,peripheral,peripheral.identifier]]; [self.peripheral setDelegate:self]; [self.peripheral discoverServices:nil]; [self updateLog:@&quot;扫描服务&quot;];&#125;//连接外设失败-(void)centralManager:(CBCentralManager *)central didFailToConnectPeripheral:(CBPeripheral *)peripheral error:(NSError *)error&#123; NSLog(@&quot;%@&quot;,error);&#125;-(void)peripheralDidUpdateRSSI:(CBPeripheral *)peripheral error:(NSError *)error&#123; NSLog(@&quot;%s,%@&quot;,__PRETTY_FUNCTION__,peripheral); int rssi = abs([peripheral.RSSI intValue]); CGFloat ci = (rssi - 49) / (10 * 4.); NSString *length = [NSString stringWithFormat:@&quot;发现BLT4.0热点:%@,距离:%.1fm&quot;,_peripheral,pow(10,ci)]; [self updateLog:[NSString stringWithFormat:@&quot;距离：%@&quot;, length]];&#125; （4）发现服务和搜索到的Characteristice 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//已发现服务-(void) peripheral:(CBPeripheral *)peripheral didDiscoverServices:(NSError *)error&#123; [self updateLog:@&quot;发现服务.&quot;]; int i=0; for (CBService *s in peripheral.services) &#123; [self.nServices addObject:s]; &#125; for (CBService *s in peripheral.services) &#123; [self updateLog:[NSString stringWithFormat:@&quot;%d :服务 UUID: %@(%@)&quot;,i,s.UUID.data,s.UUID]]; i++; [peripheral discoverCharacteristics:nil forService:s]; if ([s.UUID isEqual:[CBUUID UUIDWithString:@&quot;FF15&quot;]]) &#123; BOOL replace = NO; // Match if we have this device from before for (int i=0; i &lt; _nDevices.count; i++) &#123; CBPeripheral *p = [_nDevices objectAtIndex:i]; if ([p isEqual:peripheral]) &#123; [_nDevices replaceObjectAtIndex:i withObject:peripheral]; replace = YES; &#125; &#125; if (!replace) &#123; [_nDevices addObject:peripheral]; [_bluetoothTable reloadData]; &#125; &#125; &#125;&#125;//已搜索到Characteristics-(void) peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(NSError *)error&#123; [self updateLog:[NSString stringWithFormat:@&quot;发现特征的服务:%@ (%@)&quot;,service.UUID.data ,service.UUID]]; for (CBCharacteristic *c in service.characteristics) &#123; [self updateLog:[NSString stringWithFormat:@&quot;特征 UUID: %@ (%@)&quot;,c.UUID.data,c.UUID]]; if ([c.UUID isEqual:[CBUUID UUIDWithString:@&quot;FF01&quot;]]) &#123; _writeCharacteristic = c; &#125; if ([c.UUID isEqual:[CBUUID UUIDWithString:@&quot;FF02&quot;]]) &#123; [_peripheral readValueForCharacteristic:c]; [_peripheral setNotifyValue:YES forCharacteristic:c]; &#125; if ([c.UUID isEqual:[CBUUID UUIDWithString:@&quot;FF04&quot;]]) &#123; [_peripheral readValueForCharacteristic:c]; &#125; if ([c.UUID isEqual:[CBUUID UUIDWithString:@&quot;FF05&quot;]]) &#123; [_peripheral readValueForCharacteristic:c]; [_peripheral setNotifyValue:YES forCharacteristic:c]; &#125; if ([c.UUID isEqual:[CBUUID UUIDWithString:@&quot;FFA1&quot;]]) &#123; [_peripheral readRSSI]; &#125; [_nCharacteristics addObject:c]; &#125;&#125;- (void)centralManager:(CBCentralManager *)central didDisconnectPeripheral:(CBPeripheral *)peripheral error:(NSError *)error &#123; [self updateLog:[NSString stringWithFormat:@&quot;已断开与设备:[%@]的连接&quot;, peripheral.name]];&#125; （5）获取外设发来的数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119//获取外设发来的数据，不论是read和notify,获取数据都是从这个方法中读取。- (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error&#123; if ([characteristic.UUID isEqual:[CBUUID UUIDWithString:@&quot;FF02&quot;]]) &#123; NSData * data = characteristic.value; Byte * resultByte = (Byte *)[data bytes]; for(int i=0;i&lt;[data length];i++) printf(&quot;testByteFF02[%d] = %d\\n&quot;,i,resultByte[i]); if (resultByte[1] == 0) &#123; switch (resultByte[0]) &#123; case 3: // 加解锁 &#123; if (resultByte[2] == 0) &#123; [self updateLog:@&quot;撤防成功!!!&quot;]; &#125;else if (resultByte[2] == 1) &#123; [self updateLog:@&quot;设防成功!!!&quot;]; &#125; &#125; break; case 4: // 开坐桶 &#123; if (resultByte[2] == 0) &#123; [self updateLog:@&quot;关坐桶成功!!!&quot;]; &#125;else if (resultByte[2] == 1) &#123; [self updateLog:@&quot;开坐桶成功!!!&quot;]; &#125; &#125; break; case 5: // 锁定电机 &#123; if (resultByte[2] == 0) &#123; [self updateLog:@&quot;解锁电机控制器成功!!!&quot;]; &#125;else if (resultByte[2] == 1) &#123; [self updateLog:@&quot;锁定电机控制器成功!!!&quot;]; &#125; &#125; break; default: break; &#125; &#125;else if (resultByte[1] == 1) &#123; [self updateLog:@&quot;未知错误&quot;]; &#125;else if (resultByte[1] == 2) &#123; [self updateLog:@&quot;鉴权失败&quot;]; &#125; &#125; if ([characteristic.UUID isEqual:[CBUUID UUIDWithString:@&quot;FF04&quot;]]) &#123; NSData * data = characteristic.value; Byte * resultByte = (Byte *)[data bytes]; for(int i=0;i&lt;[data length];i++) printf(&quot;testByteFF04[%d] = %d\\n&quot;,i,resultByte[i]); if (resultByte[0] == 0) &#123; // 未绑定 -》写鉴权码 [self updateLog:@&quot;当前车辆未绑定，请鉴权&quot;]; [self authentication]; // 鉴权 [self writePassword:nil newPw:nil]; &#125;else if (resultByte[0] == 1) &#123; // 已绑定 -》鉴权 [self updateLog:@&quot;当前车辆已经绑定，请鉴权&quot;]; [self writePassword:nil newPw:nil]; &#125;else if (resultByte[0] == 2) &#123; // 允许绑定 [self updateLog:@&quot;当前车辆允许绑定&quot;]; &#125; &#125; if ([characteristic.UUID isEqual:[CBUUID UUIDWithString:@&quot;FF05&quot;]]) &#123; NSData * data = characteristic.value; Byte * resultByte = (Byte *)[data bytes]; for(int i=0;i&lt;[data length];i++) printf(&quot;testByteFF05[%d] = %d\\n&quot;,i,resultByte[i]); if (resultByte[0] == 0) &#123; // 设备加解锁状态 0 撤防 1 设防 [self updateLog:@&quot;当前车辆撤防状态&quot;]; &#125;else if (resultByte[0] == 1) &#123; // 设备加解锁状态 0 撤防 1 设防 [self updateLog:@&quot;当前车辆设防状态&quot;]; &#125; &#125;&#125;//中心读取外设实时数据- (void)peripheral:(CBPeripheral *)peripheral didUpdateNotificationStateForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error &#123; if (error) &#123; NSLog(@&quot;Error changing notification state: %@&quot;, error.localizedDescription); &#125; // Notification has started if (characteristic.isNotifying) &#123; [peripheral readValueForCharacteristic:characteristic]; &#125; else &#123; // Notification has stopped // so disconnect from the peripheral NSLog(@&quot;Notification stopped on %@. Disconnecting&quot;, characteristic); [self updateLog:[NSString stringWithFormat:@&quot;Notification stopped on %@. Disconnecting&quot;, characteristic]]; [self.manager cancelPeripheralConnection:self.peripheral]; &#125;&#125;//用于检测中心向外设写数据是否成功-(void)peripheral:(CBPeripheral *)peripheral didWriteValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error&#123; if (error) &#123; NSLog(@&quot;=======%@&quot;,error.userInfo); [self updateLog:[error.userInfo JSONString]]; &#125;else&#123; NSLog(@&quot;发送数据成功&quot;); [self updateLog:@&quot;发送数据成功&quot;]; &#125; /* When a write occurs, need to set off a re-read of the local CBCharacteristic to update its value */ [peripheral readValueForCharacteristic:characteristic];&#125; 后记 最主要是用 UUID 来确定你要干的事情，特征和服务的 UUID 都是外设定义好的。我们只需要读取，确定你要读取什么的时候，就去判断UUID是否相符。 一般来说我们使用的 iPhone 都是做centralManager 的，蓝牙模块是 peripheral 的，所以我们是 want datas，需要接受数据。 判断状态为 powerOn，然后执行扫描 停止扫描，连接外设 连接成功，寻找服务 在服务里寻找特征 为特征添加通知 通知添加成功，那么就可以实时的读取value[也就是说只要外设发送数据[一般外设的频率为10Hz]，代理就会调用此方法 处理接收到的 value，[hex值，得转换] 之后就自由发挥了，在这期间都是通过代理来实现的，也就是说你只需要处理你想要做的事情，代理会帮你调用方法 2015-07-28 更关于 Write 这里还有些注意的地方！！！！并不是每一个 Characteristic 都可以通过回调函数来查看它写入状态的。就比如针对 immediateAlertService（1802） 的 alertLevelCharacteristic（2A06），就是一个不能有 response 的 Characteristic。刚开始我就一直用 CBCharacteristicWriteType.WithResponse 来进行写入始终不成功，郁闷坏了，最后看到每个 Characteristic 还有个属性值是指示这个的，我将每个 Characteristic 打印出来有如下信息： 12immediateAlertService Discover characteristic &lt;CBCharacteristic: 0x15574d00, UUID = 2A06, properties = 0x4, value = (null), notifying = NO&gt;linkLossAlertService Discover characteristic &lt;CBCharacteristic: 0x15671d00, UUID = 2A06, properties = 0xA, value = (null), notifying = NO&gt; 这个的 properties 是什么刚开始不知道，觉得他没意义，后面才注意到 properties 是 Characteristic 的一个参数，具体解释如下： 123456789101112typedef enum &#123; CBCharacteristicPropertyBroadcast = 0x01, CBCharacteristicPropertyRead = 0x02, CBCharacteristicPropertyWriteWithoutResponse = 0x04, CBCharacteristicPropertyWrite = 0x08, CBCharacteristicPropertyNotify = 0x10, CBCharacteristicPropertyIndicate = 0x20, CBCharacteristicPropertyAuthenticatedSignedWrites = 0x40, CBCharacteristicPropertyExtendedProperties = 0x80, CBCharacteristicPropertyNotifyEncryptionRequired = 0x100, CBCharacteristicPropertyIndicateEncryptionRequired = 0x200,&#125; CBCharacteristicProperties; 可以看到 0x04: CBCharacteristicPropertyWriteWithoutResponse 0x10: CBCharacteristicPropertyNotify 所以 immediateAlertService（1802） 的 alertLevelCharacteristic（2A06）是不能用 CBCharacteristicWriteType.WithRespons 进行写入，只能用 CBCharacteristicWriteType.WithOutRespons。这样在以后的开发中可以对每个Characteristic的这个参数进行检查再进行设置。 最后讲一下关于蓝牙绑定的过程，在 iOS 中，没有讲当绑定的过程，直接就是扫描、连接、交互。从而很多人会认为，连接就是绑定了，其实不然。在 iOS 开发中，连接并没有完成绑定，在网上找到了个很好的解释： you cannot initiate pairing from the iOS central side. Instead, you have to read/write a characteristic value,and then let your peripheral respond with an “Insufficient Authentication” error.iOS will then initiate pairing, will store the keys for later use (bonding) and encrypts the link. As far as I know,it also caches discovery information, so that future connections can be set up faster. 就是当发生读写交互时，系统在会和外设进行绑定操作!!! 2016-02-20 更ios蓝牙如何获取广播包数据 如题，手机作为主设备，在使用 CoreBluetooth 时候，想获取蓝牙的数据广播包。在使用1- (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)aPeripheral advertisementData:(NSDictionary *)advertisementData RSSI:(NSNumber *)RSSI 方法时候获取的 advertisementData 打印出来只有1** ****kCBAdvDataIsConnectable****kCBAdvDataLocalName****kCBAdvDataManufacturerData** 三个属性对应的值，但这并非广播包的数据。例如安卓可以通过 scandata 来获取到广播包的值，那么 iOS 这边我应该怎么做呢？ 好像苹果这边禁止读取这种广播内容的的，真要的话你可以让硬件那边把数据做到 kCBAdvDataManufacturerData 这个字段里面。 Demo地址：一个蓝牙4.0的智能硬件Demo 本站文章如无其他特殊说明，均为原创，转载请注明出处。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.yuhanle.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.yuhanle.com/tags/iOS/"}]},{"title":"你到底好不好","slug":"are-you-good-or-not","date":"2015-04-20T02:00:00.000Z","updated":"2021-10-21T08:18:48.333Z","comments":true,"path":"2015/04/20/are-you-good-or-not/","link":"","permalink":"https://blog.yuhanle.com/2015/04/20/are-you-good-or-not/","excerpt":"提笔写这篇文章已经思考很久了，缘由来于一个初中朋友，异性朋友，很难得的是，我们不仅认识，而且还是同年同月同日的密友，虽不常联系，但比任何人感情都深。","text":"提笔写这篇文章已经思考很久了，缘由来于一个初中朋友，异性朋友，很难得的是，我们不仅认识，而且还是同年同月同日的密友，虽不常联系，但比任何人感情都深。 过两天就要去北京参加婚礼了，提前和她约了一下，上次见面应该是3年前了吧！在聊及到彼此生活的时候，她无意发了几句牢骚，说身边的朋友都说她的男朋友很好，可能是她脾气不好，或者其他原因，身边的朋友都被男朋友拉拢了，这让自己觉得又高兴又苦逼，高兴的是找了一个大家公认的好男人，苦逼的是朋友说这些话到底是什么意思。 后来，她补充了一句。可谁知道，我一直在朋友面前说他好，即使有时候真的很令人生气，但是还是会跟朋友讲自己男朋友的好。 听完了，我觉得貌似很有道理。 突然一个问题就来了，一个人好不好该怎么去评估？ 人都是自恋的，这是真理。要去承认一个人，对于自己来讲，截然是一个挑战。朋友眼中的你的形象很重要，我是这么以为的。 年轻时，我对人或事的是与非有一个自己的判断。 第一，少数服从多数。生活中，有些人令人觉得很奇怪，因为他们的想法始终和现实差一大截，很多人都喜欢据理力争，这是情有可原的，委曲求全不是这样表现。如果所有人都说这是错的，我想也没有必要再去坚持，方向应该是很重要的，一味的坚持原则往往适得其反，让朋友们都觉得你是傻逼，或许自己都这么觉得。也就是说，大家都认为这人的行为习惯不合适，除非存在臭味相投，我相信大家的评价。 第二，多数服从少数。有些人的眼光很独到，这是我们平凡人不可能学到的，看再多的书也没有用。对于一个人的了解也是这样，太过亲近的人虽然了解的多，但是难免带着感情来评价一个人的好与坏，亲近的也毕竟是少数，我们看到的不是同一个人，一件小事很有可能改变了你在朋友眼中的形象。说到这里，我不赞成人活着，活得小心翼翼。 第三，不要去评论一个人。人都很容易被影响，当我们在评论一个人，特别是缺点的时候，我相信很多人都已经放弃你这个朋友了。so，在这里，我特别不喜欢女孩子八卦。一些好听的话，我听着都会难受，不好的也当耳旁风，正正衣冠继续当我的禽兽！ 仅仅是品感觉，来判断一个人的好与坏。就像三国杀里一样，每个人都在玩心计，判断的正确与否，概率性很大，但是如果我们去在乎每一个细节，像内奸一样，后来会死的很惨！ 对于这个标题，我没有结论，也没有想法去整理，平凡人不是社会学家，我们把最直观，最朴素的东西累积起来，让别人去研究，去思考，这应该就是我们活着，为人处世的意义。 大家都是，从不否认自己是一个好人，却很难接受自己也曾做过哪些坏事，慢慢就变成了自己曾经最讨厌的那个人。 那个人是谁？ 好像是一条狗。","categories":[{"name":"suibi","slug":"suibi","permalink":"https://blog.yuhanle.com/categories/suibi/"}],"tags":[{"name":"outu","slug":"outu","permalink":"https://blog.yuhanle.com/tags/outu/"}]},{"title":"梅花小苏","slug":"xiaoshi-plum-flower-say","date":"2014-05-21T00:00:00.000Z","updated":"2021-10-21T08:18:48.340Z","comments":true,"path":"2014/05/21/xiaoshi-plum-flower-say/","link":"","permalink":"https://blog.yuhanle.com/2014/05/21/xiaoshi-plum-flower-say/","excerpt":"偶过空间，视动态，梅花怒放，香意正浓，簇簇枝头，如朝阳似火，醉迷人心。","text":"偶过空间，视动态，梅花怒放，香意正浓，簇簇枝头，如朝阳似火，醉迷人心。树下更有一佳人，身着粉色外衣，正闭目养神闻香气，心动也，遂作《梅花曦》： 素手探君来，轻触眉间，香意渐浓如痴。簇簇枝头，欠粉红颜。 《颤梅赋》者，心随梅动，梅随心动如是。梅花盛开的季节，也许就要过了，未曾见卿却思卿，却之。 拂袖送卿去，当说何语？败絮残落黯然。青青草地，色彩斑斓。 二零一一年三月记","categories":[{"name":"poem","slug":"poem","permalink":"https://blog.yuhanle.com/categories/poem/"}],"tags":[{"name":"poem","slug":"poem","permalink":"https://blog.yuhanle.com/tags/poem/"}]},{"title":"之所以在这里安家","slug":"reason-why-home-here","date":"2014-05-20T00:00:00.000Z","updated":"2021-10-21T08:18:48.339Z","comments":true,"path":"2014/05/20/reason-why-home-here/","link":"","permalink":"https://blog.yuhanle.com/2014/05/20/reason-why-home-here/","excerpt":"我在不经意间触摸到周国平的《人的高贵在于灵魂》，洗礼之后分明感到：做一个有思想的人，用自己的思想走完生命的全程，定会精彩纷呈。","text":"我在不经意间触摸到周国平的《人的高贵在于灵魂》，洗礼之后分明感到：做一个有思想的人，用自己的思想走完生命的全程，定会精彩纷呈。 生命如草芥，有时很脆弱，但比宇宙间的任何东西都高贵的多，因为人有一棵能思想的灵魂。 物理学家阿基米德弥留之际，他认为：圆比生命重要；哲学家第欧根尼与亚历山大大帝偶遇，他认为：阳光比赫赫战功珍贵；英国作家王尔德到美国旅行，他认为：才华比金钱更有价值……他们有思想、有丰富的精神财富、有一种纯正的追求，使他们的灵魂变得高贵，散发出迷人的光彩。 也许有人会说：他们都是名人，有自己的思想理所应当；尔等鼠辈，苟且过活，怎谈有思想？哲学家周国平不会忘记，接着他又举生活中的两例： 例一：有一回，我乘车旅行。列车飞驰，车厢里闹哄哄的，旅客们在聊天、打牌、吃零食。一个少女躲在车厢的一角，全神贯注地读着一本书。她读得那么专心，还不时地往随身携带的一个小本子上记些什么，好像完全没有听见周围嘈杂的人声。望着她仿佛沐浴在一片光辉中的安静的侧影…… 例二：每当北京举办世界名画展览时，便有许多默默无闻的青年画家节衣缩食，自筹旅费，从全国各地风尘仆仆来到首都，在名画前流连忘返。 在吵闹的列车里全神贯注读书的少女，节衣缩食、自筹旅费的青年画家不就是我们自己？无论地位的高低、钱财的多寡，当人享受自己的思想之乐时他会显示出一种超越世俗，超越时空，超越一切的精神境界，去化身于思想的空气之中，尽情享受灵魂的高贵和纯洁。 做一个有思想的人：用眼睛观察，用头脑思索，用心灵感悟，用语言表达，认真对待生活的每一瞬间；做一个有思想的人：计划每一天，思考每一天，收获每一天，快乐每一天！这样我们的人生将因此丰盈充满！ 你可以从这里找到我 Weibo Email Github Twitter","categories":[{"name":"suibi","slug":"suibi","permalink":"https://blog.yuhanle.com/categories/suibi/"}],"tags":[{"name":"think","slug":"think","permalink":"https://blog.yuhanle.com/tags/think/"}]}]}